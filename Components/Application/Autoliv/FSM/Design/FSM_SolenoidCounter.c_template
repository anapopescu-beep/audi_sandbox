/******************************************************************************

AUTOLIV ELECTRONIC document.

-------------------------------------

Copyright Autoliv Inc. All rights reserved.

 *******************************************************************************
C-File Template Version:
Template version: AEM_PROCESS_1.25.00
Last template change: AEM_PROCESS_1.00.00
Template release date: 2022-09
 ******************************************************************************/
/*
$Revision: 1.5 $
$ProjectName: e:/MKSProjects/SBE/eCS/AUDI_MCC/Phase_01/View_Development/Components/Application/Autoliv/FSM/Design/project.pj $
 */

/*!****************************************************************************

details
   The purpose of this module is to handle the number of profiles (Lock,
   Unlock, Unlock confirmation).

 ******************************************************************************/

/******************************************************************************
EXTERNAL DEPENDENCIES
 ******************************************************************************/
#include "FSM.h"
#include "Rte_FSM.h"
#include "Nvp_Cfg.h"
#include "NvmIf.h"

/******************************************************************************
MODULE DEFINES
 ******************************************************************************/
/**
 *\brief
 *      Represent the index of the variable where the number of locks should be
 *      saved
 */
#define KU8_FSM_SOLENOID_NB_OF_LOCKS                  ((uint8) 0)

/**
 *\brief
 *      Represent the index of the variable where the number of unlocks should be
 *      saved
 */
#define KU8_FSM_SOLENOID_NB_OF_UNLOCKS                ((uint8) 1)

/**
 *\brief
 *      Represent the index of the variable where the number of unlock confirmation
 *      should be saved
 */
#define KU8_FSM_SOLENOID_NB_OF_UNLOCKS_CONFIRMATIONS  ((uint8) 2)

/******************************************************************************
MODULE TYPES
 ******************************************************************************/

/******************************************************************************
DECLARATION OF LOCAL FUNCTIONS
 ******************************************************************************/
LOCAL uint8 fsm_getCounterIndex(const uint8 ku8solenoidNumber, uint8 u8SolenoidModePosition);

/******************************************************************************
DEFINITION OF LOCAL VARIABLES
 ******************************************************************************/

/**
 * \brief
 *       The array is used to return the last solenoid state (lock or unlock)
 *       per every solenoid.
 * \initialization
 *       KU8_LOCK_STATE (uint8 0x00).
 * \range
 *       KU8_LOCK_STATE
 *       KU8_UNLOCK_STATE
 *       KU8_BACKUP_STATE
 *       KU8_DISABLED_STATE;
 */
LOCAL uint8 fsm_au8LastSolenoidState[KU8_MAX_SOLENOID_NB] =
{
      KU8_LOCK_STATE, KU8_LOCK_STATE, KU8_LOCK_STATE,
      KU8_LOCK_STATE, KU8_LOCK_STATE, KU8_LOCK_STATE
};

/**
 * \brief
 *       The array is used to return the last solenoid state confirmation per
 *       every solenoid.
 * \initialization
 *       KU8_FALSE (uint8 0x55).
 * \range
 *       KU8_FALSE
 *       KU8_TRUE;
 */
LOCAL uint8 fsm_au8LastSolenoidStateConfirmationStatus[KU8_MAX_SOLENOID_NB] = {
      KU8_FALSE, KU8_FALSE, KU8_FALSE, KU8_FALSE, KU8_FALSE, KU8_FALSE
};



/******************************************************************************
DEFINITION OF EXPORTED VARIABLES
 ******************************************************************************/

/******************************************************************************
DEFINITION OF LOCAL CONSTANT DATA
 ******************************************************************************/

/**
 * \brief
 *       The counter is used to number uS until copy data is in FSM.
 * \initialization
 *       KU64_SOLENOID_X_UNLOCK_CONFIRMED
 *       where X - the solenoid number.
 */
LOCAL const uint64 fsm_kau64SolenoidConfirmationStatusMASK[KU8_MAX_SOLENOID_NB] =
{
      /* Solenoid 1 */ (KU64_SOLENOID_1_UNLOCK_CONFIRMED ),
      /* Solenoid 2 */ (KU64_SOLENOID_2_UNLOCK_CONFIRMED ),
      /* Solenoid 3 */ (KU64_SOLENOID_3_UNLOCK_CONFIRMED ),
      /* Solenoid 4 */ (KU64_SOLENOID_4_UNLOCK_CONFIRMED ),
      /* Solenoid 5 */ (KU64_SOLENOID_5_UNLOCK_CONFIRMED ),
      /* Solenoid 6 */ (KU64_SOLENOID_6_UNLOCK_CONFIRMED )
};


/******************************************************************************
DEFINITION OF EXPORTED CONSTANT DATA
 ******************************************************************************/

/******************************************************************************
DEFINITION OF LOCAL CONSTANT DATA
 ******************************************************************************/

/******************************************************************************
MODULE FUNCTION-LIKE MACROS
 ******************************************************************************/

/******************************************************************************
DEFINITION OF LOCAL FUNCTION
 ******************************************************************************/


/**
 * \brief
 *       The function is used to return the NVM array index based on the solenoid
 *       number and data to be stored.
 * \inputparam
 *       Name: ku8solenoidNumber;
 *       Type: const uint8;
 *       Description: Solenoid ID;
 *       Range: 0..6;
 * \inputparam
 *       Name: u8SolenoidModePosition;
 *       Type: uint8;
 *       Description: Solenoid mode to be stored in the array;
 *       Range: 0..2;
 * \return
 *       Index of the array where to write data.
 * \dynamicaspectcaller
 *       FSM_manageSolenoidCounters
 * \dynamicaspectdescription
 *       API called by function FSM_manageSolenoidCounters.
 * \ddesignrequirement
 *       DSG_fsm_getCounterIndex
 * \archrequirement
 *       ARCH_SW_FSM_ptrpAsrOsServices_FSM_runMainFunction
 */
LOCAL INLINE uint8 fsm_getCounterIndex(const uint8 ku8solenoidNumber, uint8 u8SolenoidModePosition)
{
   switch (SolenoidModePosition)
   {
   /* Set case for first solenoid index - NO OF LOCKS */
   case KU8_ZERO:
      Save in CounterIndex variable the position from the NVP array where
      the number of locks for current solenoids will be saved;
   break;

   /* Set case for second solenoid index - NO OF UNLOCKS */
   case KU8_ONE:
       Save in CounterIndex variable the position from the NVP array where
      the number of unlocks for current solenoids will be saved;
   break;

   /* Set case for second solenoid index - NO OF CONFIRMATION STATUS */
   case KU8_TWO:
       Save in CounterIndex variable the position from the NVP array where
      the number of unlock confirmations for current solenoids will be saved;
   break;

   default:
       Set the CounterIndex to Zero;
   break;
   }

   return u8CounterIndex;
}

/******************************************************************************
DEFINITION OF APIs
 ******************************************************************************/
/**
 * \brief
 *        The function used to count in NVM variable number of locks,
 *        unlock and unlocks confirmation per every solenoid.
 * \inputparam
 *        None.
 * \outputparam
 *        None.
 * \exception
 *        This function has no exceptions.
 * \pre
 *        This function has no preconditions.
 * \post
 *        This function has no postconditions.
 * \return
 *        This function has no return.
 * \dynamicaspectcaller
 *        FSM_runMainFunction
 * \dynamicaspectdescription
 *        API called by function FSM_runMainFunction.
 * \constrains
 *        API must be called cyclic.
 * \ddesignrequirement
 *        DSG_FSM_manageSolenoidCounters
 * \archrequirement
 *        ARCH_SW_FSM_ptrpAsrOsServices_FSM_runMainFunction
 *        ARCH_SW_FSM_pseNvmIfServices_FSM_manageSolenoidCounters
 */
EXPORTED void FSM_manageSolenoidCounters(void)
{

   for (Each solenoid)
   {
      if(Solenoid is enabled)
      {
         if (The solenoid state has changed from the last call)
         {
            if((Solenoid state is LOCK_STATE) OR (Solenoid state is UNLOCK_STATE))
            {
               if (Solenoid state is LOCK_STATE)
               {
                  SolenoidNVPArrayIndex = fsm_getCounterIndex(SolenoidIndex, ZERO);
               }
               else if(Solenoid state is UNLOCK_STATE)
               {
                  SolenoidNVPArrayIndex = fsm_getCounterIndex(SolenoidIndex, ONE);
               }
               else
               {
                  Do nothing;
               }
               if (The value from SolenoidNVPArrayIndex position of NVP_au32ExecutedSolenoidCounters
                     does not overflow the Uint32 max value)
               {
                  Increment the counter value for SolenoidNVPArrayIndex position;
               }
            }
            else
            {
               Do nothing;
            }
         }
      }
      else
      {
         Do nothing;
      }

      FSM_runCheckModeStatus(Confirmation status, &u8SolenoidConfirmationStatus);

      if ((The solenoid has been changed confirmation status) AND
         (Current confirmation status is TRUE))
      {

         SolenoidNVPArrayIndex = fsm_getCounterIndex(SolenoidIndex, TWO);

         if (The value from SolenoidNVPArrayIndex position of NVP_au32ExecutedSolenoidCounters
            does not overflow the Uint32 max value)
         {
            Increment the counter value for SolenoidNVPArrayIndex position;
         }
      }

      Save the current solenoid state for next cycle;
      Save the current solenoid confirmation status for next cycle;
   }

   if (The number of function calls reached the limit for writing in EEPROM)
   {
      Write ExecutionCounters Block in EEPROM;
      Time achieved, reset counter;
   }
   else
   {
      Increment counter in order to count until desired time;
   }
}


/******************************************************************************
End Of File
 *****************************************************************************/
