/*********************************************************************************//*!
*   \file           T1_configGen.c
*
*   \brief          generated by T1_projGen.pl for project AUDI eCS
*                   using license POT1924 - LicID1141
*
*   \par Visibility
*                   External
*
*   \date           28.08.2023 at 15:24:02
*
*   \copyright      GLIWA embedded systems GmbH & Co. KG, Weilheim i.OB. All rights reserved
*************************************************************************************/

/*************************************************************************************
 * Command line flags:
 *********************
 -UserCfg=T1_UserCfg.inv
 -Cfg=T1_Cfg_CAN_FD.inv
 -OsPm=T1_TresosAutoCoreOS.pm
 -OsCfg=T1_OsCfg.inv
 ************************************************************************************/

/*----------------------------------------------------------------------------------*/
/*--- header includes --------------------------------------------------------------*/
/*----------------------------------------------------------------------------------*/

#include "T1_AppInterface.h"
#include "T1_bid.h"


/*----------------------------------------------------------------------------------*/
/*--- Config variables -------------------------------------------------------------*/
/*----------------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------------*/
/*--- Optimization pragmas for uniform code generation with widely-used compilers --*/
/*----------------------------------------------------------------------------------*/

#if defined __ghs__
#   pragma ghs O
#elif defined __TASKING__
#   pragma optimize 2
#elif defined __GNUC__ && ! defined __TMS470__ && ! defined __clang__ && ! defined __ARMCC_VERSION
#   pragma GCC optimize "O2"
#endif /* defined __ghs__ */

#if defined T1_ENABLE
#   if 1 != T1_NOF_CORES
#       error T1_NOF_CORES does not match generated configuration
#   endif /* 1 != T1_NOF_CORES */
#   if 15 < T1_NOF_CORES
#       error Only up to 15 cores
#   endif /* 15 < T1_NOF_CORES */
#endif /* defined T1_ENABLE */

#if defined T1_ENABLE && ! defined T1_DISABLE_T1_BASE
#   if ! defined T1_SID
#       error T1_SID must be defined
#   else
#       if T1_SID < 1 || 255 < T1_SID
#           error T1_SID must be > 0 and < 256
#       endif /* T1_SID < 1 || 255 < T1_SID */
/* Also check GCP Target ID which is derived from SID */
#       define T1_TID_CORE0 (T1_SID % 32u) /*! GCP Target ID for Core 0 */
#       if defined T1_NOF_CORES
#           if T1_TID_CORE0 < 1 || (32 - T1_NOF_CORES) < T1_TID_CORE0
#               error (T1_SID % 32) must be > 0 and <= (32 - T1_NOF_CORES)
#           endif /* T1_TID_CORE0 < 1 || (32 - T1_NOF_CORES) < T1_TID_CORE0 */
#       else /* ! defined T1_NOF_CORES */
#           if T1_TID_CORE0 < 1 || 31 < T1_TID_CORE0
#               error (T1_SID % 32) must be > 0 and < 32
#           endif /* T1_TID_CORE0 < 1 || 31 < T1_TID_CORE0 */
#       endif /* defined T1_NOF_CORES */
#       undef T1_TID_CORE0
#   endif /* ! defined T1_SID */

#if 8 == T1_CONT_NOF_VRTL_STPWS
#   define T1_FG_DO_V_STPW T1_FgDoVStpw8
#else /* 64 event chains */
#   define T1_FG_DO_V_STPW T1_FgDoVStpw64
#endif /* 8 == T1_CONT_NOF_VRTL_STPWS */

#   define T1_START_SEC_CONST_8
#   include "T1_MemMap.h"
T1_uint8_t const        T1_SEC_CONST_8 T1_commsCoreOffset = T1_COMMS_CORE_OFFSET;
#   if ! defined T1_EXTERNAL_BID
T1_EXTERN T1_uint8_t const T1_SEC_CONST_8 T1_CAT( T1_bid_, T1_BUILD_ID );
T1_uint8_t const        T1_SEC_CONST_8 T1_CAT( T1_bid_, T1_BUILD_ID ) = 0u;
#   endif /* ! defined T1_EXTERNAL_BID */
#   if ! defined T1_NO_INIT_SID
T1_uint8_t const        T1_SEC_CONST_8 T1_sid = T1_SID;
#   endif /* ! defined T1_NO_INIT_SID */
#   define T1_STOP_SEC_CONST_8
#   include "T1_MemMap.h"
#   if defined T1_NO_INIT_SID
#       define T1_START_SEC_VAR_POWER_ON_CLEARED_8
#       include "T1_MemMap.h"
T1_uint8_t              T1_SEC_VAR_POWER_ON_CLEARED_8 T1_sid;
#       define T1_STOP_SEC_VAR_POWER_ON_CLEARED_8
#       include "T1_MemMap.h"
#   endif /* defined T1_NO_INIT_SID */
#   define T1_START_SEC_CONST_16
#   include "T1_MemMap.h"
T1_timeouts_t const     T1_SEC_CONST_16 T1_timeouts = { T1_TIMEOUT_RX, T1_TIMEOUT_TX, T1_TIMEOUT_RESPONSE };
T1_uint16_t const       T1_SEC_CONST_16 T1_featureMaskCallbackMask = T1_FEATURE_MASK_CALLBACK_CORE0;
#   define T1_STOP_SEC_CONST_16
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
#   if ! defined T1_EXTERNAL_BID
T1_uint8_t const * const T1_SEC_CONST_32 T1_pBid = &T1_CAT( T1_bid_, T1_BUILD_ID );
T1_uint32_t const       T1_SEC_CONST_32 T1_bid = T1_CAT( T1_BUILD_ID, uL );
#   endif /* ! defined T1_EXTERNAL_BID */
T1_featureMask_t const  T1_SEC_CONST_32 T1_initFeatureMask = T1_INIT_FEATURE_MASK;
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"
#   define T1_START_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
T1_featureMask_t        T1_SEC_VAR_POWER_ON_CLEARED_32 T1_featureMask;
#   define T1_STOP_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
#   if defined T1_CPU32BIT || defined T1_CPU64BIT
#       define T1_START_SEC_CONST_8
#       include "T1_MemMap.h"
T1_uint8_t const        T1_SEC_CONST_8 T1_traceTimerBitLengthPC[1] =
{
    T1_TRACE_TIMER_BIT_LENGTH_CORE0
};
#       define T1_STOP_SEC_CONST_8
#       include "T1_MemMap.h"
#   endif /* defined T1_CPU32BIT || defined T1_CPU64BIT */
#   define T1_START_SEC_CONST_8
#   include "T1_MemMap.h"
T1_uint8_t const        T1_SEC_CONST_8 T1_nOfCores = T1_NOF_CORES;
#   define T1_STOP_SEC_CONST_8
#   include "T1_MemMap.h"
#   define T1_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
static T1_baseGlobals_t T1_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_baseGlobals0;
#   define T1_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
T1_baseGlobals_t * const T1_SEC_CONST_32 T1_baseGlobalsPC[1] =
{
    &T1_baseGlobals0
};
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"

#endif /* defined T1_ENABLE && ! defined T1_DISABLE_T1_BASE */

#if defined T1_ENABLE && ! defined T1_DISABLE_T1_CONT

#   define T1_START_SEC_CONST_8
#   include "T1_MemMap.h"
T1_bool_t const T1_SEC_CONST_8 T1_fgContEnabled =
#   if defined T1_FG_CONT
    T1_TRUE;
#   else
    T1_FALSE;
#   endif /* defined T1_FG_CONT */
#   define T1_STOP_SEC_CONST_8
#   include "T1_MemMap.h"


#   if ! defined T1_CONT_NOF_VRTL_STPWS
#       error T1_CONT_NOF_VRTL_STPWS not defined
#   else /* defined T1_CONT_NOF_VRTL_STPWS */
#       if 8 != T1_CONT_NOF_VRTL_STPWS && 64 != T1_CONT_NOF_VRTL_STPWS
#           error T1_CONT_NOF_VRTL_STPWS must be either 8 or 64
#       endif /* 8 != T1_CONT_NOF_VRTL_STPWS && 64 != T1_CONT_NOF_VRTL_STPWS */
#   endif /* ! defined T1_CONT_NOF_VRTL_STPWS */
#   if !(1 <= T1_CONT_NOF_FOCUS_MEASUREMENTS && T1_CONT_NOF_FOCUS_MEASUREMENTS <= 3)
#       error T1_CONT_NOF_FOCUS_MEASUREMENTS must be between one and three
#   endif /* !(1 <= T1_CONT_NOF_FOCUS_MEASUREMENTS && T1_CONT_NOF_FOCUS_MEASUREMENTS <= 3) */

/* Check that static T1 configuration parameters for core 0 are present */
#   if ! defined T1_TRACEBUFFER_ENTRIES_CORE0
#       error T1_TRACEBUFFER_ENTRIES_CORE0 must be defined
#   endif /* ! defined T1_TRACEBUFFER_ENTRIES_CORE0 */
#   if ! defined T1_NOF_USER_STPWS_CORE0
#       error T1_NOF_USER_STPWS_CORE0 must be defined
#   endif /* ! defined T1_NOF_USER_STPWS_CORE0 */
#   if ! defined T1_NOF_FLEX_STPWS_CORE0
#       error T1_NOF_FLEX_STPWS_CORE0 must be defined
#   endif /* ! defined T1_NOF_FLEX_STPWS_CORE0 */
#   if ! defined T1_NOF_FLEX_ADDRS_CORE0
#       error T1_NOF_FLEX_ADDRS_CORE0 must be defined
#   endif /* ! defined T1_NOF_FLEX_ADDRS_CORE0 */
#   if ! defined T1_NOF_TASKS_CORE0
#       error T1_NOF_TASKS_CORE0 must be defined
#   endif /* ! defined T1_NOF_TASKS_CORE0 */
#   if ! defined T1_NOF_CSRNS_CORE0
#       error T1_NOF_CSRNS_CORE0 must be defined
#   endif /* ! defined T1_NOF_CSRNS_CORE0 */
#   if ! defined T1_MAX_TASK_PREEMPTIONS_CORE0
#       error T1_MAX_TASK_PREEMPTIONS_CORE0 must be defined
#   endif /* ! defined T1_MAX_TASK_PREEMPTIONS_CORE0 */
#   if ! defined T1_OVERHEAD_CORE0_NS
#       error T1_OVERHEAD_CORE0_NS must be defined
#   endif /* T1_OVERHEAD_CORE0_NS */
#   if ! defined T1_FLEX_OVERHEAD_CORE0_NS
#       error T1_FLEX_OVERHEAD_CORE0_NS must be defined
#   endif /* T1_FLEX_OVERHEAD_CORE0_NS */
#   if ! defined T1_CPULOAD_TX_PERIOD_CORE0
#       error T1_CPULOAD_TX_PERIOD_CORE0 must be defined
#   endif /* T1_CPULOAD_TX_PERIOD_CORE0 */
#   if ! defined T1_CPULOAD_SAMPLES_CORE0
#       error T1_CPULOAD_SAMPLES_CORE0 must be defined
#   endif /* T1_CPULOAD_SAMPLES_CORE0 */

/* Check limits of T1 configuration parameters for core 0 */
#   if 65535 < T1_TRACEBUFFER_ENTRIES_CORE0
#       error Only up to 65535 trace buffer entries are allowed per core
#   endif /* 65535 < T1_TRACEBUFFER_ENTRIES_CORE0 */
#   if 255 < T1_NOF_USER_STPWS_CORE0 + T1_NOF_FLEX_STPWS_CORE0 + T1_CONT_NOF_VRTL_STPWS
#       error Only up to 255 stopwatches are allowed per core
#   endif /* 255 < T1_NOF_USER_STPWS_CORE0 + T1_NOF_FLEX_STPWS_CORE0 + T1_CONT_NOF_VRTL_STPWS */
#   if 255 < T1_NOF_FLEX_ADDRS_CORE0
#       error Only up to 255 T1.flex address buffer entries are allowed per core
#   endif /* 255 < T1_NOF_FLEX_ADDRS_CORE0 */
#   if 1024 < T1_NOF_TASKS_CORE0
#       error Only up to 1024 tasks and ISRs are allowed per core
#   endif /* 1024 < T1_NOF_TASKS_CORE0 */
#   if 64 < T1_NOF_CSRNS_CORE0
#       error Only up to 64 constraints are allowed per core
#   endif /* 64 < T1_NOF_CSRNS_CORE0 */
#   if 255 < T1_MAX_TASK_PREEMPTIONS_CORE0
#       error Only up to 255 tasks and ISRs pre-emptions are allowed per core
#   endif /* 255 < T1_MAX_TASK_PREEMPTIONS_CORE0 */
#   if T1_NOF_FLEX_ADDRS_CORE0 < T1_NOF_FLEX_STPWS_CORE0
#       error Number of T1.flex address buffer entries must be at least the number of T1.flex stopwatches
#   endif /* T1_NOF_FLEX_ADDRS_CORE0 < T1_NOF_FLEX_STPWS_CORE0 */
#   if ( T1_TRACEBUFFER_ENTRIES_CORE0_ % ( T1_MAX_TRACE_BUFFER_MSG_BYTES_ / T1_TRACE_ENTRY_BYTES ) == T1_NAMEBUFFER_ENTRIES )
#       error The trace buffer size must be changed for core 0 by at least 1 with the invocation parameter -traceBufferEntries
#   endif /* ( T1_TRACEBUFFER_ENTRIES_CORE0_ % ( T1_MAX_TRACE_BUFFER_MSG_BYTES_ / T1_TRACE_ENTRY_BYTES ) == T1_NAMEBUFFER_ENTRIES ) */
#   if 255 < T1_NOF_FLEXBUFFER_ENTRIES_CORE0
#       error Only up to 255 T1.flex buffer entries are allowed per core
#   endif /* 255 < T1_NOF_FLEXBUFFER_ENTRIES_CORE0 */

#   define T1_START_SEC_CONST_8
#   include "T1_MemMap.h"
T1_uint8_t const        T1_SEC_CONST_8 T1_nOfVrtlStpws = T1_CONT_NOF_VRTL_STPWS;
T1_uint8_t const        T1_SEC_CONST_8 T1_nOfFocusMeasurements = T1_CONT_NOF_FOCUS_MEASUREMENTS;
#   define T1_STOP_SEC_CONST_8
#   include "T1_MemMap.h"

#   define T1_START_SEC_CONST_16
#   include "T1_MemMap.h"
T1_uint16_t const       T1_SEC_CONST_16 T1_maxNofTasks = T1_MAX_NOF_TASKS;
#   define T1_STOP_SEC_CONST_16
#   include "T1_MemMap.h"
#   define T1_NOF_RESULTS_CORE0 \
    (T1_NOF_TASKS_CORE0 + 2*(T1_NOF_USER_STPWS_CORE0 + T1_NOF_FLEX_STPWS_CORE0 + T1_CONT_NOF_VRTL_STPWS) + 3u)

#   if ! defined T1_DISABLE_T1_FLEX && T1_NOF_FLEX_STPWS_CORE0 < 1
#       error At least one core 0 T1.flex stopwatch is required
#   endif /* T1_NOF_FLEX_STPWS_CORE0 */
#   define T1_START_SEC_VAR_POWER_ON_CLEARED_8
#   include "T1_MemMap.h"
T1_contStatus_t         T1_SEC_VAR_POWER_ON_CLEARED_8 T1_contBgStatusPC[1];
T1_contStatus_t         T1_SEC_VAR_POWER_ON_CLEARED_8 T1_contHandlerStatusPC[1];
#   define T1_STOP_SEC_VAR_POWER_ON_CLEARED_8
#   include "T1_MemMap.h"
#   if defined T1_FG_CONT
#       define T1_CHECKED_START_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
T1_taskFgData_t         T1_CHECKED_SEC_VAR_POWER_ON_CLEARED_32 T1_taskFgData[T1_MAX_NOF_TASKS];
#       define T1_CHECKED_STOP_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
#   endif /* defined T1_FG_CONT */
#   define T1_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
T1_contGlobals_t        T1_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_contGlobals0;
#   define T1_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
T1_contGlobals_t * const T1_SEC_CONST_32 T1_contGlobalsPC[1] =
{
    &T1_contGlobals0
};
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"
#   define T1_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
static T1_stpwData_t    T1_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_stpwData0[T1_NOF_USER_STPWS_CORE0 + T1_NOF_FLEX_STPWS_CORE0 + T1_CONT_NOF_VRTL_STPWS];
#   define T1_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
T1_stpwData_t * const   T1_SEC_CONST_32 T1_stpwDataPC[1] =
{
    T1_stpwData0
};
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"
#   if defined T1_FG_CONT
#       define T1_CHECKED_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
T1_stpwFgData_t         T1_CHECKED_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_stpwFgData0[T1_NOF_USER_STPWS_CORE0 + T1_NOF_FLEX_STPWS_CORE0 + T1_CONT_NOF_VRTL_STPWS];
#       define T1_CHECKED_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_stpwFgData_t * const T1_SEC_CONST_32 T1_stpwFgDataPC[1] =
{
    T1_stpwFgData0
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#       define T1_CHECKED_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
T1_csVStpwCache_t       T1_CHECKED_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_contCsVStpwCache0[T1_NOF_CS_VS];
#       define T1_CHECKED_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_csVStpwCache_t * const T1_SEC_CONST_32 T1_contCsVStpwCachePC[1] =
{
    T1_contCsVStpwCache0
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#       define T1_CHECKED_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
T1_vStpwMapping_t       T1_CHECKED_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_vStpw0[2*T1_CONT_NOF_VRTL_STPWS];
#       define T1_CHECKED_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_vStpwMapping_t * const T1_SEC_CONST_32 T1_vStpwPC[1] =
{
    T1_vStpw0
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#   else /* !defined T1_FG_CONT */
#       define T1_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
T1_csVStpwCache_t       T1_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_contCsVStpwCache0[T1_NOF_CS_VS];
#       define T1_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_csVStpwCache_t * const T1_SEC_CONST_32 T1_contCsVStpwCachePC[1] =
{
    T1_contCsVStpwCache0
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#       define T1_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
T1_vStpwMapping_t       T1_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_vStpw0[2*T1_CONT_NOF_VRTL_STPWS];
#       define T1_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_vStpwMapping_t * const T1_SEC_CONST_32 T1_vStpwPC[1] =
{
    T1_vStpw0
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#   endif /* defined T1_FG_CONT */
#   define T1_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
static T1_csrnData_t    T1_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_csrnData0[T1_NOF_CSRNS_CORE0];
#   define T1_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
T1_csrnData_t * const   T1_SEC_CONST_32 T1_csrnDataPC[1] =
{
    T1_csrnData0
};
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"
#   define T1_CHECKED_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
T1_resultTime_t         T1_CHECKED_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_resultBuffer0[((T1_NOF_RESULTS_CORE0 + 0xFu) & ~0xFu) + 1u];
#   define T1_CHECKED_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
T1_resultTime_t * const T1_SEC_CONST_32 T1_resultBufferPC[1] =
{
    T1_resultBuffer0
};
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"
#   define T1_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
static T1_taskStackElem_t T1_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_taskStack0[T1_MAX_TASK_PREEMPTIONS_CORE0+T1_TASK_STACK_OVERRUNS];
#   define T1_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
T1_taskStackElem_t * const T1_SEC_CONST_32 T1_taskStackPC[1] =
{
    T1_taskStack0
};
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"
#   define T1_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
T1_focusData_t          T1_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_focus0[T1_CONT_NOF_FOCUS_MEASUREMENTS];
#   define T1_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
T1_focusData_t * const  T1_SEC_CONST_32 T1_focusPC[1] =
{
    T1_focus0
};
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"
#   if defined T1_WAIT_RESUME
#       define T1_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
static T1_taskData_t    T1_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_taskData0[T1_NOF_TASKS_CORE0];
#       define T1_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_taskData_t * const   T1_SEC_CONST_32 T1_taskDataPC[1] =
{
    T1_taskData0
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#   else /* ! defined T1_WAIT_RESUME */
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_taskData_t     * const T1_SEC_CONST_32 T1_taskDataPC[1] = { T1_NULL };
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#   endif /* defined T1_WAIT_RESUME */
#   define T1_START_SEC_CONST_16
#   include "T1_MemMap.h"
T1_resultsIdx_t const   T1_SEC_CONST_16 T1_nOfResultsPC[1] =
{
    T1_NOF_RESULTS_CORE0
};
#   define T1_STOP_SEC_CONST_16
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_16
#   include "T1_MemMap.h"
T1_tick_t const         T1_SEC_CONST_16 T1_overheadPC[1] =
{
    (T1_tick_t)T1_NS_TO_TICKS( T1_OVERHEAD_CORE0_NS )
};
#   define T1_STOP_SEC_CONST_16
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_16
#   include "T1_MemMap.h"
T1_tick_t const         T1_SEC_CONST_16 T1_flexOverheadPC[1] =
{
    (T1_tick_t)T1_NS_TO_TICKS( T1_FLEX_OVERHEAD_CORE0_NS )
};
#   define T1_STOP_SEC_CONST_16
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_16
#   include "T1_MemMap.h"
T1_uint16_t const       T1_SEC_CONST_16 T1_cpuLoadTxPeriodPC[1] =
{
    T1_CPULOAD_TX_PERIOD_CORE0
};
#   define T1_STOP_SEC_CONST_16
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_16
#   include "T1_MemMap.h"
T1_uint16_t const       T1_SEC_CONST_16 T1_startOfFrameEventPC[1] =
{
    ((T1_uint16_t)T1_BSF_EVENT_ID_CORE0 << 10) | (T1_uint16_t)(T1_BSF_EVENT_INFO_CORE0 & 0x3FFu)
};
#   define T1_STOP_SEC_CONST_16
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_16
#   include "T1_MemMap.h"
T1_anaCapa_t const      T1_SEC_CONST_16 T1_defaultAnalysisCapacityPC[1] =
{
    T1_CONT_ANALYSIS_CAPACITY_CORE0
};
#   define T1_STOP_SEC_CONST_16
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_16
#   include "T1_MemMap.h"
T1_taskIdx_t const      T1_SEC_CONST_16 T1_nOfTasksPC[1] =
{
    T1_NOF_TASKS_CORE0
};
#   define T1_STOP_SEC_CONST_16
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_16
#   include "T1_MemMap.h"
T1_taskIdx_t const      T1_SEC_CONST_16 T1_bgTaskIdxPC[1] =
{
    T1_BACKGROUND_TASK_IDX_CORE0
};
#   define T1_STOP_SEC_CONST_16
#   include "T1_MemMap.h"
#   if ! defined T1_70618
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
T1_longTime_t const     T1_SEC_CONST_32 T1_38948[1] =
{
    0xFFFFFFFFuL
};
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"
#   endif /* ! defined T1_70618 */
#   define T1_START_SEC_CONST_8
#   include "T1_MemMap.h"
T1_uint8_t const        T1_SEC_CONST_8 T1_avgCPULoadSamplesPC[1] =
{
    T1_CPULOAD_SAMPLES_CORE0
};
#   define T1_STOP_SEC_CONST_8
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_8
#   include "T1_MemMap.h"
T1_stpwIdx_t const      T1_SEC_CONST_8 T1_nOfStpwsPC[1] =
{
    T1_NOF_USER_STPWS_CORE0 + T1_NOF_FLEX_STPWS_CORE0 + T1_CONT_NOF_VRTL_STPWS
};
#   define T1_STOP_SEC_CONST_8
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_8
#   include "T1_MemMap.h"
T1_stpwIdx_t const      T1_SEC_CONST_8 T1_nOfUserStpwsPC[1] =
{
    T1_NOF_USER_STPWS_CORE0
};
#   define T1_STOP_SEC_CONST_8
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_8
#   include "T1_MemMap.h"
T1_csrnIdx_t const      T1_SEC_CONST_8 T1_nOfCsrnsPC[1] =
{
    T1_NOF_CSRNS_CORE0
};
#   define T1_STOP_SEC_CONST_8
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_8
#   include "T1_MemMap.h"
T1_uint8_t const        T1_SEC_CONST_8 T1_nOfPreemptionsPC[1] =
{
    T1_MAX_TASK_PREEMPTIONS_CORE0
};
#   define T1_STOP_SEC_CONST_8
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_8
#   include "T1_MemMap.h"
T1_uint8_t const        T1_SEC_CONST_8 T1_cpuLoadThresholdPC[1] =
{
    T1_CPULOAD_THRESHOLD_256THS_CORE0
};
#   define T1_STOP_SEC_CONST_8
#   include "T1_MemMap.h"
#   if defined T1_CONT_DEFAULT_CONFIG_STOPWATCH
#       define T1_START_SEC_CONST_8
#       include "T1_MemMap.h"
#       if 1 != T1_NOF_USER_STPWS_CORE0
#           error T1_NOF_USER_STPWS_CORE0 does not match generated configuration
#       endif /* 1 != T1_NOF_USER_STPWS_CORE0 */
static T1_stpwConfig_t  T1_SEC_CONST_8 T1_stpwConfig0[1] =
{
    T1_CONT_GET_STOPWATCH(            T1_SW_CHECK_INTEGRATION_CORE0 ), /* Check Integration */
};
#       define T1_STOP_SEC_CONST_8
#       include "T1_MemMap.h"
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_stpwConfig_t * const T1_SEC_CONST_32 T1_stpwConfigPC[1] =
{
    T1_stpwConfig0
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#   endif /* defined T1_CONT_DEFAULT_CONFIG_STOPWATCH */

#   if defined T1_CONT_DEFAULT_CONFIG_CONSTRAINT
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
#       if 2 != T1_NOF_CSRNS_CORE0
#           error T1_NOF_CSRNS_CORE0 does not match generated configuration
#       endif /* 2 != T1_NOF_CSRNS_CORE0 */
static T1_csrnData_t const T1_SEC_CONST_32 T1_csrnConfig0[2] =
{
    T1_CONT_DEFAULT_CONFIG_CONSTRAINT,
    T1_CONT_DEFAULT_CONFIG_CONSTRAINT
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_csrnData_t const * const T1_SEC_CONST_32 T1_csrnConfigPC[1] =
{
    T1_csrnConfig0
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#   endif /* defined T1_CONT_DEFAULT_CONFIG_CONSTRAINT */

#endif /* defined T1_ENABLE && ! defined T1_DISABLE_T1_CONT */

#if defined T1_ENABLE && ! defined T1_DISABLE_T1_DELAY
#   define T1_START_SEC_CONST_8
#   include "T1_MemMap.h"
T1_uint8_t const        T1_SEC_CONST_8 T1_nOfDelaysPC[1] =
{
    T1_NOF_DELAYS_CORE0
};
#   define T1_STOP_SEC_CONST_8
#   include "T1_MemMap.h"
#   define T1_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
static T1_delay_t       T1_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_delays0[T1_NOF_DELAYS_CORE0];
#   define T1_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
T1_delay_t * const      T1_SEC_CONST_32 T1_delaysPC[1] =
{
    T1_delays0
};
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"
#   define T1_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
static T1_delayGlobals_t T1_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_delayGlobals0;
#   define T1_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
T1_delayGlobals_t * const T1_SEC_CONST_32 T1_delayGlobalsPC[1] =
{
    &T1_delayGlobals0
};
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"
#   if ! defined T1_DELAY_OVERWRITE_CONFIG
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
/*!
 * \brief Array with T1.delay configuration values use by T1_InitDelays() and
 *        T1_InitDelaysPC(), for system 0.
 */
#   if 1 != T1_NOF_DELAYS_CORE0
#       error T1_NOF_DELAYS_CORE0 does not match generated configuration
#   endif /* 1 != T1_NOF_DELAYS_CORE0 */
static T1_delay_t const T1_SEC_CONST_32 T1_delayConfig0[1] =
{
    /*   0 */ (T1_delay_t)0u /* 0us */, /* Check Integration */
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#   endif /* ! defined T1_DELAY_OVERWRITE_CONFIG */
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
T1_delay_t const * const T1_SEC_CONST_32 T1_delayConfigPC[1] =
{
    T1_delayConfig0
};
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"

#endif /* defined T1_ENABLE && ! defined T1_DISABLE_T1_DELAY */

#if defined T1_ENABLE && ! defined T1_DISABLE_T1_MOD
#   define T1_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
static T1_modGlobals_t  T1_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_modGlobals0;
#   define T1_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
T1_modGlobals_t * const T1_SEC_CONST_32 T1_modGlobalsPC[1] =
{
    &T1_modGlobals0
};
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"

#endif /* defined T1_ENABLE && ! defined T1_DISABLE_T1_MOD */

#if defined T1_ENABLE && ! defined T1_DISABLE_T1_FLEX

#   define T1_START_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
T1_uint32_t             T1_SEC_VAR_POWER_ON_CLEARED_32 T1_swdStart;
#   define T1_STOP_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"

#   if defined T1_TRICORE

#       define T1_DCX_CORE0_START_SEC_VAR_POWER_ON_CLEARED
#       include "T1_MemMap.h"
static T1_flexAddr_t    T1_DCX_CORE0_SEC_VAR_POWER_ON_CLEARED T1_dcx0[4];
#       define T1_DCX_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED
#       include "T1_MemMap.h"
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_flexAddr_t * const   T1_SEC_CONST_32 T1_dcxPC[1] =
{
    T1_dcx0
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#           define T1_START_SEC_CONST_32
#           include "T1_MemMap.h"
T1_pVoidVoid_t const    T1_SEC_CONST_32 T1_outerHandlerPC[1] =
{
    T1_OUTER_HANDLER_CORE0
};
#           define T1_STOP_SEC_CONST_32
#           include "T1_MemMap.h"

#   elif /* ! defined T1_TRICORE && */ defined T1_ARM7R || defined T1_ARM8R
#       define T1_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
T1_uint32_t             T1_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_abortSP0;
#       define T1_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_uint32_t * const     T1_SEC_CONST_32 T1_abortSPPC[1] =
{
    &T1_abortSP0
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"

#   elif /* ! defined T1_TRICORE && ! (defined T1_ARM7R || defined T1_ARM8R) && */ defined T1_ARM7M

#       if 0 <= 0 && 0 <= 1
#   define T1_START_SEC_CONST_8
#   include "T1_MemMap.h"
/* Flash Patch breakpoint architecture revision: version 1 */
T1_uint8_t const T1_SEC_CONST_8 T1_fpCtrlRev = 0u;
#   define T1_STOP_SEC_CONST_8
#   include "T1_MemMap.h"
#       else
#           error Invalid configuration, please check -cortexMFPBversion is 1 or 2
#       endif /* 0 <= 0 && 0 <= 1 */

#   endif /* defined T1_TRICORE / T1_ARM7R / T1_ARM8R / T1_ARM7M */

#   define T1_START_SEC_CONST_8
#   include "T1_MemMap.h"
T1_uint8_t const        T1_SEC_CONST_8 T1_nOfAddrsPC[1] =
{
    T1_NOF_FLEX_ADDRS_CORE0
};
#   define T1_STOP_SEC_CONST_8
#   include "T1_MemMap.h"
#    if defined T1_DISABLE_T1_CONT
#   define T1_START_SEC_CONST_8
#   include "T1_MemMap.h"
T1_stpwIdx_t const      T1_SEC_CONST_8 T1_nOfFlexStpwsPC[1] =
{
    255
};
#   define T1_STOP_SEC_CONST_8
#   include "T1_MemMap.h"
#    else /* ! defined T1_DISABLE_T1_CONT */
#   define T1_START_SEC_CONST_8
#   include "T1_MemMap.h"
T1_stpwIdx_t const      T1_SEC_CONST_8 T1_nOfFlexStpwsPC[1] =
{
    T1_NOF_FLEX_STPWS_CORE0
};
#   define T1_STOP_SEC_CONST_8
#   include "T1_MemMap.h"
#    endif /* defined T1_DISABLE_T1_CONT */
#   define T1_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
static T1_flexAddr_t    T1_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_addrs0[T1_FLEX_NOF_PRE_ADDRS + T1_NOF_FLEX_ADDRS_CORE0];
#   define T1_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
T1_flexAddr_t * const   T1_SEC_CONST_32 T1_addrsPC[1] =
{
    T1_addrs0
};
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"
#   define T1_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
T1_flexGlobals_t        T1_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_flexGlobals0;
#   define T1_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
T1_flexGlobals_t * const T1_SEC_CONST_32 T1_flexGlobalsPC[1] =
{
    &T1_flexGlobals0
};
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_8
#   include "T1_MemMap.h"
T1_uint8_t const        T1_SEC_CONST_8 T1_nOfFlexBufferEntriesPC[1] =
{
    T1_NOF_FLEXBUFFER_ENTRIES_CORE0
};
#   define T1_STOP_SEC_CONST_8
#   include "T1_MemMap.h"
#   define T1_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
static T1_uint32_t      T1_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_flexBuffer0[T1_NOF_FLEXBUFFER_ENTRIES_CORE0];
#   define T1_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
T1_uint32_t * const     T1_SEC_CONST_32 T1_flexBufferPC[1] =
{
    T1_flexBuffer0
};
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"

#endif /* defined T1_ENABLE && ! defined T1_DISABLE_T1_FLEX */

#if defined T1_ENABLE && ! defined T1_DISABLE_T1_SCOPE

#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
T1_fgContHelpers_t const * const T1_SEC_CONST_32 T1_pFgContHelpers =
#   if defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT
    &T1_46828;
#   else
    &T1_91054;
#   endif /* defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT */
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"

#   if defined T1_64BIT_TRACE_ENTRY
#       if 24 != 16
#           error traceTimeStampBitLength should be 24
#       endif /* 24 != 16 */
#   else /* ! defined T1_64BIT_TRACE_ENTRY */
#       if 16 != 16
#           error traceTimeStampBitLength should be 16
#       endif /* 16 != 16 */
#   endif /* defined T1_64BIT_TRACE_ENTRY */

#   if ! defined T1_SYNC_TIMER_WIDTH_BITS
#   endif /* ! defined T1_SYNC_TIMER_WIDTH_BITS */
#   if defined T1_EXTERNAL_TRACEBUFFER
#       error T1_EXTERNAL_TRACEBUFFER defined but -externalTraceBuffer not set to true
#   endif /* defined T1_EXTERNAL_TRACEBUFFER */
#   if ! defined T1_EXTERNAL_TRACEBUFFER && ! defined T1_TRACEBUFFER_ENTRIES_CORE0
#       error T1_TRACEBUFFER_ENTRIES_CORE0 not defined
#   endif /* ! defined T1_EXTERNAL_TRACEBUFFER && ! defined T1_TRACEBUFFER_ENTRIES_CORE0 */

#   if ! defined T1_PTIMER_CORE0
#define T1_PTIMER_CORE0 (0u)
#   endif /* defined T1_PTIMER_CORE0 */
#   define T1_START_SEC_CONST_8
#   include "T1_MemMap.h"
T1_uint8_t const        T1_SEC_CONST_8 T1_syncPeriodPC[1] =
{
    T1_SYNC_PERIOD_CORE0
};
#   define T1_STOP_SEC_CONST_8
#   include "T1_MemMap.h"
#   define T1_TRACEBUFFER_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
T1_traceEntry_t T1_FAR  T1_TRACEBUFFER_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_traceBuffer0[T1_TRACEBUFFER_ENTRIES_CORE0 + 1];
#   define T1_TRACEBUFFER_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
T1_traceEntry_t T1_FAR * const T1_SEC_CONST_32 T1_traceBufferPC[1] =
{
    T1_traceBuffer0
};
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"
#   define T1_START_SEC_CONST_16
#   include "T1_MemMap.h"
T1_nOfEntries_t const   T1_SEC_CONST_16 T1_traceEntriesPC[1] =
{
    T1_TRACEBUFFER_ENTRIES_CORE0
};
#   define T1_STOP_SEC_CONST_16
#   include "T1_MemMap.h"
#   if defined T1_NAMEBUFFER_ENABLE
#       define T1_TRACEBUFFER_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
static T1_traceEntry_t T1_FAR T1_TRACEBUFFER_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_nameBuffer0[T1_NAMEBUFFER_ENTRIES + 1];
#       define T1_TRACEBUFFER_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_traceEntry_t T1_FAR * const T1_SEC_CONST_32 T1_nameBufferPC[1] =
{
    T1_nameBuffer0
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#       define T1_START_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
void * T1_SEC_VAR_POWER_ON_CLEARED_32 T1_nameListHandlePC[T1_NOF_CORES];
#       define T1_STOP_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
#   endif /* defined T1_NAMEBUFFER_ENABLE */
#   if defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT
#       define T1_CHECKED_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
T1_scopeFgGlobals_t     T1_CHECKED_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_scopeFgGlobals0;
#       define T1_CHECKED_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_scopeFgGlobals_t * const T1_SEC_CONST_32 T1_scopeFgGlobalsPC[1] =
{
    &T1_scopeFgGlobals0
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_scopeGlobals_t * const T1_SEC_CONST_32 T1_scopeGlobalsPC[1] =
{
    &(T1_scopeFgGlobals0._)
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#       define T1_CORE0_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_scopeFgConsts_t      T1_CORE0_SEC_CONST_32 T1_scopeFgConsts0 = { { { (T1_scopeGlobals_t *)&T1_scopeFgGlobals0 }, T1_traceBuffer0 + 1, T1_TRACEBUFFER_ENTRIES_CORE0 - 1, T1_TRACE_TIMER_IS_SYNC_TIMER_CORE0, T1_SYNC_TIMER_WIDTH_BITS, T1_TRACE_TIMER_BIT_LENGTH_CORE0, 0u, T1_TRACEBUFFER_ENTRIES_CORE0, (T1_tickUint_t volatile const *)T1_PTIMER_CORE0, (T1_bool_t)T1_TRACE_56BIT_SYNC_TIMER, T1_CONT_NOF_VRTL_STPWS, T1_FG_CONT_ACT_EXTRA_ENTRIES, T1_FAR_TRACE_EVENT_NOSUSP_TIME, T1_FAR_TRACE_UINT32_REST_NOSUSP, T1_FAR_TRACE_UINT56_REST_NOSUSP }, T1_DISPATCH_CORE0, T1_MAX_NOF_TASKS, T1_NOF_USER_STPWS_CORE0, T1_NOF_USER_STPWS_CORE0 + T1_NOF_FLEX_STPWS_CORE0, T1_CONT_NOF_FOCUS_MEASUREMENTS, T1_NOF_CSRNS_CORE0, 0u, (T1_uint32_t)(0uL - T1_NOF_FLEX_STPWS_CORE0), T1_taskFgData, T1_focus0, T1_stpwFgData0, T1_contHandlerStatusPC + 0, T1_FG_DO_V_STPW, T1_resultBuffer0 + T1_NOF_TASKS_CORE0, T1_vStpw0, T1_vStpw0 + T1_CONT_NOF_VRTL_STPWS, T1_contCsVStpwCache0, T1_HANDLERS };
#       define T1_CORE0_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_scopeFgConsts_t * const T1_SEC_CONST_32 T1_scopeFgConstsPC[1] =
{
    &T1_scopeFgConsts0
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_scopeConsts_t * const T1_SEC_CONST_32 T1_scopeConstsPC[1] =
{
    &(T1_scopeFgConsts0._)
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#   else /* ! defined T1_FG_CONT || defined T1_DISABLE_T1_CONT */
#       define T1_CHECKED_CORE0_START_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
T1_scopeGlobals_t       T1_CHECKED_CORE0_SEC_VAR_POWER_ON_CLEARED_32 T1_scopeGlobals0;
#       define T1_CHECKED_CORE0_STOP_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_scopeGlobals_t * const T1_SEC_CONST_32 T1_scopeGlobalsPC[1] =
{
    &T1_scopeGlobals0
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#       define T1_CORE0_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_scopeConsts_t        T1_CORE0_SEC_CONST_32 T1_scopeConsts0 = { { &T1_scopeGlobals0 }, T1_traceBuffer0 + 1, T1_TRACEBUFFER_ENTRIES_CORE0 - 1, T1_TRACE_TIMER_IS_SYNC_TIMER_CORE0, T1_SYNC_TIMER_WIDTH_BITS, T1_TRACE_TIMER_BIT_LENGTH_CORE0, 0u, T1_TRACEBUFFER_ENTRIES_CORE0, (T1_tickUint_t volatile const *)T1_PTIMER_CORE0, (T1_bool_t)T1_TRACE_56BIT_SYNC_TIMER, 0u, 0u, T1_FAR_TRACE_EVENT_NOSUSP_TIME, T1_FAR_TRACE_UINT32_REST_NOSUSP, T1_FAR_TRACE_UINT56_REST_NOSUSP };
#       define T1_CORE0_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_scopeConsts_t * const T1_SEC_CONST_32 T1_scopeConstsPC[1] =
{
    &T1_scopeConsts0
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#   endif /* defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT */
#   if defined T1_CROSS_CORE_ACT && 1 < T1_NOF_CORES
#       define T1_START_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
/* Add one extra element as destination for writes with invalid task ID. */
T1_uint32_t T1_SEC_VAR_POWER_ON_CLEARED_32 T1_taskAct[T1_MAX_NOF_TASKS+1];
#       define T1_STOP_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
#   endif /* defined T1_CROSS_CORE_ACT && 1 < T1_NOF_CORES */
#   define T1_START_SEC_CONST_8
#   include "T1_MemMap.h"
T1_uint8_t const        T1_SEC_CONST_8 T1_syncTimerWidthBits = T1_SYNC_TIMER_WIDTH_BITS;
#   define T1_STOP_SEC_CONST_8
#   include "T1_MemMap.h"
#   if defined T1_DEFN_GET_TASK_NAME
#       define T1_START_SEC_CONST_8
#       include "T1_MemMap.h"
T1_char_t const * const T1_SEC_CONST_8 T1_taskNames[T1_MAX_NOF_TASKS] =
{
    "OsTask_Bsw_ReadWrite_AllProcess: ECC",
    "OsTask_AppIdle: ECC",
    "OsTask_Bsw_ComServices",
    "OsTask_Bsw_SysServices",
    "OsTask_Bsw_MemServices",
    "OsTask_Alv_ComHwAbs",
    "OsTask_Bsw_Init",
    "OsTask_Bsw_Events",
    "OsTask_Alv_eCSApp",
    "OsTask_Alv_Autotests",
    "OsTask_Alv_ComServices",
    "OsTask_Alv_EcuHwAbs",
    "OsTask_Alv_ModeMngmt",
    "OsTask_Bsw_ComEvents",
    "CAN0_ORED_IRQHandler: CAT2",
    "CAN0_Error_IRQHandler: CAT2",
    "CAN0_ORED_0_15_MB_IRQHandler: CAT2",
    "CAN0_ORED_16_31_MB_IRQHandler: CAT2",
    "LPIT_0_CH_1_ISR: CAT2",
    "LPTMR_ISR: CAT1",
    "PORTD_ISR: CAT1",
    "PORTE_ISR: CAT2",
    "LPIT_0_CH_2_ISR: CAT2",
    "Os_Counter_FTM0_0: CAT2"
};
#       define T1_STOP_SEC_CONST_8
#       include "T1_MemMap.h"

#       define T1_START_SEC_VAR_POWER_ON_CLEARED_16
#       include "T1_MemMap.h"
typedef T1_uint16_t T1_TaskIdListDescriptor_t;
T1_TaskIdListDescriptor_t T1_SEC_VAR_POWER_ON_CLEARED_16 T1_TaskIdListDescriptorPC[1];
#       define T1_STOP_SEC_VAR_POWER_ON_CLEARED_16
#       include "T1_MemMap.h"

#       define T1_START_SEC_CODE
#       include "T1_MemMap.h"
T1_char_t const T1_FARPTR T1_CODE T1_GetTaskName( T1_taskId_t taskId )
{
    if( (T1_taskId_t)T1_MAX_NOF_TASKS <= taskId )
    {
        return T1_NULL;
    }
    return T1_taskNames[taskId];
}

void * T1_CODE T1_InitTaskIdListPC( T1_uint8Least_t coreId )
{
    T1_TaskIdListDescriptor_t * const pTaskIdListDescriptor = T1_TaskIdListDescriptorPC + coreId;
    *pTaskIdListDescriptor = 0u;
    return (void *)pTaskIdListDescriptor;
}

T1_taskId_t T1_CODE T1_GetNextTaskId( void *pHandle )
{
    T1_TaskIdListDescriptor_t * const pTaskIdListDescriptor = (T1_TaskIdListDescriptor_t *)pHandle;
    T1_taskId_t taskId = (T1_taskId_t)*pTaskIdListDescriptor;

    while( taskId < (T1_taskId_t)T1_MAX_NOF_TASKS )
    {
        T1_taskId_t const validTaskId = taskId;
        T1_char_t const T1_FARPTR const pName = T1_GetTaskName( validTaskId );
        ++taskId;
        if( T1_NULL != pName && 0 != pName[0] )
        {
            *pTaskIdListDescriptor = taskId;
            return validTaskId;
        }
    }

    /* All task IDs have been returned. */
    return T1_INVALID_TASK_ID;
}

T1_status_t T1_CODE T1_RewindTaskId( void *pHandle )
{
    T1_TaskIdListDescriptor_t * const pTaskIdListDescriptor = (T1_TaskIdListDescriptor_t *)pHandle;
    T1_taskId_t taskId = (T1_taskId_t)*pTaskIdListDescriptor;

    while( 0 <= --taskId )
    {
        T1_char_t const T1_FARPTR const pName = T1_GetTaskName( taskId );
        if( T1_NULL != pName && 0 != pName[0] )
        {
            *pTaskIdListDescriptor = taskId;
            return T1_OK;
        }
    }
    *pTaskIdListDescriptor = 0u;
    return T1_FAILED;
}

T1_uint32_t T1_CODE T1_GetTaskOsIds( T1_taskId_t taskId, T1_uint32_t const **ppOsIds )
{
    (void)taskId;
    (void)ppOsIds;

    return 0uL;
}

#       define T1_STOP_SEC_CODE
#       include "T1_MemMap.h"
#   endif /* defined T1_DEFN_GET_TASK_NAME */

#   define T1_START_SEC_CODE
#   include "T1_MemMap.h"
void T1_CODE T1_InitNameBufferNoSuspPC(
#   if defined T1_NAMEBUFFER_ENABLE
    T1_uint8Least_t coreId
#   else /* ! defined T1_NAMEBUFFER_ENABLE */
/* polyspace<MISRA-C3:20.7:Justified:Low> obeying this rule here results in compiler errors */
    T1_UNUSED( T1_uint8Least_t coreId )
#   endif /* defined T1_NAMEBUFFER_ENABLE */
)
{
#   if defined T1_NAMEBUFFER_ENABLE
    T1_nameListHandlePC[coreId] = T1_InitTaskIdListPC( coreId );
#   endif /* defined T1_NAMEBUFFER_ENABLE */
}

T1_uint8_t T1_FARPTR T1_CODE T1_GetNameBufferPC(
#   if defined T1_NAMEBUFFER_ENABLE
    T1_uint8Least_t coreId
#   else /* ! defined T1_NAMEBUFFER_ENABLE */
/* polyspace<MISRA-C3:20.7:Justified:Low> obeying this rule here results in compiler errors */
    T1_UNUSED( T1_uint8Least_t coreId )
#   endif /* defined T1_NAMEBUFFER_ENABLE */
)
{
#   if defined T1_NAMEBUFFER_ENABLE
    T1_uint8Least_t counter;
    T1_uint8Least_t nOfEntriesPerLoop;
    T1_traceEntry_t * const pNameBuffer = T1_nameBufferPC[coreId] + 1;
    void * const pHandle = T1_nameListHandlePC[coreId];
    T1_scopeGlobals_t tmpScopeGlobals;
    T1_scopeConsts_t tmpScopeConsts =
    {
        { &tmpScopeGlobals },
        pNameBuffer,
        T1_NAMEBUFFER_ENTRIES - 1,
        T1_TRUE,
        32u,
        32u,
        coreId,
        T1_NAMEBUFFER_ENTRIES
    };
    T1_taskId_t taskId = T1_GetNextTaskId( pHandle );
    if( T1_INVALID_TASK_ID == taskId )
    {
        return T1_NULL;
    }

    counter = T1_NAMEBUFFER_ENTRIES;
    do
    {
        pNameBuffer[--counter] = 0uL;
    }
    while( 0u != counter );
#       if ! defined T1_CERT_RELEASE
    tmpScopeGlobals.pTraceBuffer = pNameBuffer;
    tmpScopeGlobals.bufferEntriesMinusOne = T1_NAMEBUFFER_ENTRIES - 1;
#       endif /* ! defined T1_CERT_RELEASE */
    tmpScopeGlobals.tB._.wrIdx = T1_NAMEBUFFER_ENTRIES - 1;
    tmpScopeGlobals.compareIdx = T1_NAMEBUFFER_ENTRIES - 1;
    tmpScopeGlobals.compareState = 0u; /* T1_COMPARE_WRAP */

    /* We assume that the data length of one task never overflows the buffer */
    /*
     * Safe with interrupts enabled because T1_TraceNameNoSuspTime_ and
     * T1_TraceOsIdsNoSuspTime_ cannot be pre-empted by code using tmpScopeGlobals
     */
    nOfEntriesPerLoop  = T1_TraceNameNoSuspTime_(  &tmpScopeConsts, taskId, 0uL );
    nOfEntriesPerLoop += T1_TraceOsIdsNoSuspTime_( &tmpScopeConsts, taskId, 0uL );
    counter = T1_NAMEBUFFER_ENTRIES - nOfEntriesPerLoop;
    tmpScopeGlobals.compareState = 2u; /* T1_COMPARE_TRACING_DISABLED */

    while( 0u != counter && T1_INVALID_TASK_ID != (taskId = T1_GetNextTaskId( pHandle )) )
    {
        /*
         * Safe with interrupts enabled because T1_TraceNameNoSuspTime_ and
         * T1_TraceOsIdsNoSuspTime_ cannot be pre-empted by code using tmpScopeGlobals
         */
        nOfEntriesPerLoop  = T1_TraceNameNoSuspTime_(  &tmpScopeConsts, taskId, 0uL );
        nOfEntriesPerLoop += T1_TraceOsIdsNoSuspTime_( &tmpScopeConsts, taskId, 0uL );
        if( nOfEntriesPerLoop <= counter )
        {
            counter -= nOfEntriesPerLoop;
        }
        else
        {
            /*
             * This else-part is executed when T1_nameBufferPC[coreId] overflows.
             * Writing to the buffer did not wrap-around because pCompare is set to
             * the last entry and compareState is set to T1_COMPARE_TRACING_DISABLED.
             * But the last, incomplete entries need to be overwritten with T1_EMPTY.
             */
            if( T1_OK == T1_RewindTaskId( pHandle ) )
            {
                do
                {
                    pNameBuffer[tmpScopeGlobals.tB._.wrIdx--] = 0u;
                }
                while( 0u != --counter );
            }
        }
    }

    return (T1_uint8_t T1_FARPTR)pNameBuffer;

#   else /* ! defined T1_NAMEBUFFER_ENABLE */
    return T1_NULL;
#   endif /* defined T1_NAMEBUFFER_ENABLE */
}

/*!
 * \brief Callout function to translate a duration in synchronization timer ticks to
 *        trace timer ticks.
 * \param[in] coreId    use the trace timer tick duration for this core
 * \param[in] getSwTime the GET stopwatch duration to convert
 * \returns             converted result
 *
 * Translate a duration in synchronization timer ticks to trace timer ticks. This is
 * used as a callout from library code and should not normally be called directly
 * from user code.
 *
 */
T1_longTime_t T1_CODE T1_SyncToTraceTimerPC( T1_uint8Least_t coreId, T1_longTime_t getSwTime )
{
#   if defined T1_SYNC_TO_TRACE_TIME
    (void)coreId;    /* Suppress warnings since coreId is not actually used */
    return T1_SYNC_TO_TRACE_TIME( getSwTime );
#   else /* Different trace timer frequencies on different cores */
    switch( coreId )
    {
    default:    return T1_SYNC_TO_TRACE_TIME_CORE0( getSwTime );
    }
#   endif /* defined T1_SYNC_TO_TRACE_TIME */
}
#   define T1_STOP_SEC_CODE
#   include "T1_MemMap.h"


#   define T1_START_SEC_CODE_FAST
#   include "T1_MemMap.h"
/*!
 * \brief Callout to translate a duration in trace timer ticks to synchronization timer ticks.
 * \param[in] coreId    use the trace timer tick duration for this core
 * \param[in] traceTime the trace timer value to convert
 * \returns             converted result
 *
 * Translate a value in trace timer ticks to synchronization timer ticks. This is
 * used as a callout from library code and should not normally be called directly
 * from user code.
 *
 */
#if defined T1_GCC_ADAPT
#   undef T1_TraceToSyncTimerPC
T1_CODE_FAST( T1_tickUint_t ) T1_NOINLINE T1_CODE_OPT T1_TraceToSyncTimerPC
                            ( T1_uint8Least_t coreId, T1_tickUint_t traceTime )
{
    return T1_NearTraceToSyncTimerPC( coreId, traceTime );
}
T1_CODE_FAST( T1_uint32_t ) T1_CODE_OPT T1_NearTraceToSyncTimerPC
#else /* ! defined T1_GCC_ADAPT */
T1_CODE_FAST( T1_uint32_t ) T1_CODE_OPT T1_TraceToSyncTimerPC
#endif /* defined T1_GCC_ADAPT */
                            ( T1_uint8Least_t coreId, T1_tickUint_t traceTime )
{
    (void)coreId;    /* Suppress warnings since coreId is not actually used */
    return T1_TRACE_TO_SYNC_TIME( traceTime );
}
#   if defined T1_NEAR_CODE_FAST
T1_uint32_t T1_NOINLINE T1_NEAR_CODE_FAST __attribute__((alias("T1_TraceToSyncTimerPC")))
T1_NearTraceToSyncTimerPC( T1_uint8Least_t coreId, T1_tickUint_t traceTime );
#   endif /* defined T1_NEAR_CODE_FAST */

#   if defined __ghs__
/* Green Hills __noinline keyword can be disabled, so use the pragma instead. */
#       pragma ghs startnoinline
#   endif /* defined __ghs__ */

T1_CODE_FAST( void ) T1_NOINLINE T1_CODE_OPT
T1_SWStopNoSusp__( T1_scopeConsts_t    *pScopeConsts,
                   T1_eventInfo_t       eventInfo,
                   T1_uint32_t          syncData )
{
    T1_SWStopNoSuspTime__(  pScopeConsts,
                            syncData,
                            T1_NearTraceEventNoSusp__( pScopeConsts, eventInfo ) );
}

#if defined T1_NEAR_CODE_FAST
void T1_NOINLINE T1_NEAR_CODE_FAST T1_CODE_OPT __attribute__((alias("T1_SWStopNoSusp__")))
T1_NearSWStopNoSusp__( T1_scopeConsts_t *pScopeConsts, T1_eventInfo_t eventInfo, T1_uint32_t syncData );
#endif /* defined T1_NEAR_CODE_FAST */

T1_CODE_FAST( void ) T1_NOINLINE T1_CODE_OPT
T1_SWStopNoSuspTime__(  T1_scopeConsts_t   *pScopeConsts,
                        T1_uint32_t         syncData,
                        T1_tickUint_t       traceTime   )
{
    T1_uint32_t syncTime;
#   if T1_ALL_TRACE_TIMERS_ARE_SYNC_TIMER && 28 <= T1_SYNC_TIMER_WIDTH_BITS
    syncTime = traceTime;
#   else /* ! T1_ALL_TRACE_TIMERS_ARE_SYNC_TIMER || T1_SYNC_TIMER_WIDTH_BITS < 28 */
#       if T1_ANY_TRACE_TIMER_IS_SYNC_TIMER && 28 <= T1_SYNC_TIMER_WIDTH_BITS
    if( pScopeConsts->syncTimerIsTraceTimer )
    {
        syncTime = traceTime;
    }
    else
#       endif /* T1_ANY_TRACE_TIMER_IS_SYNC_TIMER && 28 <= T1_SYNC_TIMER_WIDTH_BITS */
    {
        T1_tickUint_t const traceTimerBase = pScopeConsts->_.pScopeGlobals->_.traceTime;
        T1_uint32_t const syncTimerBase = pScopeConsts->_.pScopeGlobals->_.syncTime;
        T1_tickUint_t const traceTimerDelta = traceTime - traceTimerBase;
        syncTime = syncTimerBase +
#       if defined T1_TRACE_TO_SYNC_TIME
                            T1_TRACE_TO_SYNC_TIME( traceTimerDelta );
#       elif 28 <= T1_SYNC_TIMER_WIDTH_BITS /* Cannot be a sync timer */
                            T1_TRACE_TO_NOT_SYNC_TIME_PC( pScopeConsts->coreId, traceTimerDelta );
#       else /* Can be a sync timer */
                            T1_TRACE_TO_SYNC_TIME_PC( pScopeConsts->coreId, traceTimerDelta );
#       endif /* defined T1_TRACE_TO_SYNC_TIME */
    }
#   endif /* T1_ALL_TRACE_TIMERS_ARE_SYNC_TIMER && 28 <= T1_SYNC_TIMER_WIDTH_BITS */

#   if defined T1_CONT_REMOTE
    (void)T1_NearTraceUint32RestNoSuspRC
#   elif defined T1_FG_CONT
    (void)T1_NearTraceUint32RestNoSuspFg
#   else
    (void)T1_NearTraceUint32RestNoSusp
#   endif /* defined T1_CONT_REMOTE */
                (   pScopeConsts,
                    T1_TRUNC_SYNC_DATA( (syncTime << 4) - syncData ) );
}

#if defined T1_NEAR_CODE_FAST
void T1_NOINLINE T1_NEAR_CODE_FAST T1_CODE_OPT __attribute__((alias("T1_SWStopNoSuspTime__")))
T1_NearSWStopNoSuspTime__( T1_scopeConsts_t *pScopeConsts, T1_uint32_t syncData, T1_tickUint_t traceTime );
#endif /* defined T1_NEAR_CODE_FAST */

#   if defined __ghs__
#       pragma ghs endnoinline
#   endif /* defined __ghs__ */

#   if ! T1_ALL_TRACE_TIMERS_ARE_SYNC_TIMER || T1_SYNC_TIMER_WIDTH_BITS < 32
T1_CODE_FAST( T1_uint32_t ) T1_CODE_OPT
T1_TraceToSyncNoSusp__( T1_scopeConsts_t *pScopeConsts, T1_tickUint_t traceTime )
{
#       if T1_ANY_TRACE_TIMER_IS_SYNC_TIMER && 32 <= T1_SYNC_TIMER_WIDTH_BITS
    if( pScopeConsts->syncTimerIsTraceTimer )
    {
        return (T1_uint32_t)traceTime;
    }
#       endif /* T1_ANY_TRACE_TIMER_IS_SYNC_TIMER && 32 <= T1_SYNC_TIMER_WIDTH_BITS */
    {
        T1_tickUint_t const traceTimerDelta = traceTime
                                        - pScopeConsts->_.pScopeGlobals->_.traceTime;
        T1_uint32_t const syncTimerBase = pScopeConsts->_.pScopeGlobals->_.syncTime;
        return syncTimerBase +
#       if defined T1_TRACE_TO_SYNC_TIME
                            T1_TRACE_TO_SYNC_TIME( traceTimerDelta );
#       elif 28 <= T1_SYNC_TIMER_WIDTH_BITS /* Cannot be a sync timer */
                            T1_TRACE_TO_NOT_SYNC_TIME_PC( pScopeConsts->coreId, traceTimerDelta );
#       else /* Can be a sync timer */
                            T1_TRACE_TO_SYNC_TIME_PC( pScopeConsts->coreId, traceTimerDelta );
#       endif /* defined T1_TRACE_TO_SYNC_TIME */
    }
}
#   endif /* ! T1_ALL_TRACE_TIMERS_ARE_SYNC_TIMER || T1_SYNC_TIMER_WIDTH_BITS < 32 */

#   if T1_TRACE_56BIT_SYNC_TIMER
T1_CODE_FAST( void ) T1_TraceSync56RestNoSusp( T1_scopeConsts_t *pScopeConsts,
                                               T1_tickUint_t traceTime )
{
    T1_tickUint_t const traceTimerDelta = traceTime
                                    - pScopeConsts->_.pScopeGlobals->_.traceTime;
    T1_uint64_t const syncTimerBase =
        pScopeConsts->_.pScopeGlobals->_.syncTime
        | ( (T1_uint64_t)( pScopeConsts->_.pScopeGlobals->syncTimeHigh ) << 32 );
    T1_uint64_t const syncTimer = syncTimerBase +
#   if defined T1_TRACE_TO_SYNC_TIME
                        T1_TRACE_TO_SYNC_TIME( traceTimerDelta );
#   elif 28 <= T1_SYNC_TIMER_WIDTH_BITS /* Cannot be a sync timer */
                        T1_TRACE_TO_NOT_SYNC_TIME_PC( pScopeConsts->coreId, traceTimerDelta );
#   else /* Can be a sync timer */
                        T1_TRACE_TO_SYNC_TIME_PC( pScopeConsts->coreId, traceTimerDelta );
#   endif /* defined T1_TRACE_TO_SYNC_TIME */
    (void)T1_NEAR_TRACE_UINT56_REST_NOSUSP( pScopeConsts,
                                            (T1_uint32_t)syncTimer,
                                            (T1_uint32_t)( syncTimer >> 32 ) );
}
#   endif /* T1_TRACE_56BIT_SYNC_TIMER */

#   define T1_STOP_SEC_CODE_FAST
#   include "T1_MemMap.h"

#   if defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT
#       if 1 == T1_NOF_CORES || (defined T1_GET_RAW_TIME && defined T1_RAW_TO_TRACE_TIME)
#           define T1_START_SEC_CODE_FAST
#           include "T1_MemMap.h"
T1_CODE_FAST( T1_tickUint_t ) T1_CODE_OPT T1_Dispatch0( T1_scopeFgConsts_t *pScopeConsts, T1_eventInfo_t eventInfo, T1_uint8Least_t handlerIdx )
{
    T1_tickUint_t const traceTime = T1_RAW_TO_TRACE_TIME_UNMASKED_CORE0( T1_GET_RAW_TIME_CORE0( ) );
    T1_DISPATCH_PC( 0, pScopeConsts, eventInfo, traceTime, handlerIdx, pScopeGlobals->cpuLoadMultiplier_, 16 < T1_TRACE_TIMER_BIT_LENGTH_CORE0, Near );
}
#           define T1_STOP_SEC_CODE_FAST
#           include "T1_MemMap.h"
#       else /* 1 != T1_NOF_CORES && (! defined T1_GET_RAW_TIME || ! defined T1_RAW_TO_TRACE_TIME) */
#           define T1_CORE0_START_SEC_CODE
#           include "T1_MemMap.h"
T1_CODE_FAST( T1_tickUint_t ) T1_CODE_OPT T1_Dispatch0( T1_scopeFgConsts_t *pScopeConsts, T1_eventInfo_t eventInfo, T1_uint8Least_t handlerIdx )
{
    T1_tickUint_t const traceTime = T1_RAW_TO_TRACE_TIME_UNMASKED_CORE0( T1_GET_RAW_TIME_CORE0( ) );
    T1_DISPATCH_PC( 0, pScopeConsts, eventInfo, traceTime, handlerIdx, pScopeGlobals->cpuLoadMultiplier_, 16 < T1_TRACE_TIMER_BIT_LENGTH_CORE0, Near );
}
#           define T1_CORE0_STOP_SEC_CODE
#           include "T1_MemMap.h"

#       endif /* 1 == T1_NOF_CORES || (defined T1_GET_RAW_TIME && defined T1_RAW_TO_TRACE_TIME) */

#       define T1_START_SEC_CODE
#       include "T1_MemMap.h"
/* polyspace<MISRA-C3:20.7:Justified:Low> obeying this rule here results in compiler errors */
T1_tickUint_t T1_CODE T1_DispatchTimePC( T1_UNUSED( T1_uint8Least_t coreId ), T1_eventInfo_t eventInfo, T1_uint8Least_t handlerIdx, T1_tickUint_t now )
{
    T1_scopeFgConsts_t * const pScopeConsts = T1_CORE_ID_TO_SCOPE_FG_CONSTS( 0 );
    T1_DISPATCH_PC( 0, pScopeConsts, eventInfo, now, handlerIdx, pScopeGlobals->cpuLoadMultiplier_, 16 < T1_TRACE_TIMER_BIT_LENGTH_CORE0, );
}
#       define T1_STOP_SEC_CODE
#       include "T1_MemMap.h"

#   endif /* defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT */


#   if ! defined T1_DISABLE_T1_SCOPE
#       define T1_START_SEC_CODE
#       include "T1_MemMap.h"
void T1_CODE
T1_TraceScopeUploadNoSuspTime__( T1_scopeConsts_t *pScopeConsts, T1_eventInfo_t eventInfo, T1_tickUint_t now )
{
#       if defined T1_FG_CONT && defined T1_TEST_ONLY
    T1_TraceScopeUploadNoSuspTimeIntern( (T1_scopeFgConsts_t *)pScopeConsts, eventInfo, now );
#       else /* ! defined T1_FG_CONT || ! defined T1_TEST_ONLY */
    (void)T1_FAR_TRACE_EVENT_NOSUSP_TIME( pScopeConsts, eventInfo, now );
#       endif /* defined T1_FG_CONT && defined T1_TEST_ONLY */
}
#       define T1_STOP_SEC_CODE
#       include "T1_MemMap.h"
#   endif /* defined T1_DISABLE_T1_SCOPE */

#   if defined T1_64BIT_TRACE_ENTRY && defined T1_CPU64BIT
#       define ALIGN    0uL,
#   elif ! defined T1_64BIT_TRACE_ENTRY && (defined T1_CPU32BIT || defined T1_CPU64BIT)
#       define ALIGN    0u,
#   else
#       define ALIGN
#   endif

#   define T1_INIT_FG_CONT_SCOPE_CORE0                                        \
{                                                                                   \
    (T1_uint16_t)T1_NS_TO_TICKS_CORE0( T1_OVERHEAD_CORE0_NS ),      \
    (T1_uint16_t)(T1_NS_TO_TICKS_CORE0( T1_FLEX_OVERHEAD_CORE0_NS ) + T1_NS_TO_TICKS_CORE0( T1_OVERHEAD_CORE0_NS )), \
    (T1_uint16_t)(T1_NS_TO_TICKS_CORE0( T1_FLEX_OVERHEAD_CORE0_NS ) >> 1), \
    (T1_uint16_t)0u,                                                                \
    T1_BSF_EVENT_TO_MASK( T1_BSF_EVENT_ID_CORE0 ),                            \
    ALIGN                                                                           \
    T1_COMBINE_EVENT_INFO( T1_BSF_EVENT_ID_CORE0, T1_BSF_EVENT_INFO_CORE0 ) \
}
#   if defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
T1_scopeFgGlobalsInit_t const T1_SEC_CONST_32 T1_initFgContScopePC[1] =
{
    T1_INIT_FG_CONT_SCOPE_CORE0
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
T1_taskFgInitData_t const T1_SEC_CONST_32 T1_initFgContTasks[T1_MAX_NOF_TASKS] =
{
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    },
    {
        T1_TT_FG_TASK | 0x00u,
        0u,
        0u
    }
};
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"

#       define T1_CHECKED_START_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"
T1_uint32_t T1_SEC_VAR_POWER_ON_CLEARED_32 T1_actExtra[T1_FG_CONT_ACT_EXTRA_ENTRIES];
#       define T1_CHECKED_STOP_SEC_VAR_POWER_ON_CLEARED_32
#       include "T1_MemMap.h"

#   endif /* if defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT */

#endif /* defined T1_ENABLE && ! defined T1_DISABLE_T1_SCOPE */
#if defined T1_ENABLE && ! defined T1_DISABLE_T1_FLEX
#   define T1_START_SEC_CONST_32
#   include "T1_MemMap.h"
void (* const (* const T1_pCodeBpHandlers)[T1_NOF_CODE_BP_HANDLERS])( T1_EXCEPTION_HANDLER_PARAMS ) T1_SEC_CONST_32 =
#   if defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT
    &T1_00885;
#   else /* ! defined T1_FG_CONT || defined T1_DISABLE_T1_CONT */
    &T1_23656;
#   endif /* defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT */

void (* const (* const T1_pDataBpHandlers)[T1_NOF_DATA_BP_HANDLERS][T1_NOF_DATA_BP_KINDS])( T1_EXCEPTION_HANDLER_PARAMS ) T1_SEC_CONST_32 =
#   if defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT
    &T1_95477;
#   else /* ! defined T1_FG_CONT || defined T1_DISABLE_T1_CONT */
#       if 1 == T1_NOF_CORES
    &T1_42046;
#       else /* 1 < T1_NOF_CORES */
    &T1_23656;
#       endif /* 1 == T1_NOF_CORES */
#   endif /* defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT */

void (* const (* const T1_pSwHandlers)[T1_NOF_SW_HANDLERS])( T1_EXCEPTION_HANDLER_PARAMS ) T1_SEC_CONST_32 =
#   if defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT
    &T1_55015;
#   else /* ! defined T1_FG_CONT || defined T1_DISABLE_T1_CONT */
    &T1_73409;
#   endif /* defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT */

void (* const T1_pHandlerTraceEvent)( T1_uint8Least_t coreId, T1_uint32_t val ) T1_SEC_CONST_32 =
#   if defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT
    T1_15112;
#   else /* ! defined T1_FG_CONT || defined T1_DISABLE_T1_CONT */
    T1_30318;
#   endif /* defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT */

void (* const T1_pNcaMaybeStoreCodeAddress)( T1_flexGlobals_t *pFlexGlobals, T1_flexAddr_t addr ) T1_SEC_CONST_32 =
#   if defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT
    T1_40585;
#   else /* ! defined T1_FG_CONT || defined T1_DISABLE_T1_CONT */
    T1_57687;
#   endif /* defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT */

void (* const T1_pCftMaybeStoreCodeAddress)( T1_flexGlobals_t *pFlexGlobals, T1_flexAddr_t addr ) T1_SEC_CONST_32 =
#   if defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT
    T1_35804;
#   else /* ! defined T1_FG_CONT || defined T1_DISABLE_T1_CONT */
    T1_20590;
#   endif /* defined T1_FG_CONT && ! defined T1_DISABLE_T1_CONT */
#   define T1_STOP_SEC_CONST_32
#   include "T1_MemMap.h"

#   define T1_START_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"
void (*T1_pMaybeStoreCodeAddress)( T1_flexGlobals_t *pFlexGlobals, T1_flexAddr_t addr ) T1_SEC_VAR_POWER_ON_CLEARED_32;
#   define T1_STOP_SEC_VAR_POWER_ON_CLEARED_32
#   include "T1_MemMap.h"

#   if defined T1_TRICORE
#       define T1_START_SEC_CONST_32
#       include "T1_MemMap.h"
void (* const T1_pAppContextManagementHandlerPC[T1_NOF_CORES])( void ) T1_SEC_CONST_32 =
{
    T1_NULL
};
#       define T1_STOP_SEC_CONST_32
#       include "T1_MemMap.h"
#   endif /* defined T1_TRICORE */
#endif /* defined T1_ENABLE && ! defined T1_DISABLE_T1_FLEX */
