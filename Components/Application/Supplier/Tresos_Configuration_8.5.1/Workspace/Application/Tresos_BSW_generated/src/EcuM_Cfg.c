/**
 * \file
 *
 * \brief AUTOSAR EcuM
 *
 * This file contains the implementation of the AUTOSAR
 * module EcuM.
 *
 * \author Elektrobit Automotive GmbH, 91058 Erlangen, Germany
 *
 * Copyright 2005 - 2018 Elektrobit Automotive GmbH
 * All rights exclusively reserved for Elektrobit Automotive GmbH,
 * unless expressly agreed to otherwise.
 */
/* !LINKSTO ECUM121_Conf,1 */



/*==================[inclusions]============================================*/

#include <Mcu.h>          /* MCU module types                  */
/* Macro for preventing redundant declarations of EcuM_MainFunction(),
 * since the function prototype is also generated by the SchM. */
#define ECUM_INTERNAL_USE
#include <EcuM.h>
#include <EcuM_Int.h>     /* EcuM private header               */
#include <EcuM_Cfg.h>
#include <SchM_EcuM.h>           /* SchM API for EcuM */
#include <Dem.h>
#include <MyMcuArchClock.h>
#include <Port.h>
#include <Can.h>
#include <Fls.h>
#include <Fee.h>
#include <Adc.h>
#include <AdcIf.h>
#include <Pwm.h>
#include <DioIf.h>
#include <Spi.h>
#include <SBC.h>




/*------------------[MultiCore variables]-----------------------------------------------*/


#if (ECUM_MULTICORE_ENABLED == TRUE)
/** \brief Returns the core ID that is currently active. */
#define ECUM_GET_CORE_ID() GetCoreID()
#else
#define ECUM_GET_CORE_ID() 0U
#endif /* (ECUM_MULTICORE_ENABLED == TRUE) */

/*==================[macros]================================================*/

/*==================[type definitions]======================================*/

/*==================[external function declarations]========================*/

/*==================[internal function declarations]========================*/

#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>

STATIC FUNC(void, ECUM_CODE) EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_0 (void);
STATIC FUNC(void, ECUM_CODE) EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_0 (void);

#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>

/*==================[external constants]====================================*/
#define ECUM_START_SEC_CONST_8
#include <EcuM_MemMap.h>

/* Wake-up Source ID mapping */
CONST(uint8, ECUM_CONST) EcuM_WksMapping[ECUM_WKS_ID_MAXVAL + 1U] =
{
  0U,
  1U,
  2U,
  3U,
  4U,
  5U,
};

#define ECUM_STOP_SEC_CONST_8
#include <EcuM_MemMap.h>


#define ECUM_START_SEC_CONST_16
#include <EcuM_MemMap.h>

/* !LINKSTO EcuM4004,1 */
/* timeout for wakeup source */
CONST(uint16, ECUM_CONST) EcuM_WksValTimeout[ECUM_WKSCONFIGNUM] =
{
  0U, /* Timeout for wakeup source ECUM_WKSOURCE_POWER */
  0U, /* Timeout for wakeup source ECUM_WKSOURCE_RESET */
  0U, /* Timeout for wakeup source ECUM_WKSOURCE_INTERNAL_RESET */
  0U, /* Timeout for wakeup source ECUM_WKSOURCE_INTERNAL_WDG */
  0U, /* Timeout for wakeup source ECUM_WKSOURCE_EXTERNAL_WDG */
  500U, /* Timeout for wakeup source ECUM_WKSOURCE_CAN */
};

#define ECUM_STOP_SEC_CONST_16
#include <EcuM_MemMap.h>

#define ECUM_START_SEC_CONST_UNSPECIFIED
#include <EcuM_MemMap.h>


/*------------------[Wakeup Sources]----------------------------------------*/

/* configurations of Wakeup Sources */
CONST(EcuM_WksConfigType, ECUM_CONST) EcuM_WksConfigList[ECUM_WKSCONFIGNUM] =
{
/* !LINKSTO EcuM2166,1 */
  /* ECUM_WKSOURCE_POWER */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    ECUM_NO_COMM_CH,   /* No associated ComM Channel */
    MCU_POWER_ON_RESET,   /* Reset Reason */
    0U   /* Wakeup Source Id */
  },
  /* ECUM_WKSOURCE_RESET */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    ECUM_NO_COMM_CH,   /* No associated ComM Channel */
    MCU_RESET_UNDEFINED,   /* No valid Reset Reason */
    1U   /* Wakeup Source Id */
  },
  /* ECUM_WKSOURCE_INTERNAL_RESET */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    ECUM_NO_COMM_CH,   /* No associated ComM Channel */
    MCU_RESET_UNDEFINED,   /* No valid Reset Reason */
    2U   /* Wakeup Source Id */
  },
  /* ECUM_WKSOURCE_INTERNAL_WDG */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    ECUM_NO_COMM_CH,   /* No associated ComM Channel */
    MCU_RESET_UNDEFINED,   /* No valid Reset Reason */
    3U   /* Wakeup Source Id */
  },
  /* ECUM_WKSOURCE_EXTERNAL_WDG */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    ECUM_NO_COMM_CH,   /* No associated ComM Channel */
    MCU_RESET_UNDEFINED,   /* No valid Reset Reason */
    4U   /* Wakeup Source Id */
  },
  /* ECUM_WKSOURCE_CAN */
  {
    ECUM_NO_COMM_PNC,   /* No associated ComM PNC */
    0U,   /* ComM Channel Id */
    MCU_RESET_UNDEFINED,   /* Reset Reason */
    5U   /* Wakeup Source Id */
  },
};

/*------------------[Sleep Modes]-------------------------------------------*/
CONST(EcuM_SleepModeConfigType, ECUM_CONST) EcuM_SleepModeConfigList[ECUM_SLEEPMODECONFIGNUM] =
{

  {
    
    /* Sleep mode: EcuMSleepMode_0, ID: 0 */
    #if (defined McuConf_McuModeSettingConf_McuModeSettingConf_RUN)
    McuConf_McuModeSettingConf_McuModeSettingConf_RUN,
    #else
    McuModeSettingConf_RUN,
    #endif
    FALSE, /* Suspend flag */
    ECUM_EcuMSleepMode_0_WKUP_MASK /* Wakeup event mask of sleep mode EcuMSleepMode_0 */
  },

};

/*------------------[Errors reporting to Dem]-------------------------------------------*/



/*------------------[EcuMShutdownCause]-------------------------------------------*/

#if (ECUM_DEV_ERROR_DETECT == STD_ON)
/* Array holding the configured values of Shutdown Causes */
CONST(EcuM_ShutdownCauseType, ECUM_CONST)
   EcuM_ValidShutdownCause[ECUM_SHUTDOWNCAUSECONFIGNUM] =
{
  EcuMConf_EcuMShutdownCause_ECUM_CAUSE_UNKNOWN,
  EcuMConf_EcuMShutdownCause_ECUM_CAUSE_ECU_STATE,
  EcuMConf_EcuMShutdownCause_ECUM_CAUSE_WDGM,
  EcuMConf_EcuMShutdownCause_ECUM_CAUSE_DCM,
};
#endif

#define ECUM_STOP_SEC_CONST_UNSPECIFIED
#include <EcuM_MemMap.h>
/*==================[internal constants]====================================*/

/*==================[external data]=========================================*/

/*==================[internal data]=========================================*/

/*------------[EcuM Multi-Core internal data]---------------*/

/* !LINKSTO EcuM.Impl.MemoryMapping.InstanceData,1 */
#define ECUM_START_SEC_VAR_CLEARED_UNSPECIFIED
#include <EcuM_MemMap.h>

/** \brief The EcuM core specific context data.
 **
 ** This variable holds the core-specific run time data of the EcuM
 ** master core. */
STATIC VAR(EcuM_CoreContextType, ECUM_VAR) EcuM_Core0_Context;

#define ECUM_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include <EcuM_MemMap.h>


/*==================[external function definitions]=========================*/
#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>
/*------------------[Callouts from STARTUP state]---------------------------*/

/* No content for EcuM_AL_DriverInitZero() configured */

/* Configured Initialization List One items */
FUNC(void, ECUM_CODE) EcuM_DefaultInitListOne(void)
{
  /* *** Call service PreInit of module Dem *** */
  Dem_PreInit(NULL_PTR);
  /* *** Call service Init of module Mcu *** */
  Mcu_Init(NULL_PTR);
  /* *** Call service Init of module MyMcuArchClock *** */
  MyMcuArchClock_Init();
  /* *** Call service Init of module Port *** */
  Port_Init(NULL_PTR);
  /* *** Call service Init of module Can *** */
  Can_Init(NULL_PTR);
  /* *** Call service Init of module Fls *** */
  Fls_Init(&FlsConfigSet_TDK_4G);
  /* *** Call service Init of module Fee *** */
  Fee_Init(NULL_PTR);
  /* *** Call service Init of module Adc *** */
  Adc_Init(NULL_PTR);
  /* *** Call service Calib of module AdcIf *** */
  AdcIf_Calib();
  /* *** Call service Init of module Pwm *** */
  Pwm_Init(NULL_PTR);
  /* *** Call service Init of module DioIf *** */
  DioIf_Init();
  /* *** Call service Init of module Spi *** */
  Spi_Init(&SpiDriver_TDK_4G);
  /* *** Call service Init of module SBC *** */
  SBC_Init();
}

/*------------------[Callouts from SLEEP state]--------------------------*/
#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>
/*==================[internal function definitions]=========================*/

/*------------[EcuM Multi-Core internal function definitions]---------------*/

#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>

FUNC(void, ECUM_CODE) EcuM_EnterExclusiveArea(void)
{

  EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_0();
}

FUNC(void, ECUM_CODE) EcuM_ExitExclusiveArea(void)
{

  EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_0();
}

STATIC FUNC(void, ECUM_CODE) EcuM_Enter_SCHM_ECUM_EXCLUSIVE_AREA_0 (void)
{
  /* SchM function has no return value */
  SchM_Enter_EcuM_SCHM_ECUM_EXCLUSIVE_AREA_0();
}

STATIC FUNC(void, ECUM_CODE) EcuM_Exit_SCHM_ECUM_EXCLUSIVE_AREA_0 (void)
{
  /* SchM function has no return value */
  SchM_Exit_EcuM_SCHM_ECUM_EXCLUSIVE_AREA_0();
}


#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>

#if (ECUM_MULTICORE_ENABLED == TRUE)

#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>

FUNC(void, ECUM_CODE) EcuM_GetResourceScheduler(void)
{
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();

  switch(coreID)
  {
    case 0:
    {
#if (OS_AUTOSAROS_VER != 5)
      (void)GetResource(RES_SCHEDULER);
#else
      (void)GetResource(RES_SCHEDULER_0);
#endif
      break;
    }
    default:
    {
      break;
    }
  }
}

FUNC(void, ECUM_CODE) EcuM_ReleaseResourceScheduler(void)
{
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();

  switch(coreID)
  {
    case 0:
    {
#if (OS_AUTOSAROS_VER != 5)
      (void)ReleaseResource(RES_SCHEDULER);
#else
      (void)ReleaseResource(RES_SCHEDULER_0);
#endif
      break;
    }
    default:
    {
      /* ERROR */
      break;
    }
  }
}

FUNC(Std_ReturnType, ECUM_CODE) EcuM_Send_SlaveCoreReadyPort(void)
{
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();

  Std_ReturnType ret = E_OK;
  Std_ReturnType schMSendResult;

  if (ECUM_CORE_ID_MASTER != coreID)
  {
      switch(coreID)
      {
        default:
        {
          break;
        }
      }
  }

  return ret;
}

/* !LINKSTO EcuM.Impl.EcuM_MasterCoreSync,1 */
/* !LINKSTO EcuM.Impl.Source.SlaveMasterCoreSync,1 */
FUNC(Std_ReturnType, ECUM_CODE) EcuM_MasterCoreSync(void)
{
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();
  EcuM_SyncActionType syncResult = ECUM_CONTINUE_SYNC;
  Std_ReturnType schMReceiveResult = E_NOT_OK;

  if (ECUM_CORE_ID_MASTER != coreID)
  {
    boolean EcuM_IsMasterReady = FALSE;
    do
    {
      switch(coreID)
      {
        default:
        {
          break;
        }
      }
      if (TRUE == EcuM_IsMasterReady)
      {
        break;
      }
      /* !LINKSTO EcuM.Impl.EcuM_OnCoreSync,1 */
      syncResult = EcuM_OnCoreSync();
    } while (syncResult != ECUM_ABORT_SYNC);
  }

  return ((ECUM_CONTINUE_SYNC == syncResult) && (schMReceiveResult == SCHM_E_OK)) ? E_OK : E_NOT_OK;
}
#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>


#endif /* (ECUM_MULTICORE_ENABLED == TRUE) */

#define ECUM_START_SEC_CODE
#include <EcuM_MemMap.h>
/* !LINKSTO EcuM.Impl.EcuM_GetCoreInstance,1 */
FUNC(P2VAR(EcuM_CoreContextType, ECUM_VAR, ECUM_APPL_DATA), ECUM_CODE) EcuM_GetCoreInstance(void)
{
  P2VAR(EcuM_CoreContextType, ECUM_VAR, ECUM_APPL_DATA) inst = NULL_PTR;

#if (ECUM_MULTICORE_ENABLED == TRUE)
  const EcuMCoreIdType coreID = ECUM_GET_CORE_ID();

  switch(coreID)
  {
    case 0:
    {
      inst = &EcuM_Core0_Context;
      break;
    }
    default:
    {
      /* No EcuM instance exists for core. */
      break;
    }
  }
#else
  inst = &EcuM_Core0_Context;
#endif

  return inst;
}

/* !LINKSTO EcuM.Impl.EcuM_GetMasterCoreInstance,1 */
FUNC(P2VAR(EcuM_CoreContextType, ECUM_VAR, ECUM_APPL_DATA), ECUM_CODE) EcuM_GetMasterCoreInstance(void)
{
  return &EcuM_Core0_Context;
}
#define ECUM_STOP_SEC_CODE
#include <EcuM_MemMap.h>



/*==================[end of file]===========================================*/

