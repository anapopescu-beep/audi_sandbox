/*@!Encoding:1252*/
/*------------------------------------------------------------------------------
                                IMPORT LIBRARY
 ------------------------------------------------------------------------------*/
/* To include all the libraries used by the .capl script. */
/* WARNING: Some things such as diagnostic functions are different from project
to project, change those according to your project requirements */
includes
{
 
  #include "S:\\Tools\\CANoe\\Config\\ECS_AUDI_INT\\Includes\\Debugger_Defines.cin"
  #include "S:\\Tools\\CANoe\\Config\\ECS_AUDI_INT\\Includes\\Debugger_Functions.cin"
  #include "S:\\Tools\\CANoe\\Config\\ECS_AUDI_INT\\Includes\\Project_Functions.cin"
  #include "S:\\Tools\\CANoe\\Config\\ECS_AUDI_INT\\Includes\\Diagnostic_Functions.cin"
}

/*------------------------------------------------------------------------------
                                    GLOBALS
 ------------------------------------------------------------------------------*/
/* To declare the constants used throurough the entire module, and global variables */
variables
{

/*----------------------------Global Variables---------------------------------*/
 float fSignalValue;
 int64 signal_value;
 int64 variable_value;
}


/*------------------------------------------------------------------------------
                                TEST FUNCTIONS
------------------------------------------------------------------------------*/
/*------------------------- Test Preconditions ------------------------------*/
/* For operations to ensure the correct execution of the test case, such as IGN_ON,
checking that CAN communication is present, etc.
/* Varies from module to module, use from Helper_Functions.cin only the ones you need */
testfunction RunPreTs()
{
  DisplayRequirementsInfo();
  AddTestSetupInformation();
  
  PreTS_StartLogging();
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  
  testStep("", "Delete all breakpoint from debugger.");
  debugger_deleteAllBreakpoints();
  
  testStep("", "Reset the debugger.");
  debugger_reset();
  
  testStep("", "Run the debugger.");
  debugger_run();
}

/*------------------------- Test Postconditions ------------------------------*/
/* For operations to ensure that after the test case was executed, the enviroment
would go back to a blank state, to be ready for the next test step in queue. Call it a Cleanup phase. */
testfunction RunPostTs()
{
  stopLogging("TestCaseLogASC");
  stopLogging("TestCaseLogBLF");
}

testcase InitTestModule()
{
  ConfigureTestModuleInformation();
  strncpy(cLogPathAndName, "S:\\Tools\\CANoe\\Config\\ECS_AUDI_INT\\Logs\\",  elcount(cLogPathAndName));
}


/*------------------------------------------------------------------------------
                                TEST EXECUTION
------------------------------------------------------------------------------*/

testcase Sw_Int_CIL_RP_IF_AB_eCS_Aktuatortest_BF_XIX_Grundumfang_XIX_eCS_01()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based, Interface Test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_BF_XIX_Grundumfang_XIX_eCS");
  AddRequirementInfo("ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_BF_XIX_Grundumfang_XIX_eCS", "- Interface used to read if and on demand selt-test has been requested for each solenoid - The on demand self-test for seat BF will trigger the unlock/lock for solenoids 3 && 4.");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization"); // If the first parameter of testStep() is "Step", the arguments will be written in the specification file and "Step" argument will be numbered by 1 for each iteration.
  RunPreTs();
//====================================================
  
   testCaseComment("Action: ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_BF_XIX_Grundumfang_XIX_eCS");
   testStep("STEP", "Set a breakpoint in function CIL_runCANToAppli in order to call interface used to read if and on demand selt-test has been requested for solenoids 3. --> BP reached");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "5");
   testStep("", "Run the debugger.");
   debugger_run();
  debugger_run();
   debugger_run();
  debugger_run();
   debugger_run();
   debugger_waitUntilBPisReached("12000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");
  
   testStep("STEP", "Set a breakpoint in function Rte_COMCbk_SGis_AB_Gurtschloss_BF1_1312R in order where check Rte State --> BP reached");
   debugger_setRelativeFunctionBpAtLine("Rte_COMCbk_SGis_AB_Gurtschloss_BF1_1312R", "4");
   debugger_run();
  TestWaitForTimeout(1000);
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
   debugger_deleteAllBreakpoints();
  
   testStep("STEP", "Set a breakpoint in function Rte_COMCbk_SGis_AB_Gurtschloss_BF1_1312R in order to read Internal Buffer --> BP reached");
   debugger_setRelativeFunctionBpAtLine("Rte_COMCbk_SGis_AB_Gurtschloss_BF1_1312R", "9");
   debugger_run();
  TestWaitForTimeout(1000);
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
//   debugger_deleteAllBreakpoints();
  
   testStep("STEP", "Read the Internal Buffer value");
   debugger_readLocalVariable("Rte_InternalBuffer");
   ExpectedTestResult(debugger_result, "0x1", "Variable read");

   testStep("STEP", "Set a breakpoint in function CIL_runCANToAppli in order to check ODST for Solenoid 3. --> BP reached");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "5");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");
  
   testStep("STEP", "Read the Buckle Status Tx value for solenoid 3");
   debugger_readLocalVariable("(CIL_u8BuckleStatusTx)[2]");
   ExpectedTestResult(debugger_result, "0x1", "Variable read");
 
//  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase Sw_Int_CIL_RP_IF_AB_eCS_Aktuatortest_BF_XIX_Grundumfang_XIX_eCS_02()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based, Interface Test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_BF_XIX_Grundumfang_XIX_eCS");
  AddRequirementInfo("ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_BF_XIX_Grundumfang_XIX_eCS", "- Interface used to read if and on demand selt-test has been requested for each solenoid - The on demand self-test for seat BF will trigger the unlock/lock for solenoids 3 && 4.");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization"); // If the first parameter of testStep() is "Step", the arguments will be written in the specification file and "Step" argument will be numbered by 1 for each iteration.
  RunPreTs();
//====================================================
  
   testCaseComment("Action: ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_BF_XIX_Grundumfang_XIX_eCS");
   testStep("STEP", "Set a breakpoint in function CIL_runCANToAppli in order to call interface used to read if and on demand selt-test has been requested for solenoids 4. --> BP reached");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "5");
   testStep("", "Run the debugger.");
   debugger_run();
  debugger_run();
   debugger_run();
  debugger_run();
   debugger_run();
   debugger_waitUntilBPisReached("12000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");
    
   testStep("STEP", "Set a breakpoint in function Rte_COMCbk_SGis_AB_Gurtschloss_FA1_1312R in order where check Rte State --> BP reached");
   debugger_setRelativeFunctionBpAtLine("Rte_COMCbk_SGis_AB_Gurtschloss_BF1_1312R", "4");
   debugger_run();
  TestWaitForTimeout(1000);
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
   debugger_deleteAllBreakpoints();
  
  testStep("STEP", "Set a breakpoint in function Rte_COMCbk_SGis_AB_Gurtschloss_FA1_1312R in order to read Internal Buffer --> BP reached");
   debugger_setRelativeFunctionBpAtLine("Rte_COMCbk_SGis_AB_Gurtschloss_BF1_1312R", "9");
   debugger_run();
  TestWaitForTimeout(1000);
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
  
   testStep("STEP", "Read the Internal Buffer value");
   debugger_readLocalVariable("Rte_InternalBuffer");
   ExpectedTestResult(debugger_result, "0x1", "Variable read");

   testStep("STEP", "Set a breakpoint in function CIL_runCANToAppli in order to check ODST for Solenoid 4. --> BP reached");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "5");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");
  
   testStep("STEP", "Read the Buckle Status Tx value for solenoid 4");
   debugger_readLocalVariable("(CIL_u8BuckleStatusTx)[3]");
   ExpectedTestResult(debugger_result, "0x1", "Variable read");
 
//  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase Sw_Int_CIL_RP_IF_AB_eCS_Aktuatortest_FA_XIX_Grundumfang_XIX_eCS_01()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based, Interface Test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CILRP_IF_AB_eCS_Aktuatortest_FA_XIX_Grundumfang_XIX_eCS ");
  AddRequirementInfo("ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_FA_XIX_Grundumfang_XIX_eCS", "Interface used to read if and on demand selt-test has been requested for each solenoid - The on demand self-test for seat FA will trigger the unlock/lock for solenoids 1 && 2.");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization"); // If the first parameter of testStep() is "Step", the arguments will be written in the specification file and "Step" argument will be numbered by 1 for each iteration.
  RunPreTs();
//====================================================
  
    testCaseComment("Action: ARCH_SW_CILRP_IF_AB_eCS_Aktuatortest_FA_XIX_Grundumfang_XIX_eCS");
   testStep("STEP", "Set a breakpoint in function CIL_runCANToAppli in order to call interface used to read if and on demand selt-test has been requested for solenoids 1. --> BP reached");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "1");
   testStep("", "Run the debugger.");
   debugger_run();
  debugger_run();
   debugger_run();
  debugger_run();
   debugger_run();
  debugger_run();
   debugger_waitUntilBPisReached("12000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");
   debugger_deleteAllBreakpoints();
  
  testStep("STEP", "Set a breakpoint in function Rte_COMCbk_SGis_AB_Gurtschloss_BF1_1312R in order to read Internal Buffer --> BP reached");
   debugger_setRelativeFunctionBpAtLine("Rte_COMCbk_SGis_AB_Gurtschloss_FA1_1312R", "9");
   debugger_run();
  TestWaitForTimeout(1000);
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
  
   testStep("STEP", "Read the Internal Buffer value");
   debugger_readLocalVariable("Rte_InternalBuffer");
   ExpectedTestResult(debugger_result, "0x1", "Variable read");

   testStep("STEP", "Set a breakpoint in function CIL_runCANToAppli in order to check ODST for Solenoid 1. --> BP reached");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "5");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");
  
   testStep("STEP", "Read the Buckle Status Tx value for solenoid 1");
   debugger_readLocalVariable("(CIL_u8BuckleStatusTx)[0]");
   ExpectedTestResult(debugger_result, "0x1", "Variable read");
 
//  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase Sw_Int_CIL_RP_IF_AB_eCS_Aktuatortest_FA_XIX_Grundumfang_XIX_eCS_02()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based, Interface Test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CILRP_IF_AB_eCS_Aktuatortest_FA_XIX_Grundumfang_XIX_eCS ");
  AddRequirementInfo("ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_FA_XIX_Grundumfang_XIX_eCS", "Interface used to read if and on demand selt-test has been requested for each solenoid - The on demand self-test for seat FA will trigger the unlock/lock for solenoids 1 && 2.");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization"); // If the first parameter of testStep() is "Step", the arguments will be written in the specification file and "Step" argument will be numbered by 1 for each iteration.
  RunPreTs();
//====================================================
  
    testCaseComment("Action: ARCH_SW_CILRP_IF_AB_eCS_Aktuatortest_FA_XIX_Grundumfang_XIX_eCS");
   testStep("STEP", "Set a breakpoint in function CIL_runCANToAppli in order to call interface used to read if and on demand selt-test has been requested for solenoids 2. --> BP reached");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "1");
   testStep("", "Run the debugger.");
   debugger_run();
  debugger_run();
   debugger_run();
  debugger_run();
   debugger_run();
  debugger_run();
   debugger_waitUntilBPisReached("12000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");
   debugger_deleteAllBreakpoints();
  
  testStep("STEP", "Set a breakpoint in function Rte_COMCbk_SGis_AB_Gurtschloss_BF1_1312R in order to read Internal Buffer --> BP reached");
   debugger_setRelativeFunctionBpAtLine("Rte_COMCbk_SGis_AB_Gurtschloss_FA1_1312R", "9");
   debugger_run();
  TestWaitForTimeout(1000);
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
  
   testStep("STEP", "Read the Internal Buffer value");
   debugger_readLocalVariable("Rte_InternalBuffer");
   ExpectedTestResult(debugger_result, "0x1", "Variable read");

   testStep("STEP", "Set a breakpoint in function CIL_runCANToAppli in order to check ODST for Solenoid 2. --> BP reached");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "5");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");
  
   testStep("STEP", "Read the Buckle Status Tx value for solenoid 2");
   debugger_readLocalVariable("(CIL_u8BuckleStatusTx)[1]");
   ExpectedTestResult(debugger_result, "0x1", "Variable read"); 
 
//  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase Sw_Int_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_BF_XIX_Grundumfang_XIX_eCS_01()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based, Interface Test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_BF_XIX_Grundumfang_XIX_eCS");
  AddRequirementInfo("ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_BF_XIX_Grundumfang_XIX_eCS", "- Interface used to read if and on demand selt-test has been requested for each solenoid - The on demand self-test for seat BF Reihe 2 will trigger the unlock/lock for solenoids 6");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization"); // If the first parameter of testStep() is "Step", the arguments will be written in the specification file and "Step" argument will be numbered by 1 for each iteration.
  RunPreTs();
//====================================================
  
  testCaseComment("Action: ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_BF_XIX_Grundumfang_XIX_eCS");
  testStep("STEP", "Set a breakpoint in function CIL_runCANToAppli in order to call interface used to read if and on demand selt-test has been requested for solenoid 6. --> BP reached");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "5");
   testStep("", "Run the debugger.");
   debugger_run();
   debugger_waitUntilBPisReached("12000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");
  debugger_deleteAllBreakpoints();  
  
   testStep("STEP", "Set a breakpoint in function Rte_COMCbk_SGis_AB_Gurtschloss_Reihe2_BF1_1312R in order where check Rte State --> BP reached");
   debugger_setRelativeFunctionBpAtLine("Rte_COMCbk_SGis_AB_Gurtschloss_Reihe2_BF1_1312R", "4");
  debugger_run();
  TestWaitForTimeout(1000);
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
   
  
  testStep("STEP", "Set a breakpoint in function Rte_COMCbk_SGis_AB_Gurtschloss_Reihe2_BF1_1312R in order to read Internal Buffer --> BP reached");
   debugger_setRelativeFunctionBpAtLine("Rte_COMCbk_SGis_AB_Gurtschloss_Reihe2_BF1_1312R", "9");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
//  
//   testStep("STEP", "Read the Internal Buffer value");
//   debugger_readLocalVariable("Rte_InternalBuffer");
//   ExpectedTestResult(debugger_result, "0x1", "Variable read");
//
//   testStep("STEP", "Set a breakpoint in function CIL_runCANToAppli in order to check ODST for Solenoid 6. --> BP reached");
//   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "5");
//   debugger_run();
//   debugger_waitUntilBPisReached("5000");
//   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");
//  
//   testStep("STEP", "Read the Buckle Status Tx value for solenoid 6");
//   debugger_readLocalVariable("(CIL_u8BuckleStatusTx)[5]");
//   ExpectedTestResult(debugger_result, "0x1", "Variable read");
 
//  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase Sw_Int_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_BF_XIX_Grundumfang_XIX_eCS_02()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based, Interface Test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_BF_XIX_Grundumfang_XIX_eCS");
  AddRequirementInfo("ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_BF_XIX_Grundumfang_XIX_eCS", "- Interface used to read if and on demand selt-test has been requested for each solenoid - The on demand self-test for seat BF Reihe 2 will trigger the unlock/lock for solenoids 6");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization"); // If the first parameter of testStep() is "Step", the arguments will be written in the specification file and "Step" argument will be numbered by 1 for each iteration.
  RunPreTs();
//====================================================

  testCaseComment("Action: ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_BF_XIX_Grundumfang_XIX_eCS");
   testStep("STEP", "Set a breakpoint in function CIL_runCANToAppli at the check if Aktuatortest_Reihe2_BF command was received --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "29");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");
    
   debugger_deleteAllBreakpoints();
   testStep("STEP", "Read the variable which stores AB_eCS_Aktuatortest_Reihe2_BF CAN command --> Variable read.");
   debugger_readLocalVariable("u8Aktuatortest_Reihe2_BF");

   testStep("STEP", "Read the signal AB_eCS_Aktuatortest_Reihe2_BF --> Signal Value read.");
   fSignalValue = getSignal(AB_eCS_Aktuatortest_Reihe2_BF);
   CompareToFloat(fSignalValue, 1.0);
   
   testStep("STEP", "Set signal Aktuatortest_Reihe2_BF value to Entriegelt. --> Signal value is set to 2");
   setSignal(AB_eCS_Aktuatortest_Reihe2_BF, 2);

   testStep("STEP", "Set a breakpoint in function CIL_runCANToAppli in order to check if UNLOCK actuator 6 --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "176");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
 
//  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase Sw_Int_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_FA_XIX_Grundumfang_XIX_eCS_01()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based, Interface Test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_FA_XIX_Grundumfang_XIX_eCS");
  AddRequirementInfo("ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_FA_XIX_Grundumfang_XIX_eCS", "Interface used to read if and on demand selt-test has been requested for each solenoid - The on demand self-test for seat FA Reihe 2 will trigger the unlock/lock for solenoids 5");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization"); // If the first parameter of testStep() is "Step", the arguments will be written in the specification file and "Step" argument will be numbered by 1 for each iteration.
  RunPreTs();
//====================================================
  
  /* Sequence
  1. Read signal value from debugger
  2. Read signal value from CAN
  3. Modify u8Aktuatortest_Reihe2_BF with 1.
  4. 
  */
  testCaseComment("Action: ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_BF_XIX_Grundumfang_XIX_eCS");
   testStep("STEP", "Set a breakpoint in function CIL_runCANToAppli at the check if Aktuatortest_Reihe2_FA command was received --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "26");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");
    
   debugger_deleteAllBreakpoints();
   testStep("STEP", "Read the variable which stores AB_eCS_Aktuatortest_Reihe2_FA CAN command --> Variable read.");
   debugger_readLocalVariable("u8Aktuatortest_Reihe2_FA");

   testStep("STEP", "Read the signal AB_eCS_Aktuatortest_Reihe2_FA --> Signal value read.");
   fSignalValue = getSignal(AB_eCS_Aktuatortest_Reihe2_FA);
   CompareToFloat(fSignalValue, 1.0);
   
   testStep("STEP", "Set signal AB_eCS_Aktuatortest_Reihe2_FA value to verriegelt. --> Signal value is set to 1.");
   setSignal(AB_eCS_Aktuatortest_Reihe2_FA, 1);

   //Source code and line number: CIL_CANToAppli.c 281 -  au8SolenoidDiagRequest[KU8_FIVE] = KU8_LOCK_DIAG_REQUEST;
   testStep("STEP", "Set a breakpoint in function CIL_runCANToAppli in order to check if LOCK actuator 5 --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "128");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
 
//  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase Sw_Int_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_FA_XIX_Grundumfang_XIX_eCS_02()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based, Interface Test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_FA_XIX_Grundumfang_XIX_eCS");
  AddRequirementInfo("ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_FA_XIX_Grundumfang_XIX_eCS", "Interface used to read if and on demand selt-test has been requested for each solenoid - The on demand self-test for seat FA Reihe 2 will trigger the unlock/lock for solenoids 5");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization"); // If the first parameter of testStep() is "Step", the arguments will be written in the specification file and "Step" argument will be numbered by 1 for each iteration.
  RunPreTs();
//====================================================
  
  testCaseComment("Action: ARCH_SW_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_BF_XIX_Grundumfang_XIX_eCS");
   testStep("STEP", "Set a breakpoint in function CIL_runCANToAppli at the check if Aktuatortest_Reihe2_FA command was received --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "26");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");
    
   debugger_deleteAllBreakpoints();
   testStep("STEP", "Read the variable which stores AB_eCS_Aktuatortest_Reihe2_FA CAN command --> Variable read.");
   debugger_readLocalVariable("u8Aktuatortest_Reihe2_FA");

   testStep("STEP", "Read the signal AB_eCS_Aktuatortest_Reihe2_FA --> Signal value read.");
   fSignalValue = getSignal(AB_eCS_Aktuatortest_Reihe2_FA);
   CompareToFloat(fSignalValue, 1.0);
   
   testStep("STEP", "Set signal AB_eCS_Aktuatortest_Reihe2_FA value to verriegelt. --> Signal value is set to 2");
   setSignal(AB_eCS_Aktuatortest_Reihe2_FA, 2);

   //Source code and line number: CIL_CANToAppli.c 281 -  au8SolenoidDiagRequest[KU8_FIVE] = KU8_LOCK_DIAG_REQUEST;
   testStep("STEP", "Set a breakpoint in function CIL_runCANToAppli in order to check if UNLOCK actuator 5 --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "139");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
 
//  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase Sw_Int_CIL_RP_IF_AB_Crash_Int_XIX_Grundumfang_XIX_eCS_01()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based, Interface Test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CIL_RP_IF_AB_Crash_Int_XIX_Grundumfang_XIX_eCS, ARCH_SW_CIL_psrCrashStatus");
  AddRequirementInfo("ARCH_SW_CIL_RP_IF_AB_Crash_Int_XIX_Grundumfang_XIX_eCS", "Interface used to receive the crash status from the CAN bus");
  AddRequirementInfo("ARCH_SW_CIL_psrCrashStatus", "Interface used to transmit the crash status to the rest of the Application - The solenoids will be locked if a crash situation has been detected(any value other than NO_CRASH)");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization"); // If the first parameter of testStep() is "Step", the arguments will be written in the specification file and "Step" argument will be numbered by 1 for each iteration.
  RunPreTs();
//====================================================
  
  testCaseComment("Action: ARCH_SW_CIL_RP_IF_AB_Crash_Int_XIX_Grundumfang_XIX_eCS, ARCH_SW_CIL_psrCrashStatus");
  testStep("STEP", "Set a breakpoint in CIL_runCANToAppli at the RTE Read of Crash Status sent via CAN message --> BP reached.");
  debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "199");
  debugger_run();
 debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP was set successfully");
 
  testStep("STEP", "Set signal AB_Crash_Int to value CRASH_INTENSITY_1 --> Signal set to 1.");
  debugger_run();
  setSignal(AB_Crash_Int, 1.0);
 
  testStep("STEP", "Set a breakpoint in CIL_runCANToAppli at the RTE Write of Crash Status --> BP reached.");
  debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "201");
  debugger_run();
  debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP was set successfully");
  
  testStep("STEP", "Set a breakpoint in CIL_runAppliToCAN in order to transmit the crash status to the rest of the Applications --> BP reached.");
  debugger_setRelativeFunctionBpAtLine("CIL_runAppliToCAN", "2");
  debugger_run();
  debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP was set successfully");
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase Sw_Int_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS_01()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based, Interface Test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS");
  AddRequirementInfo("ARCH_SW_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS", "The runnable shall write the status of the eCS ECU on the CAN bus - The runnable shall read the current output of the virtual ball algorithm - The runnable shall read the critical auto-test status via the mode management interface - The runnable shall read the permanent and sporadic error status via the mode management interface - If the critical auto-tests have not been run then the INIT value shall be transmitted on the CAN Bus - If the permanent HW error mode is set then the ERROR value shall be transmitted on the CAN Bus - If the sporadic error mode is set then the ERROR value shall be transmitted on the CAN Bus - If the ball algorithm outputs the LOCK state then this value shall be transmitted on the CAN bus - If the ball algorithm outputs the UNLOCK state then this value shall be transmitted on the CAN bus");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
//====================================================
  
  //The runnable shall write the status of the eCS ECU on the CAN bus
   testCaseComment("Action: ARCH_SW_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS");
   testStep("STEP", "Set a breakpoint in function CIL_runAppliToCAN at the execution for the current time slot --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runAppliToCAN", "5");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP was set successfully");
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot03 at the 3rd timeslot --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot03", "0");
  
   testStep("STEP", "Run the debugger 3 times, in order to reach the 3rd timeslot.");
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   debugger_deleteAllBreakpoints();
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot03 at RTE Write for eCS_Status signal --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot03", "58");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP was set successfully");   
  
   testStep("STEP", "Modify ECS status variable with CM_eCS_Status_Cx2_entriegelt --> Variable modified with 2.");
   debugger_writeLocalVariable("u8MergedECSStatus", "2");
   ExpectedTestResult(debugger_result, "2", "u8MergedECSStatus is equal to 0x2");
  
   testStep("STEP", "Check that eCS_Status was set to CM_eCS_Status_Cx2_entriegelt --> Signal set to 2.");
   debugger_run();
   fSignalValue = getSignal(eCS_Status);
   CompareToFloat(fSignalValue, 1.0);
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase Sw_Int_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS_02()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based, Interface Test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS");
  AddRequirementInfo("ARCH_SW_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS", "The runnable shall write the status of the eCS ECU on the CAN bus - The runnable shall read the current output of the virtual ball algorithm - The runnable shall read the critical auto-test status via the mode management interface - The runnable shall read the permanent and sporadic error status via the mode management interface - If the critical auto-tests have not been run then the INIT value shall be transmitted on the CAN Bus - If the permanent HW error mode is set then the ERROR value shall be transmitted on the CAN Bus - If the sporadic error mode is set then the ERROR value shall be transmitted on the CAN Bus - If the ball algorithm outputs the LOCK state then this value shall be transmitted on the CAN bus - If the ball algorithm outputs the UNLOCK state then this value shall be transmitted on the CAN bus");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
//====================================================
  
  //The runnable shall read the current output of the virtual ball algorithm
   testCaseComment("Action: ARCH_SW_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS");
  testStep("STEP", "Start DevKit_01 Frame --> Frame started.");
  testStep("STEP", "Send request for Supplier session");
   @Platform::DIAG_Session_Control = 126; // Supplier session selected.
   TestWaitForTimeout(100);
   @Platform::DIAG_Session_Control_Update = 1; // Update Session.
   TestWaitForTimeout(100);
  testStep("STEP", "Send request for  Supplier Security Access");
   @Platform::DIAG_Security_Control = 97; // Security Access = Supplier
  TestWaitForTimeout(100);
   @Platform::DIAG_Security_Control_Update = 1; // Update Security Access
  TestWaitForTimeout(100);
   testStep("STEP", "Send request for press ECUUnlock button");
   @Platform::DIAG_ECUUnlock = 1;
   TestWaitForTimeout(500);
  testStep("STEP", "Send request for Activate measurement frame");
   @Platform::DIAG_MeasurementFrameID1 = 1; // Activate measurement frame.
  TestWaitForTimeout(100);
   @Platform::DIAG_EnableDevFrame = 1;
  TestWaitForTimeout(100);
   @Platform::DIAG_MeasurementFrameConfWrite = 1; // Write meas frame.
  
   testStep("STEP", "Set a breakpoint in function CIL_runAppliToCAN at the execution for the current time slot --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runAppliToCAN", "5");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP was set successfully");
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot02 at the 2nd timeslot --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot02", "0");
  
   testStep("STEP", "Run the debugger 2 times, in order to reach the 2nd timeslot.");
   debugger_run();
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   debugger_deleteAllBreakpoints();
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot02 after RTE Read for ball position in mm --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot02", "23");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP was set successfully");   
  
   testStep("STEP", "Read Ball_Position in mm from debugger --> Variable read.");
   debugger_readLocalVariable("u16BallPosition");
   ExpectedTestResult(debugger_result, "u16BallPosition", "Variable read");
  
   testStep("STEP", "Read value of signal Ball_Position --> Signal value read.");
   debugger_run();
   fSignalValue = getSignal(Ball_Position);

  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase Sw_Int_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS_03()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based, Interface Test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS");
  AddRequirementInfo("ARCH_SW_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS", "The runnable shall write the status of the eCS ECU on the CAN bus - The runnable shall read the current output of the virtual ball algorithm - The runnable shall read the critical auto-test status via the mode management interface - The runnable shall read the permanent and sporadic error status via the mode management interface - If the critical auto-tests have not been run then the INIT value shall be transmitted on the CAN Bus - If the permanent HW error mode is set then the ERROR value shall be transmitted on the CAN Bus - If the sporadic error mode is set then the ERROR value shall be transmitted on the CAN Bus - If the ball algorithm outputs the LOCK state then this value shall be transmitted on the CAN bus - If the ball algorithm outputs the UNLOCK state then this value shall be transmitted on the CAN bus");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization");
  RunPreTs();
//====================================================
  
  //The runnable shall read the critical auto-test status via the mode management interface
   testCaseComment("Action: ARCH_SW_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS");
    testStep("STEP", "Start DevKit_01 Frame --> Frame started.");
  testStep("STEP", "Send request for Supplier session");
   @Platform::DIAG_Session_Control = 126; // Supplier session selected.
   TestWaitForTimeout(100);
   @Platform::DIAG_Session_Control_Update = 1; // Update Session.
   TestWaitForTimeout(100);
  testStep("STEP", "Send request for  Supplier Security Access");
   @Platform::DIAG_Security_Control = 97; // Security Access = Supplier
  TestWaitForTimeout(100);
   @Platform::DIAG_Security_Control_Update = 1; // Update Security Access
  TestWaitForTimeout(100);
   testStep("STEP", "Send request for press ECUUnlock button");
   @Platform::DIAG_ECUUnlock = 1;
   TestWaitForTimeout(500);
  testStep("STEP", "Send request for Activate measurement frame");
   @Platform::DIAG_MeasurementFrameID1 = 1; // Activate measurement frame.
  TestWaitForTimeout(100);
   @Platform::DIAG_EnableDevFrame = 1;
  TestWaitForTimeout(100);
   @Platform::DIAG_MeasurementFrameConfWrite = 1; // Write meas frame.
   testStep("STEP", "Set a breakpoint in function CIL_runAppliToCAN at the execution for the current time slot --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runAppliToCAN", "5");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP was set successfully");
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot03 at the 3rd timeslot --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot03", "0");
  
   testStep("STEP", "Run the debugger 3 times, in order to reach the 3rd timeslot.");
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   debugger_deleteAllBreakpoints();
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot03 at RTE Call for CheckModeStatus --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot03", "12");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP Reached.");   
  
   testStep("STEP", "Set a breakpoint in function FSM_runCheckModeStatus in RTE Call to can check CheckModeStatus value --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("FSM_runCheckModeStatus", "0");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP Reached."); 
   
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot03 to Check that eCS_Status --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot03", "14");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP Reached.");   
  
   testStep("STEP", "Read Init mode status. --> Init mode status succesfully read");
   debugger_readLocalVariable("bInitModeStatus");
   ExpectedTestResult(debugger_result, "0x55", "Local variable bInitModeStatus is equal to 0x55");
  
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase Sw_Int_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS_04()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS");
  AddRequirementInfo("ARCH_SW_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS", "The runnable shall write the status of the eCS ECU on the CAN bus - The runnable shall read the current output of the virtual ball algorithm - The runnable shall read the critical auto-test status via the mode management interface - The runnable shall read the permanent and sporadic error status via the mode management interface - If the critical auto-tests have not been run then the INIT value shall be transmitted on the CAN Bus - If the permanent HW error mode is set then the ERROR value shall be transmitted on the CAN Bus - If the sporadic error mode is set then the ERROR value shall be transmitted on the CAN Bus - If the ball algorithm outputs the LOCK state then this value shall be transmitted on the CAN bus - If the ball algorithm outputs the UNLOCK state then this value shall be transmitted on the CAN bus");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization"); // If the first parameter of testStep() is "Step", the arguments will be written in the specification file and "Step" argument will be numbered by 1 for each iteration.
  RunPreTs();
//====================================================
  
  //The runnable shall read the permanent and sporadic error status via the mode management interface
  testCaseComment("Action: ARCH_SW_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS");
   testStep("STEP", "Set a breakpoint in function CIL_runAppliToCAN at the execution for the current time slot --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runAppliToCAN", "5");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP was set successfully");
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot04 at the 4th timeslot --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot04", "0");
  
   testStep("STEP", "Run the debugger 4 times, in order to reach the 4th timeslot.");
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   debugger_deleteAllBreakpoints();
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot04 after RTE Call for CheckModeStatus --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot04", "78");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
 
   testStep("STEP", "Set Sporatic error variable to B_TRUE");
   debugger_writeLocalVariable("u8SporadicErrorTx","0xAA");
   TestWaitForTimeout(800);
   ExpectedTestResult(debugger_result, "0xAA", "Successfully overwritten local variableu8SporadicErrorTx with value 0xAA");
   debugger_deleteAllBreakpoints();
  
  debugger_run();
  TestWaitForTimeout(5000);
  testStep("STEP", "Check that signal Stoerung is set to 0x1  --> Signal is set to 1.");
  fSignalValue = getSignal(eCS::eCS_Stoerung);
  CompareToFloat(1, fSignalValue);
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}

testcase Sw_Int_CIL_SP_IF_eCS_Gurtschloss_Status_Reihe2_BF_XIX_Grundumfang_XIX_eCS_01()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based, Interface Test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CIL_SP_IF_eCS_Gurtschloss_Status_Reihe2_BF_XIX_Grundumfang_XIX_eCS");
  AddRequirementInfo("ARCH_SW_CIL_SP_IF_eCS_Gurtschloss_Status_Reihe2_BF_XIX_Grundumfang_XIX_eCS", "The runnable shall read the buckle sensor status from the IoHwAb module - The runnable shall write the buckle sensor status for the second row on the CAN bus.");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization"); // If the first parameter of testStep() is "Step", the arguments will be written in the specification file and "Step" argument will be numbered by 1 for each iteration.
  RunPreTs();
//====================================================
  
  testCaseComment("Action: ARCH_SW_CIL_SP_IF_eCS_Gurtschloss_Status_Reihe2_BF_XIX_Grundumfang_XIX_eCS");
   testStep("STEP", "Set a breakpoint in function IoHwAb_DetectSeatOccupancy at the switch statement --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "51");
  debugger_run();
  debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
 
   testStep("STEP", "Set a breakpoint in function IoHwAb_DetectSeatOccupancy at the case KU8_IOHWAB_BELT_PLUG --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "62");
  debugger_run();
  debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
 
   testStep("STEP", "Set a breakpoint in function IoHwAb_DetectSeatOccupancy at the RTE Write for SeatOccupancySensorStatus --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "77");
  debugger_run();
  debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
 
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot01 at the switch statement --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "26");
  debugger_run();
  debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
 
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot01 at the case KU8_BUCKLE_LATCHED --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "31");
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   debugger_readLocalVariable("u8BuckleStatusRx"); //1

   testStep("STEP", "Read the signal eCS_Gurtschloss_Status_Reihe2_BF.");
   fSignalValue = getSignal(eCS_Gurtschloss_Status_Reihe2_BF); // 1
   CompareToFloat(fSignalValue, 1.0);
 
//  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}

testcase Sw_Int_CIL_SP_IF_eCS_Gurtschloss_Status_Reihe2_FA_XIX_Grundumfang_XIX_eCS_01()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based, Interface Test");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CIL_SP_IF_eCS_Gurtschloss_Status_Reihe2_FA_XIX_Grundumfang_XIX_eCS");
  AddRequirementInfo("ARCH_SW_CIL_SP_IF_eCS_Gurtschloss_Status_Reihe2_FA_XIX_Grundumfang_XIX_eCS", "The runnable shall read the buckle sensor status from the IoHwAb module - The runnable shall write the buckle sensor status for the second row on the CAN bus.");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization"); // If the first parameter of testStep() is "Step", the arguments will be written in the specification file and "Step" argument will be numbered by 1 for each iteration.
  RunPreTs();
//====================================================
  
  testCaseComment("Action: ARCH_SW_CIL_SP_IF_eCS_Gurtschloss_Status_Reihe2_FA_XIX_Grundumfang_XIX_eCS");
   testStep("STEP", "Set a breakpoint in function IoHwAb_DetectSeatOccupancy at the switch statement --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "51");
  debugger_run();
  debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");
  
   testStep("STEP", "Set a breakpoint in function IoHwAb_DetectSeatOccupancy at the case KU8_IOHWAB_BELT_PLUG --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "62");
  debugger_run();
  debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");
  
   testStep("STEP", "Set a breakpoint in function IoHwAb_DetectSeatOccupancy at the RTE Write for SeatOccupancySensorStatus --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "77");
  debugger_run();
  debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot01 at the switch statement --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "26");
  debugger_run();
  debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot01 at the case KU8_BUCKLE_LATCHED --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runCANToAppli", "31");

   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   debugger_readLocalVariable("u8BuckleStatusRx"); //1

   testStep("STEP", "Read the signal eCS_Gurtschloss_Status_Reihe2_FA.");
   fSignalValue = getSignal(eCS_Gurtschloss_Status_Reihe2_FA); // 1
   CompareToFloat(fSignalValue, 1.0);
 
//  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
}
testcase Sw_Int_CIL_P_CAN_CanDataOut_Frame_0_01()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CIL_P_CAN_CanDataOut_Frame_0");
  AddRequirementInfo("ARCH_SW_CIL_P_CAN_CanDataOut_Frame_0", "The runnable shall write all the content of the CAN signals belonging to the eCS Dev Frame - The runnable shall read from the Application the followig data and send them on the CAN bus: - NVP_u32eCSVariant - Acceleration on X,Y,Z axis in g - eCS Algorithm Decision - Ball Position in mm - Selected Profile[for each solenoid] - Acceleration on X,Y,Z axis in m/s^2 - Selected step [for each solenoid] - Solenoid state [for each solenoid] - Solenoid confirmation status [for each solenoid] - Buckle Status [for each solenoid] - Lock Execution Counter [for each solenoid] - Unlock Execution Counter [for each solenoid] - Unlock Confirmed Execution Counter [for each solenoid] - Warm reset counter");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization"); // If the first parameter of testStep() is "Step", the arguments will be written in the specification file and "Step" argument will be numbered by 1 for each iteration.
  RunPreTs();
//====================================================
  
  //Acceleration on X,Y,Z axis in g 
  testCaseComment("Action: ARCH_SW_CIL_P_CAN_CanDataOut_Frame_0");
  testStep("STEP", "Start DevKit_01 Frame --> Frame started.");
  testStep("STEP", "Send request for Supplier session");
   @Platform::DIAG_Session_Control = 126; // Supplier session selected.
   TestWaitForTimeout(100);
   @Platform::DIAG_Session_Control_Update = 1; // Update Session.
   TestWaitForTimeout(100);
  testStep("STEP", "Send request for  Supplier Security Access");
   @Platform::DIAG_Security_Control = 97; // Security Access = Supplier
  TestWaitForTimeout(100);
   @Platform::DIAG_Security_Control_Update = 1; // Update Security Access
  TestWaitForTimeout(100);
   testStep("STEP", "Send request for press ECUUnlock button");
   @Platform::DIAG_ECUUnlock = 1;
   TestWaitForTimeout(500);
  testStep("STEP", "Send request for Activate measurement frame");
   @Platform::DIAG_MeasurementFrameID1 = 1; // Activate measurement frame.
  TestWaitForTimeout(100);
   @Platform::DIAG_EnableDevFrame = 1;
  TestWaitForTimeout(100);
   @Platform::DIAG_MeasurementFrameConfWrite = 1; // Write meas frame.
  
   testStep("STEP", "Set a breakpoint in function CIL_runAppliToCAN at the execution for the current time slot --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runAppliToCAN", "5");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP was set successfully");
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot02 at the 2th timeslot --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot02", "0");
  
   testStep("STEP", "Run the debugger 2 times, in order to reach the 2th timeslot.");
   debugger_run();
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   debugger_deleteAllBreakpoints();
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot02 after RTE Call Get Acceleration in g --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot02", "18");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
 
   testStep("STEP", "Read s16Ax Axis Accel value. --> s16Ax Axis Accel value succesfully read");
   debugger_readLocalVariableForBoundary("(stRaw3AxisAccel).s16Ax");
   write ("salutsalutsalut %s", debugger_result);
   debugger_readLocalVariableForBoundary("s16Ax");
   BoundaryTestResult(debugger_result, -0x51E, 0x51E, "Verify that actual result is within boundaries: 0x0 - 0x2");
  
   testStep("STEP", "Read s16Ay Axis Accel value. --> s16Ay Axis Accel value succesfully read");
   debugger_readLocalVariableForBoundary("(stRaw3AxisAccel).s16Ay");
  BoundaryTestResult(debugger_result, 0x51E, 0x51E, "Verify that actual result is within boundaries: 0x0 - 0x270F");
  
   testStep("STEP", "Read s16Az Accel value. --> s16Az Axis Accel value succesfully read");
   debugger_readLocalVariableForBoundary("(stRaw3AxisAccel).s16Az");
   BoundaryTestResult(debugger_result, 0x51E, 0x51E, "Verify that actual result is within boundaries: 0x0 - 0x270F");
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}
testcase Sw_Int_CIL_P_CAN_CanDataOut_Frame_0_02()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CIL_P_CAN_CanDataOut_Frame_0");
  AddRequirementInfo("ARCH_SW_CIL_P_CAN_CanDataOut_Frame_0", "The runnable shall write all the content of the CAN signals belonging to the eCS Dev Frame - The runnable shall read from the Application the followig data and send them on the CAN bus: - NVP_u32eCSVariant - Acceleration on X,Y,Z axis in g - eCS Algorithm Decision - Ball Position in mm - Selected Profile[for each solenoid] - Acceleration on X,Y,Z axis in m/s^2 - Selected step [for each solenoid] - Solenoid state [for each solenoid] - Solenoid confirmation status [for each solenoid] - Buckle Status [for each solenoid] - Lock Execution Counter [for each solenoid] - Unlock Execution Counter [for each solenoid] - Unlock Confirmed Execution Counter [for each solenoid] - Warm reset counter");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization"); // If the first parameter of testStep() is "Step", the arguments will be written in the specification file and "Step" argument will be numbered by 1 for each iteration.
  RunPreTs();
//====================================================
  
  //Selected Profile
  testCaseComment("Action: ARCH_SW_CIL_P_CAN_CanDataOut_Frame_0");
  testStep("STEP", "Start DevKit_01 Frame --> Frame started.");
  testStep("STEP", "Send request for Supplier session");
   @Platform::DIAG_Session_Control = 126; // Supplier session selected.
   TestWaitForTimeout(100);
   @Platform::DIAG_Session_Control_Update = 1; // Update Session.
   TestWaitForTimeout(100);
  testStep("STEP", "Send request for  Supplier Security Access");
   @Platform::DIAG_Security_Control = 97; // Security Access = Supplier
  TestWaitForTimeout(100);
   @Platform::DIAG_Security_Control_Update = 1; // Update Security Access
  TestWaitForTimeout(100);
   testStep("STEP", "Send request for press ECUUnlock button");
   @Platform::DIAG_ECUUnlock = 1;
   TestWaitForTimeout(500);
  testStep("STEP", "Send request for Activate measurement frame");
   @Platform::DIAG_MeasurementFrameID1 = 1; // Activate measurement frame.
  TestWaitForTimeout(100);
   @Platform::DIAG_EnableDevFrame = 1;
  TestWaitForTimeout(100);
   @Platform::DIAG_MeasurementFrameConfWrite = 1; // Write meas frame.
  
   testStep("STEP", "Set a breakpoint in function CIL_runAppliToCAN at the execution for the current time slot --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runAppliToCAN", "5");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP was set successfully");
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot01 at the 1th timeslot --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot01", "0");
  
   testStep("STEP", "Run the debugger 1 times, in order to reach the 1st timeslot.");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   debugger_deleteAllBreakpoints();
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot01 after RTE Call Selected Profile --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot01", "14");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
 
  testStep("STEP", "Read Selected Profile value. -->Selected Profile value succesfully read");
   debugger_readLocalVariable("(au8SelectedProfile)[0]");
   ExpectedTestResult(debugger_result, "0xff", "	Local variable (au8SelectedProfile)[0] is equal to 0xff");

  debugger_deleteAllBreakpoints();
  debugger_run();
  TestWaitForTimeout(5000);
  testStep("STEP", "Check that signal eCS_SelectedProfile_S1 value set  --> Signal is set");
  fSignalValue = getSignal(DevKit_01::eCS_SelectedProfile_S1);
  CompareToFloat(fSignalValue, 0xFFFFFFFF);
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}
testcase Sw_Int_CIL_P_CAN_CanDataOut_Frame_0_03()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CIL_P_CAN_CanDataOut_Frame_0");
  AddRequirementInfo("ARCH_SW_CIL_P_CAN_CanDataOut_Frame_0", "The runnable shall write all the content of the CAN signals belonging to the eCS Dev Frame - The runnable shall read from the Application the followig data and send them on the CAN bus: - NVP_u32eCSVariant - Acceleration on X,Y,Z axis in g - eCS Algorithm Decision - Ball Position in mm - Selected Profile[for each solenoid] - Acceleration on X,Y,Z axis in m/s^2 - Selected step [for each solenoid] - Solenoid state [for each solenoid] - Solenoid confirmation status [for each solenoid] - Buckle Status [for each solenoid] - Lock Execution Counter [for each solenoid] - Unlock Execution Counter [for each solenoid] - Unlock Confirmed Execution Counter [for each solenoid] - Warm reset counter");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization"); // If the first parameter of testStep() is "Step", the arguments will be written in the specification file and "Step" argument will be numbered by 1 for each iteration.
  RunPreTs();
//====================================================
  
  //Acceleration on X,Y,Z axis in m/s^2 
  testCaseComment("Action: ARCH_SW_CIL_P_CAN_CanDataOut_Frame_0");
  testStep("STEP", "Start DevKit_01 Frame --> Frame started.");
  testStep("STEP", "Send request for Supplier session");
   @Platform::DIAG_Session_Control = 126; // Supplier session selected.
   TestWaitForTimeout(100);
   @Platform::DIAG_Session_Control_Update = 1; // Update Session.
   TestWaitForTimeout(100);
  testStep("STEP", "Send request for  Supplier Security Access");
   @Platform::DIAG_Security_Control = 97; // Security Access = Supplier
  TestWaitForTimeout(100);
   @Platform::DIAG_Security_Control_Update = 1; // Update Security Access
  TestWaitForTimeout(100);
   testStep("STEP", "Send request for press ECUUnlock button");
   @Platform::DIAG_ECUUnlock = 1;
   TestWaitForTimeout(500);
  testStep("STEP", "Send request for Activate measurement frame");
   @Platform::DIAG_MeasurementFrameID1 = 1; // Activate measurement frame.
  TestWaitForTimeout(100);
   @Platform::DIAG_EnableDevFrame = 1;
  TestWaitForTimeout(100);
   @Platform::DIAG_MeasurementFrameConfWrite = 1; // Write meas frame.
  
   testStep("STEP", "Set a breakpoint in function CIL_runAppliToCAN at the execution for the current time slot --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runAppliToCAN", "5");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP was set successfully");
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot02 at the 2th timeslot --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot02", "0");
  
   testStep("STEP", "Run the debugger 2 times, in order to reach the 2th timeslot.");
   debugger_run();
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   debugger_deleteAllBreakpoints();
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot02 after RTE Call Get Acceleration in m/s^2 --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot02", "16");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
 
  testStep("STEP", "Read st 3 Axis Accel for x in m/s^2 value. --> st 3 Axis Accel value succesfully read");
   debugger_readLocalVariable("(st3AxisAccel).s16Ax");
   ExpectedTestResult(debugger_result, "", "Local variable (st3AxisAccel).s16Ax");

  testStep("STEP", "Read st 3 Axis Accel for y in m/s^2 value. --> st 3 Axis Accel value succesfully read");
   debugger_readLocalVariable("(st3AxisAccel).s16Ay");
   ExpectedTestResult(debugger_result, "", "Local variable (st3AxisAccel).s16Ay");
  
  testStep("STEP", "Read st 3 Axis Accel for z in m/s^2 value. --> st 3 Axis Accel value succesfully read");
   debugger_readLocalVariable("(st3AxisAccel).s16Az");
   ExpectedTestResult(debugger_result, "", "Local variable (st3AxisAccel).s16Az");
  
  debugger_deleteAllBreakpoints();
  debugger_run();
  TestWaitForTimeout(5000);
  testStep("STEP", "Check that signal Accel_Ax was set  --> Signal is set");
  fSignalValue = getSignal(DevKit_01::eCS_Accel_Ax);
  CompareToFloat(fSignalValue, 0x3);
  
  testStep("STEP", "Check that signal Accel_Ay was set  --> Signal is set");
  fSignalValue = getSignal(DevKit_01::eCS_Accel_Ay);
  CompareToFloat(fSignalValue, 0x3);
  
  CompareToFloat(fSignalValue, 0x3);
  testStep("STEP", "Check that signal Accel_Az was set  --> Signal is set");
  fSignalValue = getSignal(DevKit_01::eCS_Accel_Az);
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}
testcase Sw_Int_CIL_P_CAN_CanDataOut_Frame_0_04()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CIL_P_CAN_CanDataOut_Frame_0");
  AddRequirementInfo("ARCH_SW_CIL_P_CAN_CanDataOut_Frame_0", "The runnable shall write all the content of the CAN signals belonging to the eCS Dev Frame - The runnable shall read from the Application the followig data and send them on the CAN bus: - NVP_u32eCSVariant - Acceleration on X,Y,Z axis in g - eCS Algorithm Decision - Ball Position in mm - Selected Profile[for each solenoid] - Acceleration on X,Y,Z axis in m/s^2 - Selected step [for each solenoid] - Solenoid state [for each solenoid] - Solenoid confirmation status [for each solenoid] - Buckle Status [for each solenoid] - Lock Execution Counter [for each solenoid] - Unlock Execution Counter [for each solenoid] - Unlock Confirmed Execution Counter [for each solenoid] - Warm reset counter");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization"); // If the first parameter of testStep() is "Step", the arguments will be written in the specification file and "Step" argument will be numbered by 1 for each iteration.
  RunPreTs();
//====================================================
  
  //Solenoid state
  
  testCaseComment("Action: ARCH_SW_CIL_P_CAN_CanDataOut_Frame_0");
    testStep("STEP", "Start DevKit_01 Frame --> Frame started.");
  testStep("STEP", "Send request for Supplier session");
   @Platform::DIAG_Session_Control = 126; // Supplier session selected.
   TestWaitForTimeout(100);
   @Platform::DIAG_Session_Control_Update = 1; // Update Session.
   TestWaitForTimeout(100);
  testStep("STEP", "Send request for  Supplier Security Access");
   @Platform::DIAG_Security_Control = 97; // Security Access = Supplier
  TestWaitForTimeout(100);
   @Platform::DIAG_Security_Control_Update = 1; // Update Security Access
  TestWaitForTimeout(100);
   testStep("STEP", "Send request for press ECUUnlock button");
   @Platform::DIAG_ECUUnlock = 1;
   TestWaitForTimeout(500);
  testStep("STEP", "Send request for Activate measurement frame");
   @Platform::DIAG_MeasurementFrameID1 = 1; // Activate measurement frame.
  TestWaitForTimeout(100);
   @Platform::DIAG_EnableDevFrame = 1;
  TestWaitForTimeout(100);
   @Platform::DIAG_MeasurementFrameConfWrite = 1; // Write meas frame.
  
  testStep("STEP", "Set a breakpoint in function CIL_runAppliToCAN at the execution for the current time slot --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runAppliToCAN", "5");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP was set successfully");
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot01 at the 1th timeslot --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot01", "0");
  
   testStep("STEP", "Run the debugger 1 times, in order to reach the 1st timeslot.");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   debugger_deleteAllBreakpoints();
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot01 after RTE Call Solenoid state --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot01", "85");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP reached.");   
 
  testStep("STEP", "Read Solenoid 1 state value. --> Solenoid state value succesfully read");
   debugger_readLocalVariable("(au8SolenoidStates)[0]");
   ExpectedTestResult(debugger_result, "0x3", "Local variable (au8SolenoidStates)[0] is equal to 0x3");

  testStep("STEP", "Read Solenoid 2 state value. --> Solenoid state value succesfully read");
   debugger_readLocalVariable("(au8SolenoidStates)[1]");
   ExpectedTestResult(debugger_result, "0x3", "Local variable (au8SolenoidStates)[1] is equal to 0x3");
  
  testStep("STEP", "Read Solenoid 3 state value. --> Solenoid state value succesfully read");
   debugger_readLocalVariable("(au8SolenoidStates)[2]");
   ExpectedTestResult(debugger_result, "0x3", "Local variable (au8SolenoidStates)[2] is equal to 0x3");
  
  testStep("STEP", "Read Solenoid 4 state value. --> Solenoid state value succesfully read");
   debugger_readLocalVariable("(au8SolenoidStates)[3]");
   ExpectedTestResult(debugger_result, "0x3", "Local variable (au8SolenoidStates)[3] is equal to 0x3");
  
  testStep("STEP", "Read Solenoid 5 state value. --> Solenoid state value succesfully read");
   debugger_readLocalVariable("(au8SolenoidStates)[4]");
   ExpectedTestResult(debugger_result, "0x2", "Local variable (au8SolenoidStates)[4] is equal to 0x2");
  
  testStep("STEP", "Read Solenoid 6 state value. --> Solenoid state value succesfully read");
   debugger_readLocalVariable("(au8SolenoidStates)[5]");
   ExpectedTestResult(debugger_result, "0x2", "Local variable (au8SolenoidStates)[5] is equal to 0x2");
  
  debugger_deleteAllBreakpoints();
  debugger_run();
  TestWaitForTimeout(5000);
  testStep("STEP", "Check that signal eCS_Solenoid_1_State value set  --> Signal is set");
  fSignalValue = getSignal(DevKit_01::eCS_Solenoid_1_State);
  CompareToFloat(fSignalValue, 0x3);
  
  testStep("STEP", "Check that signal eCS_Solenoid_2_State value set  --> Signal is set");
  fSignalValue = getSignal(DevKit_01::eCS_Solenoid_2_State);
  CompareToFloat(fSignalValue, 0x3);
  
  testStep("STEP", "Check that signal eCS_Solenoid_3_State value set  --> Signal is set");
  fSignalValue = getSignal(DevKit_01::eCS_Solenoid_3_State);
  CompareToFloat(fSignalValue, 0x3);
  
  testStep("STEP", "Check that signal eCS_Solenoid_4_State value set  --> Signal is set");
  fSignalValue = getSignal(DevKit_01::eCS_Solenoid_4_State);
  CompareToFloat(fSignalValue, 0x3);
  
  testStep("STEP", "Check that signal eCS_Solenoid_5_State value set  --> Signal is set");
  fSignalValue = getSignal(DevKit_01::eCS_Solenoid_5_State);
  CompareToFloat(fSignalValue, 0x0);
  
  testStep("STEP", "Check that signal eCS_Solenoid_6_State value set  --> Signal is set");
  fSignalValue = getSignal(DevKit_01::eCS_Solenoid_6_State);
  CompareToFloat(fSignalValue, 0x0);
  
    //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}
testcase Sw_Int_CIL_P_CAN_CanDataOut_Frame_0_05()
{
//***********************************Test report header*********************************
  testReportAddMiscInfoBlock("AUTOLIV ELECTRONICS document");
  TestReportAddMiscInfo("Nightly test", "No");
  TestReportAddMiscInfo("Test type", "Requirement-Based");
  TestReportAddMiscInfo("Regression Test", "No");
  TestReportAddMiscInfo("Fault injection method used", "No");
  TestReportAddMiscInfo("Resource usage evaluation", "No");
  TestReportAddMiscInfo("Priority", "No");
  TestReportAddMiscInfo("Safety relevant", "No");
  
  AddRequirementInfo("Requirement under test", "ARCH_SW_CIL_P_CAN_CanDataOut_Frame_0, ARCH_SW_CIL_P_CAN_MF_Frame");
  AddRequirementInfo("ARCH_SW_CIL_P_CAN_CanDataOut_Frame_0", "The runnable shall write all the content of the CAN signals belonging to the eCS Dev Frame - The runnable shall read from the Application the followig data and send them on the CAN bus: - NVP_u32eCSVariant - Acceleration on X,Y,Z axis in g - eCS Algorithm Decision - Ball Position in mm - Selected Profile[for each solenoid] - Acceleration on X,Y,Z axis in m/s^2 - Selected step [for each solenoid] - Solenoid state [for each solenoid] - Solenoid confirmation status [for each solenoid] - Buckle Status [for each solenoid] - Lock Execution Counter [for each solenoid] - Unlock Execution Counter [for each solenoid] - Unlock Confirmed Execution Counter [for each solenoid] - Warm reset counter");
  AddRequirementInfo("ARCH_SW_CIL_P_CAN_MF_Frame", "- The runnable shall write all the content of the CAN signals belonging to the eCS Dev Frame - The runnable shall read from the Application the followig data and send them on the CAN bus: - NVP_u32eCSVariant - Acceleration on X,Y,Z axis in g - eCS Algorithm Decision - Ball Position in mm - Selected Profile[for each solenoid] - Acceleration on X,Y,Z axis in m/s^2 - Selected step [for each solenoid] - Solenoid state [for each solenoid] - Solenoid confirmation status [for each solenoid] - Buckle Status [for each solenoid] - Lock Execution Counter [for each solenoid] - Unlock Execution Counter [for each solenoid] - Unlock Confirmed Execution Counter [for each solenoid] - Warm reset counter");
  //***************************************************************************************
  
  testCaseComment("Preconditions");
  testStep("STEP", "Bench Initialization"); // If the first parameter of testStep() is "Step", the arguments will be written in the specification file and "Step" argument will be numbered by 1 for each iteration.
  RunPreTs();
//====================================================
  
  //Solenoid state
  testCaseComment("Action: ARCH_SW_CIL_P_CAN_CanDataOut_Frame_0, ARCH_SW_CIL_P_CAN_MF_Frame");
    testStep("STEP", "Start DevKit_01 Frame --> Frame started.");
  testStep("STEP", "Send request for Supplier session");
   @Platform::DIAG_Session_Control = 126; // Supplier session selected.
   TestWaitForTimeout(100);
   @Platform::DIAG_Session_Control_Update = 1; // Update Session.
   TestWaitForTimeout(100);
  testStep("STEP", "Send request for  Supplier Security Access");
   @Platform::DIAG_Security_Control = 97; // Security Access = Supplier
  TestWaitForTimeout(100);
   @Platform::DIAG_Security_Control_Update = 1; // Update Security Access
  TestWaitForTimeout(100);
   testStep("STEP", "Send request for press ECUUnlock button");
   @Platform::DIAG_ECUUnlock = 1;
   TestWaitForTimeout(500);
  testStep("STEP", "Send request for Activate measurement frame");
   @Platform::DIAG_MeasurementFrameID1 = 1; // Activate measurement frame.
  TestWaitForTimeout(100);
   @Platform::DIAG_EnableDevFrame = 1;
  TestWaitForTimeout(100);
   @Platform::DIAG_MeasurementFrameConfWrite = 1; // Write meas frame.
  
   testStep("STEP", "Set a breakpoint in function CIL_runAppliToCAN at the execution for the current time slot --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("CIL_runAppliToCAN", "5");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP was set successfully");
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot02 at the 2nd timeslot --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot02", "0");
  
   testStep("STEP", "Run the debugger 2 times, in order to reach the 2nd timeslot.");
   debugger_run();
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP was set successfully");
   debugger_deleteAllBreakpoints();
  
   testStep("STEP", "Set a breakpoint in function cil_ManagePeriodicData_TimeSlot02 after RTE Read for ball position in mm --> BP reached.");
   debugger_setRelativeFunctionBpAtLine("cil_ManagePeriodicData_TimeSlot02", "23");
   debugger_run();
   debugger_waitUntilBPisReached("5000");
   ExpectedTestResult(debugger_result, W8_UNTIL_BP_SUCCESSFUL, "BP was set successfully");   
  
   testStep("STEP", "Read Ball_Position in mm from debugger --> Variable read.");
   variable_value= debugger_readLocalVariableForBoundary("u16BallPosition");
   EvalManStepRange("Verify that actual result is within boundaries: 0x0 - 0x270F", variable_value, 0x0, 0x270F);
 
   testStep("STEP", "Read value of signal Ball_Position --> Signal value read.");
   debugger_run();
   testWaitForTimeout(4000);
   signal_value = $DevKit_01::Ball_Position.raw64;
   EvalManStepEqual("Compare application vs can", signal_value, variable_value);
   
  //====================================================
  testCaseComment("Postcondition");
  testStep("STEP", "Return ECU to default values");
  RunPostTs();
  
}
void MainTest()
{
  InitTestModule();
//  Sw_Int_CIL_RP_IF_AB_eCS_Aktuatortest_BF_XIX_Grundumfang_XIX_eCS_01();
//  Sw_Int_CIL_RP_IF_AB_eCS_Aktuatortest_BF_XIX_Grundumfang_XIX_eCS_02();
//  Sw_Int_CIL_RP_IF_AB_eCS_Aktuatortest_FA_XIX_Grundumfang_XIX_eCS_01();
//  Sw_Int_CIL_RP_IF_AB_eCS_Aktuatortest_FA_XIX_Grundumfang_XIX_eCS_02();
//  Sw_Int_CIL_RP_IF_AB_eCS_Aktuatolrtest_Reihe2_BF_XIX_Grundumfang_XIX_eCS_01();
//  Sw_Int_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_BF_XIX_Grundumfang_XIX_eCS_02();
//  Sw_Int_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_FA_XIX_Grundumfang_XIX_eCS_01();
//  Sw_Int_CIL_RP_IF_AB_eCS_Aktuatortest_Reihe2_FA_XIX_Grundumfang_XIX_eCS_02();
////  Sw_Int_CIL_RP_IF_AB_Crash_Int_XIX_Grundumfang_XIX_eCS_01();
////  Sw_Int_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS_01();
////  Sw_Int_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS_02();
////  Sw_Int_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS_03();
////  Sw_Int_CIL_SP_IF_eCS_Status_XIX_Grundumfang_XIX_eCS_04();
//  Sw_Int_CIL_SP_IF_eCS_Gurtschloss_Status_Reihe2_BF_XIX_Grundumfang_XIX_eCS_01();
//  Sw_Int_CIL_SP_IF_eCS_Gurtschloss_Status_Reihe2_FA_XIX_Grundumfang_XIX_eCS_01();
//  Sw_Int_CIL_P_CAN_CanDataOut_Frame_0_01();
//  Sw_Int_CIL_P_CAN_CanDataOut_Frame_0_02();
//  Sw_Int_CIL_P_CAN_CanDataOut_Frame_0_03();
//  Sw_Int_CIL_P_CAN_CanDataOut_Frame_0_04();
//  Sw_Int_CIL_P_CAN_CanDataOut_Frame_0_05();
}