/*@!Encoding:1252*/
includes
{
  #pragma library("..\..\Includes\AER_SA.dll")
}


variables
{
  const CMEM_BLOCK_SIZE = 41;
  char bReadMemByAddressBuf[500];
  char cEpvBlockName[CMEM_BLOCK_SIZE][50] = 
  {
    "NVM_BLOCK_ECC_COUNTERS",
    "NVM_BLOCK_WARM_RESET_COUNTERS",
    "NVM_BLOCK_RESERVED_2",
    "NVM_BLOCK_AUTOTEST_ENABLE_PARAM",
    "NVM_BLOCK_LOCK_UNLOCK_ECU",
    "NVM_BLOCK_MEASUREMENT_FRAME_CONFIG",
    "NVM_BLOCK_HW_PART_NUMBER",
    "NVM_BLOCK_AEE_TRACEABILITY_NUMBER",
    "NVM_BLOCK_ECU_ASSEMBLY_SERIAL_NUMBER",
    "NVM_BLOCK_PROCESS_MODE",
    "NVM_BLOCK_ECS_VARIANT",
    "NVM_BLOCK_ECS_PARAMETERS",
    "NVM_BLOCK_ECS_ACC_OFFSETS",
    "NVM_BLOCK_RESERVED_3",
    "NVM_BLOCK_ECS_STEPS",
    "NVM_BLOCK_ECS_ACC_LOWPASS",
    "NVM_BLOCK_RESERVED_1",
    "NVM_BLOCK_ECS_ALGO_OUTPUT_DELAY",
    "NVM_BLOCK_ECS_SENSITIVITY_LUT",
    "NVM_BLOCK_ECS_SENSITIVITY_OPT",
    "NVM_BLOCK_ECU_TEMP_CALIBRATION",
    "NVM_BLOCK_ALV_NVM_VERSION",
    "NVM_BLOCK_MEAS_FRAME_RAM_ADDR_CFG",
    "NVM_BLOCK_ACC_AXIS_ANGLE_CALIBRATION",
    "NVM_BLOCK_EOL_COUNTERS",
    "NVM_BLOCK_RESERVED_4",
    "NVM_BLOCK_AUTOTEST_PARAM",
    "NVM_BLOCK_PHYS_MEASUREMENTS",
    "NVM_BLOCK_SOLENOID_PARAM",
    "NVM_BLOCK_ECS_PROFILES",
    "NVM_BLOCK_ECU_STATE_TIMING_PARAMETERS",
    "NVM_BLOCK_SPARE_PART_NUMBER",
    "NVM_BLOCK_HARDWARE_NUMBER",
    "NVM_BLOCK_SYSTEM_NAME_OR_ENGINE_TYPE",
    "NVM_BLOCK_BLOCK_FBL",
    "NVM_BLOCK_ODX_FILE_IDENTIFIER",
    "NVM_BLOCK_ODX_FILE_VERSION",
    "NVM_BLOCK_ECU_SERIAL_NUMBER",
    "NVM_BLOCK_LOGICAL_SW_BLOCK_VERSION",
    "NVM_BLOCK_HARDWARE_VERSION_NUMBER",
    "NVM_BLOCK_APP_SOFTWARE_VERSION_NUMBER"
};
  byte cEpvBlockData[CMEM_BLOCK_SIZE][500];
  int cEpvCurrentBlockData = 0;
  int cEpvCurrentBlockDataSize = 0;
  long cEpvBlockAddr[CMEM_BLOCK_SIZE] = {
    0xEE040000,
    0xEE050000,
    0xEE060000,
    0xEE070000,
    0xEE080000,
    0xEE090000,
    0xEE0A0000,
    0xEE0B0000,
    0xEE0C0000,
    0xEE0D0000,
    0xEE0E0000,
    0xEE0F0000,
    0xEE100000,
    0xEE110000,
    0xEE120000,
    0xEE130000,
    0xEE140000,
    0xEE150000,
    0xEE160000,
    0xEE170000,
    0xEE180000,
    0xEE190000,
    0xEE1A0000,
    0xEE1B0000,
    0xEE1C0000,
    0xEE1D0000,
    0xEE1E0000,
    0xEE1F0000,
    0xEE200000,
    0xEE210000,
    0xEE220000,
    0xEE230000,
    0xEE240000,
    0xEE250000,
    0xEE260000,
    0xEE270000,
    0xEE280000,
    0xEE290000,
    0xEE2A0000,
    0xEE2B0000,
    0xEE2C0000
  };
  int cEpvBlockSize[CMEM_BLOCK_SIZE] = {
    16,
    8,
    12,
    32,
    2,
    5,
    10,
    12,
    23,
    1,
    4,
    45,
    6,
    24,
    32,
    3,
    4,
    2,
    20,
    1,
    3,
    4,
    75,
    6,
    72,
    36,
    28,
    6,
    11,
    48,
    92,
    11,
    11,
    13,
    156,
    24,
    6,
    20,
    12,
    3,
    4
  };
  
  msTimer P2ExtendedTimeout;
  
  diagRequest eCS.Memory_Read Req_Read_Memory_By_Address;
  diagResponse eCS.Memory_Read Resp_Read_Memory_By_Address;
  
  diagRequest eCS.Memory_Write Req_Write_Memory_By_Address;
  diagResponse eCS.Memory_Write Resp_Write_Memory_By_Address;
  
  diagRequest eCS.Supplier_Diagnostic_Session_Start Req_Supplier_Diagnostic_Session_Start;
  
  diagRequest eCS.Supplier_RequestSeed_Request Req_Supplier_Application_Request;
  diagResponse eCS.Supplier_RequestSeed_Request Resp_Supplier_Application_Request;
  diagRequest eCS.Supplier_SendKey_Send Req_Supplier_Application_Send;
  diagResponse eCS.Supplier_SendKey_Send Resp_Supplier_Application_Send;
  
  diagRequest eCS.EcuUnlock_Start Req_EcuUnlock_Start;
  diagRequest eCS.EcuUnlock_Stop Req_EcuUnlock_Stop; 
  diagRequest eCS.EcuUnlock_RequestResults Req_EcuUnlock_RequestResults;
  
  diagRequest eCS.Hard_Reset_Reset Req_Hard_Reset;
  diagRequest eCS.Soft_Reset_Reset Req_Soft_Reset;
  
  diagRequest eCS.FaultMemory_Clear Req_FaultMemory_Clear; 
}

on timer P2ExtendedTimeout
{
  // do nothing, just wait for diag response, go for a walk outside and enjoy life
  testStepFail("STEP","Timeout received for diagnostic request");
}

on diagResponse eCS.Memory_Read
{
  int idx;
  long len;
  char bTempReadMemByAddressBuf[500];
  char cTestStepDescription[500];
  
  cancelTimer(P2ExtendedTimeout);
  
  if( diagIsNegativeResponse ( this ) )
  {
    snprintf(cTestStepDescription,elcount(cTestStepDescription),"Received negative response for service 0x%x, code 0x%x",
    this.GetPrimitiveByte(1),
    this.GetPrimitiveByte(2) );
    testStepFail("STEP",cTestStepDescription);
  }
  else
  {
    snprintf(cTestStepDescription,elcount(cTestStepDescription),"Positive response received for service 0x%x",
    this.GetPrimitiveByte(0));
    testStepPass("STEP",cTestStepDescription);
  }
  
  // clear buffer
  for(idx=0; idx < 500;idx++)
  {
    bReadMemByAddressBuf[idx] = 0;
  }
  
  len=this.GetPrimitiveSize();
  // add padding for first two bytes since size is calculated automatically for WMBA
  cEpvCurrentBlockDataSize = this.GetPrimitiveSize() + 1; 
  cEpvBlockData[cEpvCurrentBlockData][0] = 255;
  cEpvBlockData[cEpvCurrentBlockData][1] = 255;
  
  // convert to char for printing to .ini file
  for(idx=1; idx < len; idx++)
  {
    snprintf(bTempReadMemByAddressBuf,3,"%02x", this.GetPrimitiveByte(idx));
    strncat(bReadMemByAddressBuf,bTempReadMemByAddressBuf,idx*2+2+1);
    // save data for WMBA
    cEpvBlockData[cEpvCurrentBlockData][idx+1] = this.GetPrimitiveByte(idx);
  }  
}

on diagResponse eCS.Supplier_RequestSeed_Request
{
  byte seedArray[8];
  int idx;
  byte SAkey[8];
  char byteChar[8];
  char out[300];
  char out2[300];
  char tempOut[300];  
  
  DiagGetParameterRaw(this, "SecuritySeed", seedArray, elcount(seedArray));
  
  //contsruct frame
  getALVkey(elcount(seedArray),seedArray,SAkey);
  
  Req_Supplier_Application_Send.SetParameterRaw("SecurityKey", SAkey, 8);
  Req_Supplier_Application_Send.SendRequest();
}

on diagResponse *
{
  char cTestStepDescription[500];
  
  cancelTimer(P2ExtendedTimeout);

  // Handle the ambiguity of neg responses by treating them as '*'
  if( diagIsNegativeResponse ( this ) )
  {
    snprintf(cTestStepDescription,elcount(cTestStepDescription),"Received negative response for service 0x%x, code 0x%x",
    this.GetPrimitiveByte(1),
    this.GetPrimitiveByte(2) );
    testStepFail("STEP",cTestStepDescription);
  }
  else
  {
    snprintf(cTestStepDescription,elcount(cTestStepDescription),"Positive response received for service 0x%x",
    this.GetPrimitiveByte(0));

    testStepPass("STEP",cTestStepDescription);
  }
}

void waitForDiagResponse()
{
  setTimer(P2ExtendedTimeout, diagGetP2Extended ("eCS",1,0)); // wait for response

  while(isTimerActive(P2ExtendedTimeout) != 0)
  {
    /* timer is active, wait */
      testWaitForTimeout(50);
  }
}

testcase ReadMemByAddress1()
{
  int idx;
  char cFileName[13];
  char cTestStepDescription[500];
  
  testCaseComment("Enter supplier session");
  Req_Supplier_Diagnostic_Session_Start.SendRequest();
  
  waitForDiagResponse();
  
  testCaseComment("Issue supplier security access");
  Req_Supplier_Application_Request.SendRequest();
  
  waitForDiagResponse();
  
  snprintf(cFileName,elcount(cFileName)+1,"eCS_EPV_%d.ini",1);
  
  for( idx = 0; idx < CMEM_BLOCK_SIZE; idx++)
  {
    cEpvCurrentBlockData = idx;
    
    snprintf(cTestStepDescription,elcount(cTestStepDescription),"Send WriteMemByAddress Request for EEP block nb. %x",idx);

    testCaseComment("STEP",cTestStepDescription);

    Req_Read_Memory_By_Address.SetParameter("addressAndSize/Address",cEpvBlockAddr[idx]);
    Req_Read_Memory_By_Address.SetParameter("addressAndSize/Size",cEpvBlockSize[idx]);
    Req_Read_Memory_By_Address.SetParameter("addressAndLengthFormatIdentifier",0x24);
    Req_Read_Memory_By_Address.SendRequest();
    
    waitForDiagResponse();
    
    writeProfileString(cEpvBlockName[idx], "MemoryDump", bReadMemByAddressBuf, cFileName);
  }  
}


testcase ReadMemByAddress2()
{
  int idx;
  char cFileName[13];
  char cTestStepDescription[500];
  
  testCaseComment("Enter supplier session");
  Req_Supplier_Diagnostic_Session_Start.SendRequest();
  
  waitForDiagResponse();
  
  testCaseComment("Issue supplier security access");
  Req_Supplier_Application_Request.SendRequest();
  
  waitForDiagResponse();

  for( idx = 0; idx < CMEM_BLOCK_SIZE; idx++)
  {
    cEpvCurrentBlockData = idx;
    
    snprintf(cTestStepDescription,elcount(cTestStepDescription),"Send WriteMemByAddress Request for EEP block nb. %x",
    idx);
    testCaseComment("STEP",cTestStepDescription);

    Req_Read_Memory_By_Address.SetParameter("addressAndSize/Address",cEpvBlockAddr[idx]);
    Req_Read_Memory_By_Address.SetParameter("addressAndSize/Size",cEpvBlockSize[idx]);
    Req_Read_Memory_By_Address.SetParameter("addressAndLengthFormatIdentifier",0x24);
    Req_Read_Memory_By_Address.SendRequest();

    waitForDiagResponse();
    
    writeProfileString(cEpvBlockName[idx], "MemoryDump", bReadMemByAddressBuf, "eCS_EPV_2.ini");
  }  
}

testcase WriteMemByAddress()
{
  int idx;
  char cTestStepDescription[500];
  
  testCaseComment("Enter supplier session");
  Req_Supplier_Diagnostic_Session_Start.SendRequest();
  
  waitForDiagResponse();
  
  testCaseComment("Issue supplier security access");
  Req_Supplier_Application_Request.SendRequest();
  
  waitForDiagResponse();
  
  testCaseComment("Issue factory unlock routine");
  Req_EcuUnlock_Start.SendRequest();
  
  waitForDiagResponse();
  
  for( idx = 0; idx < CMEM_BLOCK_SIZE; idx++)
  {
    snprintf(cTestStepDescription,elcount(cTestStepDescription),"Send WriteMemByAddress Request for EEP block nb. %x", idx);
    
    testCaseComment("STEP",cTestStepDescription);
 
    Req_Write_Memory_By_Address.SetParameter("addressAndSizeAndData/Address",cEpvBlockAddr[idx]);
    Req_Write_Memory_By_Address.SetParameterRaw("addressAndSizeAndData/Memory",cEpvBlockData[idx],cEpvBlockSize[idx]+2);  
    Req_Write_Memory_By_Address.SetParameter("addressAndLengthFormatIdentifier",0x24);
    Req_Write_Memory_By_Address.SendRequest();
    
    waitForDiagResponse();
    
  } 
}

void MainTest ()
{
  // read all EEP parameters
  ReadMemByAddress1();
  // write back all EEP parameters
  WriteMemByAddress();
  // read back all EEP parameters
  ReadMemByAddress2();
  
  /* wait test close-out */
  testWaitForTimeout(250);
}