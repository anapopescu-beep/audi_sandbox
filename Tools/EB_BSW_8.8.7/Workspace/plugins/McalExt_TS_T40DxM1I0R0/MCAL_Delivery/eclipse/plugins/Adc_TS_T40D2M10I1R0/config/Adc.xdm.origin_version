<?xml version='1.0'?>
<datamodel version="3.0"
           xmlns="http://www.tresos.de/_projects/DataModel2/08/root.xsd"
           xmlns:a="http://www.tresos.de/_projects/DataModel2/08/attribute.xsd"
           xmlns:v="http://www.tresos.de/_projects/DataModel2/06/schema.xsd"
           xmlns:d="http://www.tresos.de/_projects/DataModel2/06/data.xsd">
<!--
*   @file    Adc.xdm
*   @version 1.0.1
*
*   @brief   AUTOSAR Adc - Tresos Studio plugin schema file
*   @details This file contains the schema configuration for and Adc Tresos Studio
*            plugin.
-->
<!--
====================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : ADC
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.1
*   Build Version        : S32K1_RTD_1_0_1_D2202_ASR_REL_4_4_REV_0000_20220224

*   (c) Copyright 2020-2022 NXP Semiconductors
*   All Rights Reserved.
====================================================================================================
-->
  <d:ctr type="AUTOSAR" factory="autosar"
         xmlns:ad="http://www.tresos.de/_projects/DataModel2/08/admindata.xsd"
         xmlns:icc="http://www.tresos.de/_projects/DataModel2/08/implconfigclass.xsd"
         xmlns:mt="http://www.tresos.de/_projects/DataModel2/11/multitest.xsd" >
    <d:lst type="TOP-LEVEL-PACKAGES">
      <d:ctr name="TS_T40D2M10I1R0" type="AR-PACKAGE">
        <a:a name="UUID" value="ECUC:8d4fdbd4-309e-4615-8f34-a64d5adbf2cc"/>
        <d:lst type="ELEMENTS">
          <!-- ECUC_Adc_00462 -->
          <!--  /** @implements Adc_Object */ -->
          <d:chc name="Adc" type="AR-ELEMENT" value="MODULE-DEF">
            <v:ctr type="MODULE-DEF">
              <a:a name="RELEASE" value="asc:4.4"/>
              <a:a name="ADMIN-DATA" type="ADMIN-DATA">
                <ad:ADMIN-DATA>
                  <ad:DOC-REVISIONS>
                    <ad:DOC-REVISION>
                      <ad:REVISION-LABEL>4.6.0</ad:REVISION-LABEL>
                      <ad:ISSUED-BY>AUTOSAR</ad:ISSUED-BY>
                      <ad:DATE>2014-10-31</ad:DATE>
                    </ad:DOC-REVISION>
                  </ad:DOC-REVISIONS>
                </ad:ADMIN-DATA>
              </a:a>
              <a:a name="POSTBUILDVARIANTSUPPORT" value="true"/>
              <a:a name="DESC"
                   value="EN: Configuration of the Adc (Analog Digital Conversion) module."/>
              <a:a name="LOWER-MULTIPLICITY" value="1"/>
              <a:a name="UPPER-MULTIPLICITY" value="1"/>
              <a:a name="UUID" value="ECUC:88c438bf-b6be-49f2-993b-3e287fdb21fc"/>
              <v:var name="POST_BUILD_VARIANT_USED" type="BOOLEAN">
                <a:a name="DESC"
                     value="Indicates whether a module implementation has or plans to have (i.e., introduced at link or post-build time) new post-build variation points."/>
                <a:a name="IMPLEMENTATIONCONFIGCLASS"
                     type="IMPLEMENTATIONCONFIGCLASS">
                  <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                </a:a>
                <a:a name="LABEL" value="Post Build Variant Used"/>
                <a:a name="ORIGIN" value="EB"/>
                <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                <a:da name="DEFAULT" value="false"/>
                <a:da name="READONLY" value="false"/>
                <a:da name="TOOLTIP"
                      value="Indicates whether a module implementation has or plans to have (i.e., introduced at link or post-build time) new post-build variation points."/>
              </v:var>

                <!--  @implements ConfigVariant_Object  -->
                <v:var name="IMPLEMENTATION_CONFIG_VARIANT" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v>
                      <![CDATA[EN:<html><p>
                           Configuration classes.
                           Enable the parameters that are editable for specific configuration classes
                           </p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                      <icc:v class="PreCompile">VariantPostBuild</icc:v>
                      <icc:v class="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Config Variant"/>
                  <a:a name="UUID" value="ECUC:1d992d8a-62c0-44f0-88a2-a4e8a4fae996"/>
                  <a:da name="DEFAULT" value="VariantPostBuild"/>
                  <a:da name="RANGE">
                    <a:v>VariantPostBuild</a:v>
                    <a:v>VariantPreCompile</a:v>
                  </a:da>
                </v:var>


                <!-- ECUC_Adc_00390  -->
                <!--  @implements AdcConfigSet_Object  -->
                <v:ctr name="AdcConfigSet"  type="IDENTIFIABLE">
                  <a:a name="DESC">
                       <a:v><![CDATA[EN:<html><p>This container contains the configuration parameters and sub containers of the AUTOSAR Adc module.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="UUID" value="ECUC:5c49ee28-8607-4878-ada6-4023d50d3efd"/>

                  <!-- SWS_Adc_00138 -->
                  <!-- /** @implements AdcHwUnit_Object */ -->
                  <v:lst name="AdcHwUnit" type="MAP">
                    <a:da name="MIN" value="1"/>
                    <a:da name="INVALID" type="XPath">
                       <a:tst expr="num:i(count(node:current()/*)) &gt; ecu:get(&apos;Adc.AdcConfigSet.AdcHwUnit&apos;)"
                       true="Maximum ADC Hardwares available for the selected derivative was exceeded."/>
                    </a:da>

                    <!-- AdcHwUnit Big container -->
                    <!-- ECUC_Adc_00242 -->
                    <v:ctr name="AdcHwUnit" type="IDENTIFIABLE">
                      <a:a name="DESC">
                        <a:v><![CDATA[EN:<html><p>This container contains the Driver configuration (parameters) depending on grouping of channels. This container could contain HW specific parameters which are not defined in the Standardized Module Definition. They must be added in the Vendor Specific Module Definition.</p></html>]]></a:v>
                      </a:a>
                      <a:a name="REQUIRES-INDEX" value="true"/>
                      <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                      <a:a name="IMPLEMENTATIONCONFIGCLASS"
                           type="IMPLEMENTATIONCONFIGCLASS">
                        <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                        <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                      </a:a>
                      <a:a name="UUID" value="ECUC:3d5fdf44-841b-443b-9cf1-bccd75b6198a"/>
                      <a:da name="INVALID" type="XPath">
                        <a:tst expr="text:uniq(../*/AdcHwUnit/*/@name, @name)" false="Duplicate Hardware Unit name"/>
                      </a:da>

                      <!-- AdcHwUnitId -->
                      <!-- ECUC_Adc_00389 -->
                      <v:var name="AdcHwUnitId" type="ENUMERATION">
                        <a:a name="DESC">
                          <a:v><![CDATA[EN:<html><p>Numeric ID of the HW Unit. This symbolic name allows accessing Hw Unit data. Enumeration literals are defined vendor specific.</p></html>]]></a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS"
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                        <a:a name="LABEL" value="Adc Hardware Unit"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:0c231b0e-e445-4ffc-be38-5b9e4425a277"/>
                        <a:da name="DEFAULT" value="ADC0"/>
                        <a:da name="RANGE" type="XPath" expr="ecu:list('Adc.AdcConfigSet.AdcHwUnits.List')"/>

                        <a:da name="INVALID" type="XPath">
                          <a:tst expr="text:uniq(../../*/AdcHwUnitId, .)" false="Duplicate Hw Unit id"/>
                          <a:tst expr="(num:i(count(ecu:list(concat('Adc.AdcConfigSet.AdcHwUnit',substring-after((.),'ADC'),'.AdcChannel.AdcChannelName'))))=0)"
                                true="This hardware unit does not support any ADC channels, please select another hardware unit."/>
                          <a:tst expr="../../../../AdcInterrupt/*[AdcInterruptSource='ADC0_COCO']/AdcInterruptEnable = 'false' and (.='ADC0') and (../AdcTransferType = 'ADC_INTERRUPT') and (count(../AdcGroup/*[AdcWithoutInterrupts='false']) > 0 ) "
                                true="This Unit has configured some Groups that need to use interrupts, so the associated End of Conversion interrupt must be enabled in Adc/AdcInterrupts container."/>
                          <a:tst expr="../../../../AdcInterrupt/*[AdcInterruptSource='ADC1_COCO']/AdcInterruptEnable = 'false' and (.='ADC1') and (../AdcTransferType = 'ADC_INTERRUPT') and (count(../AdcGroup/*[AdcWithoutInterrupts='false']) > 0 ) "
                                true="This Unit has configured some Groups that need to use interrupts, so the associated End of Conversion interrupt must be enabled in Adc/AdcInterrupts container."/>
                          <a:tst expr="../../../../AdcInterrupt/*[AdcInterruptSource='ADC0_COCO']/AdcInterruptEnable = 'true' and (.='ADC0') and (../AdcTransferType = 'ADC_INTERRUPT') and (count(../AdcGroup/*[AdcWithoutInterrupts='false']) = 0 ) "
                                true="All Groups in this unit configured as Groups Without Interrupt, so please disable the associated End of Conversion interrupt in Adc/AdcInterrupts container."/>
                          <a:tst expr="../../../../AdcInterrupt/*[AdcInterruptSource='ADC1_COCO']/AdcInterruptEnable = 'true' and (.='ADC1') and (../AdcTransferType = 'ADC_INTERRUPT') and (count(../AdcGroup/*[AdcWithoutInterrupts='false']) = 0 ) "
                                true="All Groups in this unit configured as Groups Without Interrupt, so please disable the associated End of Conversion interrupt in Adc/AdcInterrupts container."/>
                          <a:tst expr="(count(../../../../AdcInterrupt/*[contains(AdcInterruptSource,'ADC0') and AdcInterruptEnable = 'true']) > 0) and (count(../../../AdcHwUnit/*[AdcHwUnitId='ADC0']) = 0)"
                                true="Please disable Interrupt of ADC0 in tab AdcInterrupt if it's not configured."/>
                          <a:tst expr="(count(../../../../AdcInterrupt/*[contains(AdcInterruptSource,'ADC1') and AdcInterruptEnable = 'true']) > 0) and (count(../../../AdcHwUnit/*[AdcHwUnitId='ADC1']) = 0)"
                                true="Please disable Interrupt of ADC1 in tab AdcInterrupt if it's not configured."/>
                        </a:da>
                      </v:var>

                      <!-- AdcLogicalUnitId -->
                      <v:var name="AdcLogicalUnitId" type="INTEGER">
                        <a:a name="DESC">
                          <a:v><![CDATA[EN:<html><p>Specifies the Logical id of the Hardware Unit.</p></html>]]></a:v>
                        </a:a>
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS"
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="LABEL" value="Adc Logical Unit ID"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:f8f69c4d-d49e-4c7f-8651-5f7cfc5e3533"/>
                        <a:da name="DEFAULT" type="XPath" expr="node:fallback(node:current()/../@index, '0')"/>
                        <a:da name="RANGE" type="XPath">
                         <a:tst expr="(. &gt;= 0) and (. &lt; num:i(count(node:current()/../../*)))"
                         false="Value out of range: must be in range 0 to N-1 (N is number of configured units). Use the Calc button to calculate correct default value."/>
                         <a:tst expr="text:uniq(../../*/AdcLogicalUnitId, .)"
                         false="Duplicated value, AdcLogicalUnitId must be unique across all units. Use the Calc button to calculate correct default value."/>
                        </a:da>
                        <a:da name="INVALID" type="Range">
                          <a:tst expr="&lt;ecu:get(&apos;Adc.AdcConfigSet.AdcHwUnit&apos;)"/>
                          <a:tst expr="&gt;=0"/>
                        </a:da>
                      </v:var>

                      <!-- AdcTransferType -->
                      <v:var name="AdcTransferType" type="ENUMERATION">
                        <a:a name="DESC">
                          <a:v><![CDATA[EN:<html><p>Select the Interrupt or Dma transfer Type. If DMA is used, user must not run SW and HW groups at the same time on the same HW unit because the same DMA channel will be used for both.</p></html>]]></a:v>
                        </a:a>
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS"
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="LABEL" value="Adc Transfer Type"/>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:6ec8b4cb-1d4e-4c34-a80f-db2d5bc95df9"/>
                        <a:da name="DEFAULT" value="ADC_INTERRUPT"/>
                        <a:da name="RANGE">
                          <a:v>ADC_INTERRUPT</a:v>
                          <a:v>ADC_DMA</a:v>
                        </a:da>
                        <a:da name="INVALID" type="XPath">
                          <a:tst expr="(.= 'ADC_DMA') and ((ecu:get(&apos;AdcDMAPresent&apos;) = 'FALSE'))"
                                  true="DMA mode is not supported."/>
                          <a:tst expr="((. ='ADC_DMA') and (node:fallback(../../../../AutosarExt/AdcEnableDmaTransferMode,'false') = 'false'))"
                          true="DMA functionality is enabled only if AdcEnableDmaTransferMode = true"/>
                          <a:tst expr="(not(node:fallback(../../*/AdcTransferType,'ADC_DMA') = 'ADC_DMA')) and (../../../../AutosarExt/AdcEnableDmaTransferMode ='true')"
                        true="At least one HW Unit should be configured Transfer type is ADC_DMA when AdcEnableDmaTransferMode is enabled."/>
                          <a:tst expr="((. ='ADC_DMA') and (node:fallback(../../../AdcGeneral/AdcResultAlignment,'ADC_ALIGN_RIGHT') = 'ADC_ALIGN_LEFT'))"
                          true="In DMA Transfer Mode, ADC_ALIGN_LEFT is not supported because the left alignment is not supported by Hardware and the Result Buffers are recorded directly from Data Register by DMA."/>
                        </a:da>
                        <a:a name="EDITABLE" value="true"/>
                      </v:var>

                      <!-- Adc Dma Channel Id -->
                      <v:ref name="AdcDmaChannelId" type="REFERENCE">
                        <a:a name="DESC">
                          <a:v><![CDATA[EN:<html><p>ID of the DMA channel used to transfer the data.</p></html>]]></a:v>
                        </a:a>
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                        <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS"
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                          <icc:v mclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="OPTIONAL" value="true"/>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="LABEL" value="Select Dma Channel"/>
                        <a:a name="UUID" value="ECUC:64c1b027-6496-4954-ad34-13577adc9cdf"/>
                        <a:da name="REF" value="ASPathDataOfSchema:/AUTOSAR/EcucDefs/Mcl/MclConfig/dmaLogicChannel_Type"/>
                        <a:a name="EDITABLE" type="XPath" expr="(../AdcTransferType ='ADC_DMA')"/>
                        <a:da name="INVALID" type="XPath">
                          <a:tst expr="not(node:refvalid(.)) and (../AdcTransferType ='ADC_DMA')" true="Invalid XPath or empty reference. Need to select Dma Channel when Transfer Type is DMA"/>
                        </a:da>
                      </v:ref>

                      <!-- Adc Counting Dma Channel Id -->
                      <v:ref name="AdcCountingDmaChannelId" type="REFERENCE">
                        <a:a name="DESC">
                          <a:v><![CDATA[EN:<html><p>
                          Configurable only when Transfer Type is DMA and at least one group of hw unit has:
                          AdcEnableOptimizeDmaStreamingGroups enabled with more than one ADC channel
                          OR has selected Without Interrupts, ACCESS_MODE_STREAMING and Group Streaming Results Reorder and number of channels > 1
                          OR has selected Without Interrupts, ACCESS_MODE_STREAMING and a single channel - for this case, AutosarExt Adc Enable Group Streaming Results Reorder feature must be enabled, but can be disabled at group level.
                          Linked to DMA channel by ADC driver, to count the number of samples converted in streaming mode</p></html>]]></a:v>
                        </a:a>
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                        <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS"
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                          <icc:v mclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="OPTIONAL" value="true"/>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="LABEL" value="Select Adc Streaming Dma Channel"/>
                        <a:a name="UUID" value="ECUC:83bdc05c-9d44-4b3b-ba0e-2e09342b2747"/>
                        <a:da name="REF" value="ASPathDataOfSchema:/AUTOSAR/EcucDefs/Mcl/MclConfig/dmaLogicChannel_Type"/>
                        <a:a name="EDITABLE" type="XPath" expr="(../AdcTransferType ='ADC_DMA') and (num:i(count(../AdcGroup/*[(((AdcEnableOptimizeDmaStreamingGroups = 'true') or ((AdcWithoutInterrupts = 'true') and (AdcGroupAccessMode = 'ADC_ACCESS_MODE_STREAMING') and (AdcStreamResultGroup = 'true'))) and (count(AdcGroupDefinition/*) > 1)) or ((AdcWithoutInterrupts = 'true') and (AdcGroupAccessMode = 'ADC_ACCESS_MODE_STREAMING') and (count(AdcGroupDefinition/*) = 1))])) > 0)"/>
                        <a:da name="INVALID" type="XPath">
                          <a:tst expr="not(node:refvalid(.)) and (../AdcTransferType ='ADC_DMA') and (num:i(count(../AdcGroup/*[(((AdcEnableOptimizeDmaStreamingGroups = 'true') or ((AdcWithoutInterrupts = 'true') and (AdcGroupAccessMode = 'ADC_ACCESS_MODE_STREAMING') and (AdcStreamResultGroup = 'true'))) and (count(AdcGroupDefinition/*) > 1)) or ((AdcWithoutInterrupts = 'true') and (AdcGroupAccessMode = 'ADC_ACCESS_MODE_STREAMING') and (count(AdcGroupDefinition/*) = 1))])) > 0)"
                                true="Invalid XPath or empty reference. Need to select Counting Dma Channel when Transfer Type is DMA and at least one group of hw unit
                                      has AdcEnableOptimizeDmaStreamingGroups enabled with more than one ADC channels in AdcGroupDefinition
                                      OR has selected Without Interrupts, ACCESS_MODE_STREAMING and Group Streaming Results Reorder and number of channels > 1
                                      OR has selected Without Interrupts, ACCESS_MODE_STREAMING and a single channel - for this case, AutosarExt Adc Enable Group Streaming Results Reorder feature must be enabled, but can be disabled at group level. "/>
                          <a:tst expr="(not(node:empty(.)) and (. = ../AdcDmaChannelId))"
                                 true="Counting DMA channel and DMA channel need to be different"/>
                        </a:da>
                      </v:ref>

                      <!-- Adc Clock Source -->
                      <!-- ECUC_Adc_00087 -->
                      <v:var name="AdcClockSource" type="ENUMERATION">
                        <a:a name="DESC">
                          <a:v><![CDATA[EN:<html><p>The ADC module specific clock input for the conversion unit can statically be configured to select different clock sources if provided by hardware. Enumeration literals are defined vendor specific.
                                  <ul>
                                  <li>ADC_ALTCLK1        - Alternate clock 1.</li>
                                  <li>ADC_ALTCLK2        - Alternate clock 2.</li>
                                  <li>ADC_ALTCLK3        - Alternate clock 3.</li>
                                  <li>ADC_ALTCLK4        - Alternate clock 4.</li>
                                  </ul>.
                                  Note: Only ADC_ALTCLK1 is used by the current implementation.</p></html>]]>
                             </a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS"
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v class="PostBuild">VariantPostBuild</icc:v>
                          <icc:v class="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="OPTIONAL" value="true"/>
                        <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="LABEL" value="Adc Source Clock"/>
                        <a:a name="UUID" value="ECUC:d9d2de7c-e7da-4d5a-a3c1-b241cb8342bd"/>
                        <a:da name="DEFAULT" value="ADC_ALTCLK1"/>
                        <a:da name="READONLY" value="true"/>
                        <a:da name="RANGE">
                            <a:v>ADC_ALTCLK1</a:v>
                            <a:v>ADC_ALTCLK2</a:v>
                            <a:v>ADC_ALTCLK3</a:v>
                            <a:v>ADC_ALTCLK4</a:v>
                        </a:da>
                      </v:var>

                      <!-- AdcPrescale -->
                      <!-- ECUC_Adc_00088 -->
                      <v:var name="AdcPrescale" type="INTEGER">
                        <a:a name="DESC">
                             <a:v><![CDATA[EN:<html><p>Optional ADC module specific clock prescale factor, if supported by hardware.
                              ImplementationType: Adc_PrescaleType.
                              The Prescaler value for NORMAL mode. Only the following are allowed:
                                   <ul>
                                   <li>1: ADC clock frequency is equal to bus clock.</li>
                                   <li>2: ADC clock frequency is half of bus clock.</li>
                                   <li>4: ADC clock frequency is quarter of bus clock.</li>
                                   <li>8: ADC clock frequency is eighth of bus clock.</li>
                                   </ul>
                                   </p></html>]]></a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS"
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v class="PostBuild">VariantPostBuild</icc:v>
                          <icc:v class="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="LABEL" value="Adc Prescaler Value"/>
                        <a:a name="OPTIONAL" value="true"/>
                        <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:43c026fc-c64d-4dd4-b273-8d45334a6f92"/>
                        <a:da name="DEFAULT" value="1"/>
                        <a:da name="EDITABLE" value="true"/>
                        <a:da name="INVALID" type="Range">
                          <a:tst expr="&lt;=8"/>
                          <a:tst expr="&gt;=1"/>
                        </a:da>
                        <a:da name="RANGE" type="XPath">
                          <a:tst expr="(. != 1) and (. != 2) and (. != 4) and (. != 8)" true="Only values 1, 2, 4 and 8 are allowed"/>
                        </a:da>
                        <a:da name="RANGE" type="Range">
                          <a:tst expr="&lt;=65535"/>
                          <a:tst expr="&gt;=0"/>
                        </a:da>
                      </v:var>

                    <!-- AdcAltPrescale -->
                      <v:var name="AdcAltPrescale" type="INTEGER">
                        <a:a name="DESC">
                             <a:v><![CDATA[EN:<html><p>The Prescaler value for ALTERNATE mode. This feature can be configured if Adc Set Clock Mode API from General/AutosarExt is enabled. Only the following are allowed:
                                   <ul>
                                   <li>1: ADC clock frequency is equal to bus clock.</li>
                                   <li>2: ADC clock frequency is half of bus clock.</li>
                                   <li>4: ADC clock frequency is quarter of bus clock.</li>
                                   <li>8: ADC clock frequency is eighth of bus clock.</li>
                                   </ul>
                                   </p></html>]]></a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS"
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="LABEL" value="Adc Alternate Prescale"/>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:c227b7fb-ea26-4387-be77-14b370bfa914"/>
                        <a:a name="EDITABLE" type="XPath">
                          <a:tst expr="node:fallback(../../../../AutosarExt/AdcEnableDualClockMode,'true') = 'true' and node:exists(../AdcPrescale)"/>
                        </a:a>
                        <a:da name="DEFAULT" value="2"/>
                        <a:da name="RANGE" type="XPath">
                          <a:tst expr="(node:fallback(../../../../AutosarExt/AdcEnableDualClockMode,'true') = 'true') and node:exists(../AdcPrescale) and  (num:i(.) = num:i(node:fallback(../AdcPrescale, 1)))"
                                 true="Prescale value for NORMAL mode and ALTERNATE mode should be different if Adc Set Clock Mode API is enabled in Adc/AutosarExt container."/>
                          <a:tst expr="(. != 1) and (. != 2) and (. != 4) and (. != 8)" true="Only values 1, 2, 4 and 8 are allowed"/>
                        </a:da>
                        <a:da name="INVALID" type="Range">
                          <a:tst expr="&lt;=8"/>
                          <a:tst expr="&gt;=1"/>
                        </a:da>
                      </v:var>

                    <!-- AdcCalibrationPrescale -->
                    <v:var name="AdcCalibrationPrescale" type="INTEGER">
                      <a:a name="DESC">
                        <a:v><![CDATA[EN:<html><p>Specifies the used clock input for calibration. This feature can be configured if Adc Enable Calibration API from General/AutosarExt is enabled.
                                   <ul>
                                   <li>1: ADC clock frequency is equal to bus clock.</li>
                                   <li>2: ADC clock frequency is half of bus clock.</li>
                                   <li>4: ADC clock frequency is quarter of bus clock.</li>
                                   <li>8: ADC clock frequency is eighth of bus clock.</li>
                                   </ul>
                                   IMPORTANT NOTE: The clock for calibration must be less than or equal to half of maximum specified frequency (50Mhz) and higher than minimum frequency (2Mhz).
                                   Please refer to Datasheet for more details.
                                   </p></html>]]>
                        </a:v>
                      </a:a>
                      <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                      <a:a name="SCOPE" value="LOCAL"/>
                      <a:a name="IMPLEMENTATIONCONFIGCLASS"
                         type="IMPLEMENTATIONCONFIGCLASS">
                        <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                        <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                      </a:a>
                      <a:a name="LABEL" value="Adc Calibration Prescale"/>
                      <a:a name="ORIGIN" value="NXP"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:a name="UUID" value="ECUC:43c026fc-c64d-4dd4-b273-14b370bfa145"/>
                      <a:a name="EDITABLE" type="XPath">
                        <a:tst expr="node:fallback(../../../../AutosarExt/AdcEnableCalibration,'true') = 'true'"/>
                      </a:a>
                      <a:da name="DEFAULT" value="8"/>
                      <a:da name="RANGE" type="XPath">
                        <a:tst expr="(. != 1) and (. != 2) and (. != 4) and (. != 8)" true="Only values 1, 2, 4 and 8 are allowed"/>
                      </a:da>
                        <a:da name="INVALID" type="Range">
                          <a:tst expr="&lt;=8"/>
                          <a:tst expr="&gt;=1"/>
                        </a:da>
                    </v:var>

                      <!-- AdcHwUnitUsrOffset -->
                      <v:var name="AdcHwUnitUsrOffset" type="INTEGER">
                        <a:a name="DESC">
                          <a:v><![CDATA[EN:<html><p>Set user defined offset.</p></html>]]></a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="LABEL" value="Adc User Offset"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:16426534-25ba-4d15-a8f6-30f4879cb9d2"/>
                        <a:da name="DEFAULT" value="0"/>
                        <a:da name="INVALID" type="Range">
                          <a:tst expr="&gt;=0"/>
                          <a:tst expr="&lt;=255"/>
                        </a:da>
                      </v:var>

                      <!-- AdcHwUnitUsrGain -->
                      <v:var name="AdcHwUnitUsrGain" type="INTEGER">
                        <a:a name="DESC">
                          <a:v><![CDATA[EN:<html><p>Set user defined gain.</p></html>]]></a:v>
                        </a:a>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="LABEL" value="Adc User Gain"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:16426524-25ba-4d15-a8f6-30f4879cb9d2"/>
                        <a:da name="DEFAULT" value="4"/>
                        <a:da name="INVALID" type="Range">
                          <a:tst expr="&gt;=0"/>
                          <a:tst expr="&lt;=1023"/>
                        </a:da>
                      </v:var>

                      <!-- AdcHwUnitResolution -->
                      <v:var name="AdcHwUnitResolution" type="ENUMERATION">
                        <a:a name="DESC">
                          <a:v><![CDATA[EN:<html><p>Select the number of significant bits per conversion data.</p></html>]]></a:v>
                        </a:a>
                        <a:a name="SCOPE" value="LOCAL"/>
                        <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                            <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="LABEL" value="Conversion resolution"/>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                        <a:a name="UUID" value="ECUC:8e2f1435-2754-4f03-b084-073b363aaa66"/>
                        <a:da name="DEFAULT" value="RESOLUTION_12"/>
                        <a:da name="RANGE">
                            <a:v>RESOLUTION_12</a:v>
                            <a:v>RESOLUTION_10</a:v>
                            <a:v>RESOLUTION_8</a:v>
                        </a:da>
                      </v:var>

                      <v:ctr name="AdcNormalConvTimings" type="IDENTIFIABLE">
                        <a:a name ="DESC">
                          <a:v>
                              <![CDATA[<html><p> Selects Normal values used for programming clock frequency, conversion timing and hardwre averaging used at initialization and also by Adc_SetClockMode API when it is called with parameter ADC_NORMAL. </p></html>]]></a:v>
                        </a:a>
                        <a:a name="UUID" value="ECUC:0cb2283c-677d-434e-80a6-169b5c6e63e4"/>
                        <a:a name="OPTIONAL" value="true"/>
                        <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS"
                            type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v mclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="EDITABLE" type="XPath">
                          <a:tst expr="node:fallback(../../../../AutosarExt/AdcConvTimeOnce,'true') = 'true'"/>
                        </a:a>

                        <!-- AdcHardwareAverageEnable -->
                        <v:var name="AdcHardwareAverageEnable" type="BOOLEAN">
                          <a:a name="DESC">
                            <a:v><![CDATA[EN:<html><p>Enables the hardware average function of the ADC.</p></html>]]></a:v>
                          </a:a>
                          <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                          <a:a name="SCOPE" value="LOCAL"/>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS"
                              type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                            <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="LABEL" value="Adc Hardware Average Enable"/>
                          <a:a name="ORIGIN" value="NXP"/>
                          <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                          <a:a name="UUID" value="ECUC:8fd361db-6ed5-41d7-9ecb-b2046cf3f993"/>
                          <a:a name="EDITABLE" type="XPath">
                                <a:tst expr="node:fallback(../../../../../AutosarExt/AdcConvTimeOnce,'true') = 'true'"/>
                          </a:a>
                          <a:da name="DEFAULT" value="false"/>
                        </v:var>

                        <!-- AdcHardwareAverageSelect -->
                        <v:var name="AdcHardwareAverageSelect" type="ENUMERATION">
                          <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>Determines how many ADC conversions will be averaged to create the ADC average result. This functionality is activated when ADCx_MCR[AVGEN] = 1.
                                    <ul>
                                    <li>SAMPLES_4        - 4 samples averaged.</li>
                                    <li>SAMPLES_8        - 8 samples averaged.</li>
                                    <li>SAMPLES_16       - 16 samples averaged.</li>
                                    <li>SAMPLES_32       - 32 samples averaged.</li>
                                    </ul>.</p></html>]]></a:v>
                          </a:a>
                          <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                          <a:a name="SCOPE" value="LOCAL"/>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                            <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="ORIGIN" value="NXP"/>
                          <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                          <a:a name="LABEL" value="Adc Hardware Average Select"/>
                          <a:a name="UUID" value="ECUC:f1f0591f-5cc8-4ed5-be66-b24399ffed3f"/>
                          <a:da name="DEFAULT" value="SAMPLES_4"/>
                          <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="(node:fallback(../AdcHardwareAverageEnable,'true') = 'true')
                              and node:fallback(../../../../../AutosarExt/AdcConvTimeOnce,'true') = 'true'"/>
                          </a:a>
                          <a:da name="RANGE">
                              <a:v>SAMPLES_4</a:v>
                              <a:v>SAMPLES_8</a:v>
                              <a:v>SAMPLES_16</a:v>
                              <a:v>SAMPLES_32</a:v>
                          </a:da>
                        </v:var>

                        <!-- AdcSampleTimeDuration -->
                        <v:var name="AdcSampleTimeDuration" type="INTEGER">
                          <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>Input a value 1 to 255 means selecting a sample time of 2 to 256 ADCK clock cycles. The value written to this register is the desired sample time minus 1.</p></html>]]></a:v>
                          </a:a>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v class="PostBuild">VariantPostBuild</icc:v>
                            <icc:v class="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="LABEL" value="Adc Sample Time Duration"/>
                          <a:a name="ORIGIN" value="NXP"/>
                          <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                          <a:a name="UUID" value="ECUC:6153a38d-da3e-4d9e-8564-f8fe85f7b2b4"/>
                          <a:da name="DEFAULT" value="12"/>
                          <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="(node:fallback(../../../../../AutosarExt/AdcConvTimeOnce,'false') = 'true')"/>
                          </a:a>
                          <a:da name="INVALID" type="Range">
                            <a:tst expr="&lt;=255"/>
                            <a:tst expr="&gt;=1"/>
                          </a:da>
                        </v:var>
                      </v:ctr>

                      <v:ctr name="AdcAlternateConvTimings" type="IDENTIFIABLE">
                        <a:a name ="DESC">
                          <a:v>
                            <![CDATA[<html><p> Selects Alternate values used in Adc_SetClockMode API for programming CTR Conversion Timing Registers. This container is available only when AdcEnableDualClockMode has been enabled. Hardware averaging functionality is also available for configuration </p></html>]]></a:v>
                        </a:a>
                        <a:a name="UUID" value="ECUC:0cb2283c-677d-434e-80a6-169b5c6e63e5"/>
                        <a:a name="OPTIONAL" value="true"/>
                        <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS"
                            type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v mclass="PostBuild">VariantPostBuild</icc:v>
                          <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="EDITABLE" type="XPath">
                          <a:tst expr="node:fallback(../../../../AutosarExt/AdcConvTimeOnce,'true') = 'true'and (../../../../AutosarExt/AdcEnableDualClockMode = 'true')"/>
                        </a:a>

                        <!-- AdcHardwareAverageEnableAlternate -->
                        <v:var name="AdcHardwareAverageEnableAlternate" type="BOOLEAN">
                          <a:a name="DESC">
                            <a:v><![CDATA[EN:<html><p>Alternate configuration: Enables the hardware average function of the ADC.</p></html>]]></a:v>
                          </a:a>
                          <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                          <a:a name="SCOPE" value="LOCAL"/>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS"
                              type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                            <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="LABEL" value="Adc Alternate Hardware Average Enable"/>
                          <a:a name="ORIGIN" value="NXP"/>
                          <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                          <a:a name="UUID" value="ECUC:8fd361db-6ed5-41d7-9ecb-b2046cf3f942"/>
                          <a:da name="DEFAULT" value="false"/>
                          <a:da name="EDITABLE" type="XPath" expr="../../../../../AutosarExt/AdcEnableDualClockMode = 'true' and node:fallback(../../../../../AutosarExt/AdcConvTimeOnce,'true') = 'true'"/>
                        </v:var>

                        <!-- AdcHardwareAverageSelectAlternate -->
                        <v:var name="AdcHardwareAverageSelectAlternate" type="ENUMERATION">
                          <a:a name="DESC">
                               <a:v><![CDATA[EN:<html><p>Alternate configuration: Determines how many ADC conversions will be averaged to create the ADC average result. This functionality is activated when ADCx_MCR[AVGEN] = 1.
                                    <ul>
                                    <li>SAMPLES_4        - 4 samples averaged.</li>
                                    <li>SAMPLES_8        - 8 samples averaged.</li>
                                    <li>SAMPLES_16       - 16 samples averaged.</li>
                                    <li>SAMPLES_32       - 32 samples averaged.</li>
                                    </ul>.</p></html>]]></a:v>
                          </a:a>
                          <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                          <a:a name="SCOPE" value="LOCAL"/>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS"
                               type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                            <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="ORIGIN" value="NXP"/>
                          <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                          <a:a name="LABEL" value="Adc Alternate Hardware Average Select"/>
                          <a:a name="UUID" value="ECUC:f1f0591f-5cc8-4ed5-be66-b24399ffed42"/>
                          <a:da name="DEFAULT" value="SAMPLES_4"/>
                          <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="(node:fallback(../AdcHardwareAverageEnableAlternate,'true') = 'true')
                              and (../../../../../AutosarExt/AdcEnableDualClockMode = 'true')
                              and node:fallback(../../../../../AutosarExt/AdcConvTimeOnce,'true') = 'true'"/>
                          </a:a>
                          <a:da name="RANGE">
                              <a:v>SAMPLES_4</a:v>
                              <a:v>SAMPLES_8</a:v>
                              <a:v>SAMPLES_16</a:v>
                              <a:v>SAMPLES_32</a:v>
                          </a:da>
                        </v:var>

                        <!-- AdcSampleTimeDurationAlternate -->
                        <v:var name="AdcSampleTimeDurationAlternate" type="INTEGER">
                          <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>Alternate configuration: Input a value 1 to 255 means selecting a sample time of 2 to 256 ADCK clock cycles. The value written to this register is the desired sample time minus 1.</p></html>]]></a:v>
                          </a:a>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v class="PostBuild">VariantPostBuild</icc:v>
                            <icc:v class="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="LABEL" value="Adc Sample Time Duration"/>
                          <a:a name="ORIGIN" value="NXP"/>
                          <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                          <a:a name="UUID" value="ECUC:6153a38d-da3e-4d9e-8564-f8fe85f7b242"/>
                          <a:da name="DEFAULT" value="12"/>
                          <a:da name="EDITABLE" type="XPath" expr="(node:fallback(../../../../../AutosarExt/AdcEnableDualClockMode,'false') = 'true') and
                                                                   (node:fallback(../../../../../AutosarExt/AdcConvTimeOnce,'false') = 'true')"/>
                          <a:da name="INVALID" type="Range">
                            <a:tst expr="&lt;=255"/>
                            <a:tst expr="&gt;=1"/>
                          </a:da>
                        </v:var>
                      </v:ctr>

                      <!-- PdbHwUnit container -->
                      <v:ctr name="PdbHwUnit" type="IDENTIFIABLE">
                      <a:a name="DESC">
                          <a:v><![CDATA[EN:<html>This container contains the configuration of the PDB unit.</html>]]></a:v>
                      </a:a>
                      <a:a name="UUID" value="ECUC:1cf54df3-52ba-44f7-9d9b-ea80a5426351"/>

                        <!-- AdcPdbPrescalerDividerSelect -->
                        <v:var name="AdcPdbPrescalerDividerSelect" type="INTEGER">
                          <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Determines the prescaler used for the PDB counter.
                                    <ul>
                                    <li>0        - Counting uses the peripheral clock divided by multiplication factor selected by AdcPdbMultiplicationFactorSelect.</li>
                                    <li>1        - Counting uses the peripheral clock divided by twice of the multiplication factor selected by AdcPdbMultiplicationFactorSelect.</li>
                                    <li>2        - Counting uses the peripheral clock divided by four of the multiplication factor selected by AdcPdbMultiplicationFactorSelect.</li>
                                    <li>3        - Counting uses the peripheral clock divided by eight of the multiplication factor selected by AdcPdbMultiplicationFactorSelect.</li>
                                    <li>4        - Counting uses the peripheral clock divided by 16 times of the multiplication factor selected by AdcPdbMultiplicationFactorSelect.</li>
                                    <li>5        - Counting uses the peripheral clock divided by 32 times of the multiplication factor selected by AdcPdbMultiplicationFactorSelect.</li>
                                    <li>6        - Counting uses the peripheral clock divided by 64 times of the multiplication factor selected by AdcPdbMultiplicationFactorSelect.</li>
                                    <li>7        - Counting uses the peripheral clock divided by 128 times of the multiplication factor selected by AdcPdbMultiplicationFactorSelect.</li>
                                    </ul>.</p></html>]]>
                              </a:v>
                          </a:a>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="LABEL" value="Adc Pdb Prescaler Divider Select"/>
                          <a:a name="ORIGIN" value="NXP"/>
                          <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                          <a:a name="UUID" value="ECUC:f1f0591f-5cc8-4ed5-be66-b24399ffed4f"/>
                          <a:da name="DEFAULT" value="0"/>
                          <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=7"/>
                              <a:tst expr="&gt;=0"/>
                          </a:da>
                        </v:var>

                        <!-- AdcPdbMultiplicationFactorSelect -->
                        <v:var name="AdcPdbMultiplicationFactorSelect" type="INTEGER">
                          <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Selects the multiplication factor of the prescaler divider for the counter clock of the associated PDB unit.
                                    <ul>
                                    <li>0           - Multiplication factor is 1.</li>
                                    <li>1           - Multiplication factor is 10.</li>
                                    <li>2           - Multiplication factor is 20.</li>
                                    <li>3           - Multiplication factor is 40.</li>
                                    </ul>.</p></html>]]>
                              </a:v>
                          </a:a>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS"
                              type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="ORIGIN" value="NXP"/>
                          <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                          <a:a name="LABEL" value="Adc Pdb Multiplication Factor Select for Prescaler"/>
                          <a:a name="UUID" value="ECUC:09a81631-53de-45eb-a71f-98a42f687942"/>
                          <a:da name="DEFAULT" value="0"/>
                          <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=3"/>
                              <a:tst expr="&gt;=0"/>
                          </a:da>
                        </v:var>

                        <!-- AdcPdbCounterPeriod -->
                        <v:var name="AdcPdbCounterPeriod" type="INTEGER">
                          <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Specifies the period of the counter. When
                              the counter reaches this value, it will be reset back to zero. If
                              the PDB is in Continuous mode, the count begins anew. Reading this
                              field returns the value of the internal register that is effective
                              for the current cycle of PDB.</p></html>]]>
                              </a:v>
                          </a:a>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS"
                              type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="ORIGIN" value="NXP"/>
                          <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                          <a:a name="LABEL" value="Adc Pdb Counter Period"/>
                          <a:a name="UUID" value="ECUC:09a81631-53de-45eb-a71f-98a42f6879c2"/>
                          <a:da name="DEFAULT" value="65535"/>
                          <a:da name="INVALID" type="Range">
                              <a:tst expr="&gt;=0"/>
                              <a:tst expr="&lt;=65535"/>
                          </a:da>
                        </v:var>

                        <!-- AdcPdbErrorNotification -->
                        <v:var name="AdcPdbErrorNotification" type="FUNCTION-NAME">
                          <a:a name="DESC">
                            <a:v><![CDATA[EN:<html><p>Callback function for PDB channel sequence error. This function pointer is called everytime when PDB channel sequence error occurred. Setting this field to a non-null value will also enable the interrupt.</p></html>]]></a:v>
                          </a:a>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v class="PostBuild">VariantPostBuild</icc:v>
                            <icc:v class="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="LABEL" value="Adc Pdb Sequence Error Notification"/>
                          <a:a name="ORIGIN" value="NXP"/>
                          <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                          <a:a name="UUID" value="ECUC:45315cb5-e0ed-4c8c-b013-4f21012be2c3"/>
                          <a:da name="DEFAULT" value="NULL_PTR"/>
                        </v:var>
                        <!-- PdbInterChnBackToBackEnable -->
                        <v:var name="PdbInterChnBackToBackEnable" type="BOOLEAN">
                          <a:a name="DESC">
                            <a:v><![CDATA[EN:<html><p>Enable the inter-channel back to back mode between PDBx CH0 and PDBx CH1 pre-triggers, forming a ring (PDBx_CH0_pretrigger7 -> PDBx_CH1_pretrigger0 and PDBx_CH1_pretrigger7 -> PDBx_CH0_pretrigger0).
                                  &lt;b&gt;NOTE:&lt;/b&gt; this configuration is dedicated to each PDB instance.
                                  If this node is enabled, AdcDelayNextPdb is not required in all group configured with back to back mode and number of channels is greater than 8</p></html>]]></a:v>
                          </a:a>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS"
                              type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="ORIGIN" value="NXP"/>
                          <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                          <a:a name="LABEL" value="Pdb Enable Inter-channel Back to Back Mode"/>
                          <a:a name="UUID" value="ECUC:09a81631-53de-45eb-a71f-98a42f6879c4"/>
                          <a:da name="DEFAULT" value="false"/>
                          <a:a name="EDITABLE" type="XPath" expr="(ecu:get('Adc.Pdb.ChannelBackToBack') = 'TRUE') and (../../../../../AutosarExt/AdcEnablePdbInterChannelBackToBackSupport = 'true')"/>
                          <a:da name="INVALID" type="XPath">
                            <a:tst expr="(. = 'true') and (ecu:get('Adc.Pdb.ChannelBackToBack') = 'TRUE') and (../../../../../AutosarExt/AdcEnablePdbInterChannelBackToBackSupport = 'true') and (count(../../AdcGroup/*[(AdcGroupInBacktoBackMode = 'true') and (count(AdcGroupDefinition/*) > 8) and (AdcDelayNextPdb != 0)]) > 0)"
                                   true="InterchannelBackToBackEnable can only be enabled if all groups are in back to back mode with number of channels > 8 and AdcDelayNextPdb = 0"/>
                          </a:da>
                        </v:var>
                      </v:ctr>

                      <!-- AdcChannel Big container -->
                      <!-- ECUC_Adc_00268 -->
                      <!-- /** @implements AdcChannel_Object */ -->
                      <v:lst name="AdcChannel" type="MAP">
                        <a:da name="MIN" value="1"/>
                        <v:ctr name="AdcChannel" type="IDENTIFIABLE">
                          <a:a name="DESC">
                            <a:v><![CDATA[EN:<html><p>This container contains the channel configuration (parameters) depending on the hardware capability.
                              The organization of this data structure could contain dependencies to the microcontroller so this is left up to the implementer and its location is left up to the configuration.
                              Note: Since a AdcChannel can be part of several AdcGroups, this container is not realized as a subcontainer of AdcGroup but instead as a subcontainer of AdcHwUnit.</p></html>]]></a:v>
                          </a:a>
                          <a:a name="REQUIRES-INDEX" value="true"/>
                          <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS"
                               type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                            <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:a name="UUID" value="ECUC:1bda8cf5-cdd6-4b14-8b9f-8a6f6f567ed8"/>
                          <a:da name="INVALID" type="XPath">
                            <a:tst expr="text:uniq(../../../*/AdcChannel/*/@name, @name)" false="Duplicate AdcChannelNames, Channel Symbolic names must be unique across HWUnits."/>
                          </a:da>

                          <!-- AdcLogicalChannelId -->
                          <v:var name="AdcLogicalChannelId" type="INTEGER">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>This is the logical Id of the ADC channel.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Logical Channel ID"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:e2e71142-5b64-4236-b15f-9b880ca8325c"/>
                            <a:da name="DEFAULT" type="XPath" expr="node:fallback(node:current()/../@index, '0')"/>
                            <a:da name="RANGE" type="XPath">
                             <a:tst expr="(. &gt;= 0) and (. &lt; num:i(count(node:current()/../../*)))"
                             false="Value out of range: must be in range 0 to N-1 (N is number of configured channels). Use the Calc button to calculate correct default value."/>
                             <a:tst expr="text:uniq(../../*/AdcLogicalChannelId, .)"
                             false="Duplicated value, AdcLogicalChannelId must be unique across all channels. Use the Calc button to calculate correct default value."/>
                            </a:da>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=1024"/>
                              <a:tst expr="&gt;=0"/>
                            </a:da>
                          </v:var>

                          <!-- AdcChannelName -->
                          <v:var name="AdcChannelName" type="ENUMERATION">
                            <a:a name="DESC">
                                  <a:v><![CDATA[EN:<html><p>This parameter defines the assignment of the channel to the physical ADC hardware channel. Note: - Range of the ADC Channels depends on the selected package.
                                  </p></html>]]></a:v>
                            </a:a>
                              <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                              <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Physical Channel Name"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                              <a:a name="UUID" value="ECUC:ac534dfe-22b7-4c19-a37c-12e631ff4e90"/>
                            <a:da name="DEFAULT" type="XPath" expr="ecu:list(concat('Adc.AdcConfigSet.AdcHwUnit',substring-after(string(node:fallback(../../../AdcHwUnitId,'ADC0')), 'ADC'),'.AdcChannel.AdcChannelName'))[position()-1=node:fallback(node:current()/../@index,0)]"></a:da>
                            <a:da name="RANGE" type="XPath" expr="ecu:list(concat('Adc.AdcConfigSet.AdcHwUnit',substring-after(string(node:fallback(../../../AdcHwUnitId,'')), 'ADC'),'.AdcChannel.AdcChannelName'))"/>
                            <a:da name="INVALID" type="XPath">
                                <a:tst expr="text:uniq(../../*/AdcChannelName, .)" false="Duplicate physical channel"/>
                                <a:tst expr="count(../../*[contains(AdcChannelName,'INT0_ADCH21')]) &lt;= 1" false="Only 1 internal channel (INT0_ADCH21) can be configured at the given time."/>
                                <a:tst expr="contains(.,'INT0_ADCH21') and (../../../../../../AutosarExt/AdcEnableSimSupplyMonitor = 'false')" true="The Adc/AutosarExt/AdcEnableSimSupplyMonitor must be enabled in order to use this internal channel."/>
                            </a:da>
                          </v:var>

                          <!-- AdcChannelId -->
                          <!-- ECUC_Adc_00392 -->
                           <v:var name="AdcChannelId" type="INTEGER">
                              <a:a name="DESC">
                                  <a:v><![CDATA[EN:<html><p>This parameter defines the assignment of the channel to the physical ADC hardware channel. Note: - Range of the ADC Channels depends on the selected package.
                                  IMPORTANT NOTE: This node must be in sync with 'Adc Physical Channel Name': must be equal with number specified after 'ADCH' in the selected 'Adc Physical Channel Name'. E.g. INT_CH_0_ADCH21 => Channel ID must be 21. The node is required by Autosar standard. 'Adc Physical Channel Name' node is added because refers to names from ReferenceManual and is more user friendly.
                                  In Tresos configurator, after selecting a new Channel Name, the new Channel Id value can be filled in automatically by using 'Calculate Value' button.
                                  </p></html>]]></a:v>
                              </a:a>
                              <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                              <a:a name="SCOPE" value="LOCAL"/>
                              <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                                <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                                <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                              </a:a>
                              <a:a name="LABEL" value="Adc Physical Channel ID"/>
                              <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                              <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                              <a:a name="UUID" value="ECUC:ac534dfe-22b7-4c19-a37c-12e631ff4e9d"/>
                              <a:da name="DEFAULT" type="XPath" expr="num:i(substring-after(string(node:fallback(node:current()/../AdcChannelName, 'SE0_ADCH0')),'ADCH'))"/>
                              <a:da name="INVALID" type="Range">
                                <a:tst expr="&lt;=1024"/>
                                <a:tst expr="&gt;=0"/>
                              </a:da>
                              <a:da name="RANGE" type="XPath">
                                <a:tst expr="(. != num:i(substring-after(string(node:fallback(node:current()/../AdcChannelName,'SE0_ADCH0')), 'ADCH')))"
                            true="'Adc Physical Channel ID' must be equal with number specified after 'ADCH' in the selected 'Adc Physical Channel Name'. E.g. SE12_ADCH12 => Channel ID must be 12.
                                  In Tresos configurator, after selecting a new Channel Name, the new Channel Id value can be filled in automatically by using 'Calculate Value' button."/>
                            </a:da>
                          </v:var>

                          <!-- AdcChannelConvTime -->
                          <!-- ECUC_Adc_00011 -->
                          <v:var name="AdcChannelConvTime" type="INTEGER">
                            <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>Configuration of conversion time, i.e. the time during which the analogue value is converted into digital representation, (in clock cycles) for each channel, if supported by hardware.
                                  ImplementationType: Adc_ConversionTimeType.
                                  This parameter is not used by the current implementation.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Channel Conversion Time"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:25414223-a7a9-4f46-bb8f-7f86fa8b5500"/>
                            <a:da name="DEFAULT" value="0"/>
                            <a:da name="READONLY" value="true"/>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=18446744073709551615"/>
                              <a:tst expr="&gt;=0"/>
                            </a:da>
                          </v:var>

                          <!-- AdcChannelLimitCheck -->
                          <!-- ECUC_Adc_00453, SWS_Adc_00445 -->
                          <v:var name="AdcChannelLimitCheck" type="BOOLEAN">
                            <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>Enables or disables limit checking for an ADC channel.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PreCompile">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Channel Limit Check"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:3c8fd425-d4b7-4550-aea0-9c4ce253f9e4"/>
                            <a:da name="DEFAULT" value="false"/>
                            <a:da name="EDITABLE" type="XPath" expr="(../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true')"/>
                            <a:a name="INVALID" type="XPath">
                               <a:tst expr="(../../../../../../AdcGeneral/AdcEnableLimitCheck = 'false' and .='true')" true ="AdcChannelLimitCheck must be disabled when Adc/AdcGeneral/AdcEnableLimitCheck is false."/>
                               <a:tst expr="(../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true' and .='true' and (not(node:exists(../AdcChannelLowLimit))))" true ="if Adc/AdcGeneral/AdcEnableLimitCheck is enabled, AdcChannelLowLimit must be configured."/>
                               <a:tst expr="(../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true' and .='true' and (not(node:exists(../AdcChannelHighLimit))))" true ="if Adc/AdcGeneral/AdcEnableLimitCheck is enabled, AdcChannelHighLimit must be configured."/>
                               <a:tst expr="(../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true' and .='true' and (not(node:exists(../AdcChannelRangeSelect))))" true ="if Adc/AdcGeneral/AdcEnableLimitCheck is enabled, AdcChannelRangeSelect must be configured."/>
                            </a:a>
                          </v:var>

                          <!-- AdcChannelHighLimit -->
                          <!-- ECUC_Adc_00455 -->
                          <v:var name="AdcChannelHighLimit" type="INTEGER">
                            <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>High limit - used for limit checking.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PreCompile">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Channel High Limit"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:ca1022a6-a5bb-44e1-b817-ece122e5951b"/>
                            <a:da name="DEFAULT" value="255"/> <!--TODO: Use max resolution value from resources -->
                            <a:da name="EDITABLE" type="XPath" expr="node:exists(../AdcChannelLimitCheck) and (../AdcChannelLimitCheck = 'true') and (../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true')"/>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=18446744073709551615"/>
                              <a:tst expr="&gt;=0"/>
                            </a:da>
                            <a:da name="RANGE" type="XPath">
                              <a:tst expr="node:exists(../AdcChannelLowLimit) and (. &lt; ../AdcChannelLowLimit) and node:exists(../AdcChannelLimitCheck) and (../AdcChannelLimitCheck = 'true') and (../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true')"
                              true="Adc Channel High Limit value should be greater or equal than Adc Channel Low Limit value."/>
                              <a:tst expr="(substring-after(string(node:fallback(../../../AdcHwUnitResolution,'')), '_')='12' and .&gt; 4095)"  true="High limit must be lower than the maximum number on 12-bit (See AdcHwUnit/AdcHwUnitResolution)."/>
                              <a:tst expr="(substring-after(string(node:fallback(../../../AdcHwUnitResolution,'')), '_')='10' and .&gt; 1023)"  true="High limit must be lower than the maximum number on 10-bit (See AdcHwUnit/AdcHwUnitResolution)."/>
                              <a:tst expr="(substring-after(string(node:fallback(../../../AdcHwUnitResolution,'')), '_')='8'  and .&gt; 255)"   true="High limit must be lower than the maximum number on 8-bit (See AdcHwUnit/AdcHwUnitResolution)."/>
                            </a:da>
                          </v:var>

                          <!-- AdcChannelLowLimit -->
                          <!-- ECUC_Adc_00454 -->
                          <v:var name="AdcChannelLowLimit" type="INTEGER">
                            <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>Low limit - used for limit checking.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PreCompile">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Channel Low Limit"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:ed93d1f8-7c4d-459e-b781-d7b28fe97cb7"/>
                            <a:da name="DEFAULT" value="0"/>
                            <a:da name="EDITABLE" type="XPath" expr="node:exists(../AdcChannelLimitCheck) and (../AdcChannelLimitCheck = 'true') and (../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true') "/>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=18446744073709551615"/>
                              <a:tst expr="&gt;=0"/>
                            </a:da>
                            <a:da name="RANGE" type="XPath">
                              <a:tst expr="node:exists(../AdcChannelHighLimit) and (. &gt; ../AdcChannelHighLimit) and node:exists(../AdcChannelLimitCheck) and (../AdcChannelLimitCheck = 'true') and (../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true')"
                              true="Adc Channel Low Limit value should be less or equal than Adc Channel High Limit value. This value depends on the Adc Hw Unit resolution."/>
                            </a:da>
                          </v:var>

                          <!-- AdcChannelRangeSelect -->
                          <!-- ECUC_Adc_00456 -->
                          <v:var name="AdcChannelRangeSelect" type="ENUMERATION">
                            <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>In case of active limit checking: defines which conversion values are taken into account related to the boarders defined with AdcChannelLowLimit and AdcChannelHighLimit.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PreCompile">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Channel Range Select"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:4f3db645-2a27-4289-bef1-a3c669f2d86c"/>
                            <a:da name="DEFAULT" value="ADC_RANGE_ALWAYS"/>
                            <a:da name="EDITABLE" type="XPath" expr="node:exists(../AdcChannelLimitCheck) and (../AdcChannelLimitCheck = 'true') and (../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true')"/>
                            <a:da name="RANGE">
                              <a:v>ADC_RANGE_ALWAYS</a:v>
                              <a:v>ADC_RANGE_BETWEEN</a:v>
                              <a:v>ADC_RANGE_NOT_BETWEEN</a:v>
                              <a:v>ADC_RANGE_NOT_OVER_HIGH</a:v>
                              <a:v>ADC_RANGE_NOT_UNDER_LOW</a:v>
                              <a:v>ADC_RANGE_OVER_HIGH</a:v>
                              <a:v>ADC_RANGE_UNDER_LOW</a:v>
                            </a:da>
                          </v:var>

                          <!-- AdcChannelRefVoltsrcHigh -->
                          <!-- ECUC_Adc_00089 -->
                          <v:var name="AdcChannelRefVoltsrcHigh" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Upper reference voltage source for each channel. Enumeration literals are defined vendor specific.
                                This parameter is not used by the current implementation.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc High Reference Voltage"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:e141efcc-a3d5-4127-bf67-52e7ca378d89"/>
                            <a:da name="DEFAULT" value="UPPER_REF_VOLT_0"/>
                            <a:da name="READONLY" value="true"/>
                            <a:da name="RANGE">
                              <a:v>UPPER_REF_VOLT_0</a:v>
                            </a:da>
                          </v:var>

                          <!-- AdcChannelRefVoltsrcLow -->
                          <!-- ECUC_Adc_00023 -->
                          <v:var name="AdcChannelRefVoltsrcLow" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Lower reference voltage source for each channel. Enumeration literals are defined vendor specific.
                                This parameter is not used by the current implementation.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Low Reference Voltage"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:f71ff945-81dc-4e80-a7bd-587776a932b7"/>
                            <a:da name="DEFAULT" value="LOWER_REF_VOLT_0"/>
                            <a:da name="READONLY" value="true"/>
                            <a:da name="RANGE">
                              <a:v>LOWER_REF_VOLT_0</a:v>
                            </a:da>
                          </v:var>

                          <!-- AdcChannelResolution -->
                          <!-- ECUC_Adc_00019 -->
                          <v:var name="AdcChannelResolution" type="INTEGER">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Channel Resolution in bits of converted value. This value is not used. The resolution can be modified at hardware unit level.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Channel Resolution"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:115f2554-ffe3-4171-8abd-d2caa3a498c7"/>
                            <a:da name="DEFAULT" type="XPath" expr="num:i(substring-after(string(node:fallback(../../../AdcHwUnitResolution,'_12')), '_'))"/>
                            <a:da name="EDITABLE" value="true"/>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=63"/>
                              <a:tst expr="&gt;=1"/>
                            </a:da>
                            <a:da name="RANGE" type="XPath">
                              <a:tst expr="(.!=substring-after(string(node:fallback(../../../AdcHwUnitResolution,'')), '_'))" true="Invalid Resolution value! Value must be the same as AdcHwUnit/AdcHwUnitResolution."/>
                            </a:da>
                          </v:var>

                          <!-- AdcChannelSampTime -->
                          <!-- ECUC_Adc_00290 -->
                          <v:var name="AdcChannelSampTime" type="INTEGER">
                          <a:a name="DESC">
                            <a:v><![CDATA[EN:<html><p>Sampling time, i.e. the time during which the value is sampled, (in clock cycles) for each channel. Not used.</p></html>]]></a:v>
                          </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Channel Sampling time"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:5fab3df1-dd6e-4a42-8a60-21d1ee5a530a"/>
                            <a:da name="DEFAULT" value="22"/>
                             <a:da name="READONLY" value="true"/>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&gt;=8"/>
                              <a:tst expr="&lt;=254"/>
                            </a:da>
                          </v:var>
                        </v:ctr>
                      </v:lst>

                      <!-- AdcGroup Big container -->
                      <!-- SWS_Adc_00092 -->
                      <v:lst name="AdcGroup" type="MAP">
                        <a:da name="MIN" value="1"/>

                        <!-- AdcGroup -->
                        <!-- ECUC_Adc_00028, SWS_Adc_00090 -->
                        <!-- /** @implements AdcGroup_Object */ -->
                        <v:ctr name="AdcGroup" type="IDENTIFIABLE">
                          <a:a name="DESC">
                            <a:v><![CDATA[EN:<html><p>This container contains the Group configuration (parameters).</p></html>]]></a:v>
                          </a:a>
                          <a:a name="UUID" value="ECUC:1a9750b2-e985-4bfe-afeb-69760dbfdddd"/>
                          <a:a name="REQUIRES-INDEX" value="true"/>
                          <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS"  type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                              <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:da name="INVALID" type="XPath">
                            <a:tst expr="text:uniq(../../../*/AdcGroup/*/@name, @name)" false="Duplicate AdcGroupNames, Group Symbolic names must be unique across HWUnits."/>
                          </a:da>

                          <!-- AdcGroupAccessMode -->
                          <!-- ECUC_Adc_00317 -->
                          <v:var name="AdcGroupAccessMode" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Type of access mode to group conversion results.
                                ImplementationType: Adc_GroupAccessModeType.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Access Mode"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:e0b07dba-d097-4aa4-9b2b-c87b5e68fbff"/>
                            <a:da name="DEFAULT" value="ADC_ACCESS_MODE_SINGLE"/>
                            <a:da name="RANGE">
                              <a:v>ADC_ACCESS_MODE_SINGLE</a:v>
                              <a:v>ADC_ACCESS_MODE_STREAMING</a:v>
                            </a:da>
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="((../AdcWithoutInterrupts='true') and (.='ADC_ACCESS_MODE_STREAMING') and (../AdcStreamingBufferMode='ADC_STREAM_BUFFER_LINEAR'))"
                              true="Streaming access mode with ADC_STREAM_BUFFER_LINEAR is not supported without interrupts."/>
                              <a:tst expr="((../AdcWithoutInterrupts='true') and (.='ADC_ACCESS_MODE_STREAMING') and (../../../AdcTransferType ='ADC_INTERRUPT'))"
                              true="Streaming access mode without interrupts is only supported with DMA."/>
                              <a:tst expr="((../AdcGroupAccessMode='ADC_ACCESS_MODE_STREAMING') and (../AdcGroupTriggSrc='ADC_TRIGG_SRC_SW') and (../AdcGroupConversionMode='ADC_CONV_MODE_ONESHOT'))"
                              true="Group cannot be configured with streaming access mode when it is Software triggered in one shot mode."/>
                              <a:tst expr="((node:fallback(../../../../../../AutosarExt/AdcOptimizeOneShotHwTriggerConversions,'false') = 'true') and (.='ADC_ACCESS_MODE_STREAMING'))"
                              true="Streaming access mode cannot be configured if AdcOptimizeOneShotHwTriggerConversions is enabled."/>
                              <a:tst expr="((.='ADC_ACCESS_MODE_STREAMING') and (../AdcWithoutInterrupts='true') and (count(../AdcGroupDefinition/*) = 1))"
                              true="DMA streaming access mode cannot be configured for groups which have selected Without Interrupts, ACCESS_MODE_STREAMING and a single channel. However the feature can be left disabled at group level."/>
                            </a:da>
                          </v:var>

                          <!-- AdcGroupConversionMode -->
                          <!-- ECUC_Adc_00397 -->
                          <!-- /** @implements AdcGroupConversionMode_Object */ -->
                          <v:var name="AdcGroupConversionMode" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Type of conversion mode supported by the driver.
                                ImplementationType: Adc_GroupConvModeType.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Conversion Mode"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:cecb9b6c-d664-43fa-80b7-5122d3a178cc"/>
                            <a:da name="DEFAULT" value="ADC_CONV_MODE_ONESHOT"/>
                            <a:da name="RANGE">
                              <a:v>ADC_CONV_MODE_ONESHOT</a:v>
                              <a:v>ADC_CONV_MODE_CONTINUOUS</a:v>
                            </a:da>
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="((../AdcGroupTriggSrc='ADC_TRIGG_SRC_HW') and (../AdcGroupConversionMode='ADC_CONV_MODE_CONTINUOUS'))"
                              true="Group cannot be configured for continuous conversion mode when it is hardware triggered."/>
                            </a:da>
                          </v:var>

                          <!-- AdcGroupConversionType -->
                          <v:var name="AdcGroupConversionType" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Normal or Injected conversion type.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Conversion Type"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:9c7e30ee-cca4-4874-90b2-0492458cb413"/>
                            <a:da name="DEFAULT" value="ADC_CONV_TYPE_NORMAL"/>
                            <a:da name="RANGE">
                              <a:v>ADC_CONV_TYPE_NORMAL</a:v>
                            </a:da>
                          </v:var>

                          <!-- AdcGroupId -->
                          <!-- ECUC_Adc_00398, SWS_Adc_00099 -->
                          <v:var name="AdcGroupId" type="INTEGER">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Numeric ID of the group. This parameter is the symbolic name to be used on the API. This symbolic name allows accessing Channel Group data. This value will be assigned to the symbolic name derived of the AdcGroup container shortName.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Id"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="true"/>
                            <a:a name="UUID" value="ECUC:84e98da0-f4af-4c03-a4a4-a9b7efd5b563"/>
                            <a:da name="DEFAULT" type="XPath" expr="node:fallback(node:current()/../@index,'0')"/>
                            <a:da name="RANGE" type="XPath">
                              <a:tst expr="(node:fallback(.,0) &gt;= 0) and (node:fallback(.,0) &lt; num:i(count(node:fallback(../../../../*/AdcGroup/*,1))))"
                              false="Value out of range: must be in range 0 to N-1 (N is number of configured groups). Use the Calc button to calculate correct default value."/>
                              <a:tst expr="text:uniq(node:fallback(../../../../*/AdcGroup/*/AdcGroupId,text:split('0') ),node:fallback(.,1))"
                              false="Duplicate AdcGroupId, GroupIds must be unique across HWUnits."/>

                            </a:da>
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="../../../../../../AdcGeneral/AdcPriorityImplementation = 'ADC_PRIORITY_HW_SW' and not(node:exists(../AdcGroupPriority))"
                              true="If Adc/AdcGeneral/AdcPriorityImplementation is set as ADC_PRIORITY_HW_SW, AdcGroupPriority must be configured for this Group."/>
                            </a:da>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=1023"/>
                              <a:tst expr="&gt;=0"/>
                            </a:da>
                          </v:var>

                          <!-- AdcGroupPriority -->
                          <!-- ECUC_Adc_00287, SWS_Adc_00288 -->
                          <!-- /** @implements AdcGroupPriority_Object*/ -->
                          <v:var name="AdcGroupPriority" type="INTEGER">
                          <a:a name="DESC">
                            <a:v><![CDATA[EN:<html><p>Priority level of the AdcGroup. This item is ignored if Adc/AdcGeneral/AdcPriorityImplementation is defined to ADC_PRIORITY_NONE.</p></html>]]></a:v>
                          </a:a>

                          <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                          <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                          <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Group Priority"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:1f39cff8-368c-4814-bbce-34a529f2e9f8"/>
                            <a:da name="DEFAULT" value="0"/>
                            <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="../../../../../../AdcGeneral/AdcPriorityImplementation != 'ADC_PRIORITY_NONE'"/>
                            </a:a>
                            <!-- SWS_Adc_00312, SWS_Adc_00289 -->
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=255"/>
                              <a:tst expr="&gt;=0"/>
                            </a:da>
                            <a:da name="RANGE" type="XPath">
                              <a:tst expr="(node:fallback(../AdcGroupConversionType, 'ADC_CONV_TYPE_NORMAL') = 'ADC_CONV_TYPE_NORMAL') and
                                           (node:fallback(../AdcGroupTriggSrc, 'ADC_TRIGG_SRC_SW') = 'ADC_TRIGG_SRC_SW') and
                                           node:exists(node:fallback(../../../AdcGroup/*[AdcGroupTriggSrc='ADC_TRIGG_SRC_HW']/AdcGroupPriority, 0)) and
                                           (node:fallback(.,0) &gt; (num:min(node:fallback(../../../AdcGroup/*[AdcGroupTriggSrc='ADC_TRIGG_SRC_HW']/AdcGroupPriority, 0))))"
                                     true="Normal SW Triggered Groups cannot have priority more than HW Triggered Groups"/>
                            </a:da>
                          </v:var>

                          <!-- AdcGroupReplacement -->
                          <!-- ECUC_Adc_00435, SWS_Adc_00430 -->
                          <v:var name="AdcGroupReplacement" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Replacement mechanism, which is used on ADC group level, if a group conversion is interrupted by a group which has a higher priority.
                                ImplementationType: Adc_GroupReplacementType</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Group Replacement"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:040e7ff3-d837-4037-9a61-c284bbad9a32"/>
                            <a:da name="DEFAULT" value="ADC_GROUP_REPL_ABORT_RESTART"/>
                            <a:da name="READONLY" value="true"/>
                            <a:da name="RANGE">
                              <a:v>ADC_GROUP_REPL_ABORT_RESTART</a:v>
                              <a:v>ADC_GROUP_REPL_SUSPEND_RESUME</a:v>
                            </a:da>
                          </v:var>

                          <!-- AdcGroupTriggSrc -->
                          <!-- ECUC_Adc_00399, SWS_Adc_00279, PR-MCAL-3204.adc -->
                          <v:var name="AdcGroupTriggSrc" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Type of source event that starts a group conversion. It' s possible select Hw or Sw trigger.
                              In case of Hw trigger the trigger source can be from the PDB. Only trigger sources from PDB is used by the current implementation. The trigger source connected to PDB can be configured from Mcl module.
                              </p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Trigger Source"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:d6ca518c-2748-42bb-b382-6b052094b115"/>
                            <a:da name="DEFAULT" value="ADC_TRIGG_SRC_SW"/>
                            <a:a name="INVALID" type="XPath">
                              <a:tst expr="((../../../../../../AdcGeneral/AdcHwTriggerApi = 'false') and (. = 'ADC_TRIGG_SRC_HW'))"
                                     true="Adc Hw Trigger API in AdcGeneral container is switched off! Cannot configure any groups in HW triggered mode!"/>
                              <a:tst expr="((../../../../../../AdcGeneral/AdcEnableStartStopGroupApi = 'false') and (. = 'ADC_TRIGG_SRC_SW'))"
                                     true="Adc_StartStopGroup API in AdcGeneral container is switched off! Cannot configure any groups in SW triggered mode!"/>
                              <a:tst expr="((node:fallback(../../../../../../AutosarExt/AdcOptimizeOneShotHwTriggerConversions,'false') = 'true') and (.='ADC_TRIGG_SRC_SW'))"
                                     true="Software triggered groups cannot be configured if Adc/AutosarExt/AdcOptimizeOneShotHwTriggerConversions is enabled."/>
                            </a:a>
                            <a:da name="RANGE">
                              <a:v>ADC_TRIGG_SRC_HW</a:v>
                              <a:v>ADC_TRIGG_SRC_SW</a:v>
                            </a:da>
                          </v:var>

                          <!-- AdcGroupHwTriggerSource -->
                          <v:ref name="AdcGroupHwTriggerSource" type="REFERENCE">
                            <a:a name="DESC">
                             <a:v><![CDATA[EN:<html><p>
                              Select the HW trigger signal for triggering the conversion group. Configurable only when HW trigger source is selected for the group.</p></html>]]>
                             </a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Hw Trigger Source"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="UUID" value="ECUC:b3da110e-30a7-4ec5-a782-9f8e3853e9d6"/>
                            <a:da name="REF" value="ASPathDataOfSchema:/TS_T40D2M10I1R0/Adc/AdcConfigSet/AdcHwTrigger"/>
                            <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="../AdcGroupTriggSrc = 'ADC_TRIGG_SRC_HW'"/>
                            </a:a>
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="(../AdcGroupTriggSrc = 'ADC_TRIGG_SRC_HW') and (.='')" true="Select an Adc Hw Trigger for the configured group."/>
                            </a:da>
                          </v:ref>

                          <!-- AdcHwTrigSignal -->
                          <!-- ECUC_Adc_00400 -->
                          <v:var name="AdcHwTrigSignal" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Configures the edge of the hardware trigger signal, i.e. to start the conversion. This parameter is not used by the current implementation.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Group Trigger Signal"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:52c43528-a85b-4dcc-b5b5-7ab3e18e67ac"/>
                            <a:da name="DEFAULT" value="ADC_HW_TRIG_RISING_EDGE"/>
                            <a:da name="READONLY" value="true"/>
                            <a:da name="RANGE">
                              <a:v>ADC_HW_TRIG_BOTH_EDGES</a:v>
                              <a:v>ADC_HW_TRIG_RISING_EDGE</a:v>
                              <a:v>ADC_HW_TRIG_FALLING_EDGE</a:v>
                            </a:da>
                          </v:var>

                          <!-- AdcHwTrigTimer -->
                          <!-- ECUC_Adc_00401 -->
                          <v:var name="AdcHwTrigTimer" type="INTEGER">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Reload value of the ADC module embedded timer. This parameter is not used by the current implementation.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Group Trigger Timer"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:5fe66517-3dfa-49cf-b1cd-a111b7baaefe"/>
                            <a:da name="DEFAULT" value="0"/>
                            <a:da name="READONLY" value="true"/>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=18446744073709551615"/>
                              <a:tst expr="&gt;=0"/>
                            </a:da>
                          </v:var>

                          <!-- AdcNotification -->
                          <!-- ECUC_Adc_00402, SWS_Adc_00084, SWS_Adc_00085, SWS_Adc_00104 -->
                          <!-- /** @implements AdcNotification_Object */ -->
                          <v:var name="AdcNotification" type="FUNCTION-NAME">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Callback function for each group. This function pointer is called whenever the conversion of this group is completed.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="OPTIONAL" value="true"/>
                            <a:a name="LABEL" value="Adc Group Notification"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:aa328ce2-6361-49fa-8ba2-ca8904101cfd"/>
                            <a:da name="DEFAULT" value="NULL_PTR"/>
                            <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="../../../../../../AdcGeneral/AdcGrpNotifCapability = 'true'"/>
                            </a:a>
                          </v:var>

                          <!-- AdcExtraNotification -->
                          <!-- SWS_Adc_00084, SWS_Adc_00085 -->
                          <!-- /** @implements AdcExtraNotification_Object */ -->
                          <v:var name="AdcExtraNotification" type="FUNCTION-NAME">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Extra callback function for each group. This function pointer will be called at the beginning of the interrupt routine, before updating any HW registers or Group status.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Extra Notification"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:45315cb5-e0ed-4c8c-b013-4f21012be279"/>
                            <a:da name="DEFAULT" value="NULL_PTR"/>
                            <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="(node:fallback(../../../../../../AutosarExt/AdcEnableInitialNotification,'false') = 'true')"/>
                            </a:a>
                          </v:var>

                          <!-- AdcStreamingBufferMode -->
                          <!-- ECUC_Adc_00316 -->
                          <v:var name="AdcStreamingBufferMode" type="ENUMERATION">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Select the streaming buffer as linear buffer (i.e. the ADC Driver stops the conversion as soon as the stream buffer is full) or as circular buffer (wraps around if the end of the stream buffer is reached).</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Streaming Buffer Mode"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:572a24d6-27ac-4f8c-85b9-1cefae44cb8c"/>
                            <a:da name="DEFAULT" value="ADC_STREAM_BUFFER_LINEAR"/>
                            <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="../AdcGroupAccessMode = 'ADC_ACCESS_MODE_STREAMING'"/>
                            </a:a>
                            <a:a name="INVALID" type="XPath">
                              <a:tst expr="(../AdcGroupAccessMode = 'ADC_ACCESS_MODE_SINGLE' and .='ADC_STREAM_BUFFER_CIRCULAR')" true ="When AdcGroupAccessMode is Single Access, the AdcStreamingBufferMode must be Linear."/>
                            </a:a>
                            <a:da name="RANGE">
                              <a:v>ADC_STREAM_BUFFER_LINEAR</a:v>
                              <a:v>ADC_STREAM_BUFFER_CIRCULAR</a:v>
                            </a:da>
                          </v:var>

                          <!-- AdcEnableOptimizeDmaStreamingGroups_Object -->
                          <v:var name="AdcEnableOptimizeDmaStreamingGroups" type="BOOLEAN">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>
                                            Enable/Disable The Adc driver enable Optimize DMA streaming groups for reducing the number of interrupts required for processing the conversions of Adc Groups that consist of one or more channels (depending on HW capabilities) and which are configured as ADC_ACCESS_MODE_STREAMING.
                                            When this feature is enabled, only one interrupt will be raised after the completion of all stream conversions (as configured by AdcStreamingNumSamples parameter). An additional interrupt to be raised after half of the stream is converted shall also be configurable.
                                            This feature is enabled if Adc Global Enable DMA Transfer from General/AutosarExt is also enabled.</p></html>]]>
                              </a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Enable Optimize DMA Streaming Groups"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:3ca7b97c-36e2-4d2a-a199-37c07804cb65"/>
                            <a:da name="DEFAULT" value="false"/>
                            <a:da name="READONLY" value="false"/>
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="(.='true') and (node:fallback(../AdcGroupAccessMode, 'ADC_ACCESS_MODE_SINGLE') = 'ADC_ACCESS_MODE_SINGLE')" true="Only groups configured with ADC_ACCESS_MODE_STREAMING Access Mode can have enabled the Double Buffering feature!"/>
                              <a:tst expr="((.='true') and (node:fallback(../../../AdcTransferType, 'ADC_INTERRUPT') = 'ADC_INTERRUPT'))"
                                     true="AdcEnableOptimizeDmaStreamingGroups can be enabled only if ADC_DMA transfer is configured."/>
                              <a:tst expr="((.='true') and (node:fallback(../../../../../../AutosarExt/AdcOptimizeDmaStreamingGroups,'false') = 'false'))"
                                     true="AdcEnableOptimizeDmaStreamingGroups can be enabled only if AdcOptimizeDmaStreamingGroups is enabled."/>
                              <a:tst expr="((.='true') and (node:fallback(../AdcWithoutInterrupts,'false') = 'true'))"
                                     true="AdcEnableOptimizeDmaStreamingGroups cannot be enabled simultaneously with without interrupts."/>
                            </a:da>
                            <a:da name="EDITABLE" type="XPath" expr="node:fallback(../../../../../../AutosarExt/AdcOptimizeDmaStreamingGroups,'false') = 'true'"/>
                          </v:var>

                          <!-- AdcEnableHalfInterrupt -->
                          <v:var name="AdcEnableHalfInterrupt" type="BOOLEAN">
                            <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>
                                          Enable/ Disable the interrupt when half sample complete for optimize DMA streaming groups feature. AutosarExt/AdcOptimizeDmaStreamingGroups must be enable for configure this feature. </p></html>]]>
                                </a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                type="IMPLEMENTATIONCONFIGCLASS">
                                <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                                <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Enable Half Interrupt"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:c08c3abb-86b5-4f8f-be15-672bb9fdf90c"/>
                            <a:da name="DEFAULT" value="false"/>
                            <a:da name="EDITABLE" type="XPath" expr="../AdcEnableOptimizeDmaStreamingGroups = 'true'"/>
                            <a:da name="INVALID" type="XPath">
                                <a:tst expr="(.='true') and (node:fallback(../AdcEnableOptimizeDmaStreamingGroups, 'false') = 'false')" true="Optimize DMA streaming groups must be enabled for configuring this feature."/>
                            </a:da>
                          </v:var>

                          <!-- AdcStreamingNumSamples -->
                          <!-- ECUC_Adc_00292 -->
                          <v:var name="AdcStreamingNumSamples" type="INTEGER">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Number of ADC values to be acquired per channel in streaming access mode.
                                Note: in single access mode this parameter assumes value 1, since only one sample per channel is processed.
                                ImplementationType: Adc_StreamNumSampleType.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Streaming Number Samples"/>
                            <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:1862f873-395e-407f-82e6-1cb911c5faa4"/>
                            <a:da name="DEFAULT" value="1"/>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=255"/>
                              <a:tst expr="&gt;=1"/>
                            </a:da>
                            <a:da name="RANGE" type="XPath">
                              <a:tst expr="../AdcGroupAccessMode = 'ADC_ACCESS_MODE_SINGLE' and ../AdcStreamingNumSamples != 1" true="AdcStreamingNumSamples must be 1 for ADC_ACCESS_MODE_SINGLE."/>
                            </a:da>
                          </v:var>

                          <!-- AdcStreamResultGroup -->
                          <v:var name="AdcStreamResultGroup" type="BOOLEAN">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>
                                 Arrange the ADC results as multiple sets of group result buffer.
                                 E.g: for a group with channels {CH1 CH5 CH7} the resulting stream buffer shall be:
                                 { CH1, CH5, CH7, CH1, CH5, CH7, CH1, CH5, CH7}
                                 instead of
                                 { CH1, CH1, CH1, CH5, CH5, CH5, CH7, CH7, CH7} like supported by AUTOSAR standard.
                                 This Parameter can be configured only for groups configured with ADC_ACCESS_MODE_STREAMING Access Mode
                              </p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Streaming Results Reorder"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:cbf96f20-c6c0-4f30-9040-055111ce2260"/>
                            <a:da name="DEFAULT" value="false"/>
                            <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="../AdcGroupAccessMode = 'ADC_ACCESS_MODE_STREAMING' and ../../../../../../AutosarExt/AdcEnableGroupStreamingResultReorder = 'true'"/>
                            </a:a>
                          </v:var>

                          <!-- AdcEnableChDisableChGroup -->
                          <v:var name="AdcEnableChDisableChGroup" type="BOOLEAN">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>
                                If this parameter is enabled, it allows the feature of enabling or disabling a particular channel in the group.<br>
                                Max.no of Groups with this feature enabled, should be configured are 254 if the configuration parameter AdcEnableChDisableChApi is enabled in Autosar Extension container
                                <h1>Note</h1>This is an Implementation Specific Parameter.</p></html>]]>
                              </a:v>
                            </a:a>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Enable/Disable channels"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:cfaf89f9-bfc3-419b-ab5f-37e91c0184ad"/>
                            <a:da name="DEFAULT" value="false"/>
                            <a:da name="EDITABLE" value="false"/>
                          </v:var>

                          <!-- CPR_RTD_00048.adc, CPR_RTD_00488.adc -->
                          <!-- AdcWithoutInterrupts -->
                          <!-- /** @implements AdcWithoutInterrupts_Object */ -->
                          <v:var name="AdcWithoutInterrupts" type="BOOLEAN">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>
                                  Enable/ Disable the occurring of ADC Interrupts and Reading of the group conversion results periodically without interrupts (ADC interrupt or DMA notification).
                                  <ul>
                                      <li>1. When this parameter is enabled, interrupts are disabled. The conversion will run without software intervention (no interrupt generated anymore) and the application can read the results by calling Adc_ReadGroup().</li>
                                      <li>2. If Transfer Type is ADC_INTERRUPT (or ADC_DMA) and this one is enabled, the result buffer registered via Adc_SetupResultBuffer will no longer be used populated with results. Adc_ReadGroup will read the results directly from ADC HW registers (or Internal Dma Buffer).</li>
                                  </ul>
                                  When this parameter is Disabled, normal functionality shall be executed.
                                  Note: This is an Implementation Specific Parameter.</p></html>]]>
                              </a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Without Interrupts"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:2dbb0804-e88c-4f64-8bf9-b70ce22e5b71"/>
                            <a:da name="DEFAULT" value="false"/>
                            <a:da name="INVALID" type="XPath">
                                <a:tst expr="(.='true') and (count(../AdcGroupDefinition/*) &gt; ecu:get(&apos;Adc.AdcConfigSet.AdcScRegister&apos;))"
                                  true="Without interrupt supports only the groups that have number of channels less than maximum SC registers."/>
                                <a:tst expr="(.='true') and (../AdcGroupConversionMode = 'ADC_CONV_MODE_CONTINUOUS') and (node:fallback(../../../../../../AutosarExt/AdcContinuousWithoutInterrupt,'false') = 'false')"
                                  true="AdcContinuousWithoutInterrupt must be enabled to allow configure without interrupt in Conversion Mode Continuous."/>
                            </a:da>
                          </v:var>

                          <v:var name="AdcWithoutDma" type="BOOLEAN">
                          <a:a name="DESC">
                            <a:v><![CDATA[EN:<html><p>
                                          When true, disables completely DMA configuration done by ADC driver for the group, to not affect other groups for which the ADC driver has already configured the DMA. It is intended to be used when DMA Transfer Mode is selected for the ADC unit, for groups required to work without interrupt and without DMA.
                                        </p></html>]]>
                            </a:v>
                          </a:a>
                          <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                          <a:a name="SCOPE" value="LOCAL"/>
                          <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                            <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                          </a:a>
                          <a:da name="INVALID" type="XPath">
                              <a:tst expr="(. = 'true') and (../../../AdcTransferType = 'ADC_INTERRUPT')" true="This feature can be used only when ADC Unit Transfer Type = ADC_DMA"/>
                              <a:tst expr="(. = 'true') and (../AdcGroupTriggSrc = 'ADC_TRIGG_SRC_HW')" true="This feature can be used only when Group Trigger Source = SW"/>
                              <a:tst expr="(. = 'true') and (../AdcWithoutInterrupts = 'false')" true="This feature can be used only together with Group Without Interrupts enabled"/>
                              <a:tst expr="(. = 'true') and (../AdcGroupAccessMode = 'ADC_ACCESS_MODE_STREAMING')" true="This feature can be used only with Oneshot, single access mode"/>
                          </a:da>
                          <a:da name="EDITABLE" type="XPath" expr="../../../AdcTransferType = 'ADC_DMA'"/>
                          <a:a name="LABEL" value="Adc Group Without Dma"/>
                          <a:a name="ORIGIN" value="NXP"/>
                          <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                          <a:a name="UUID" value="ECUC:47b4113a-9144-11eb-a8b3-0242ac130003"/>
                          <a:da name="DEFAULT" value="false"/>
                          </v:var>

                          <!-- CPR_RTD_00489.adc -->
                          <!-- /** @implements AdcExtDMAChanEnable_Object */ -->
                          <v:var name="AdcExtDMAChanEnable" type="BOOLEAN">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>
                                            Enable/ Disable DMA functionality of individual group.
                                            In this mode the adc will only enable the dma request for the last channel in the group and, so that the dma transfer will start after the group conversion has finished.
                                            In this mode it is the users responsibility to configure the dma to transfer the data according to his needs
                                          </p></html>]]>
                              </a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                 type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                              <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:da name="INVALID" type="XPath">
                                <a:tst expr="(. = 'true') and (../../../AdcTransferType = 'ADC_INTERRUPT')" true="This feature is enabled when AdcTransferType = ADC_DMA"/>
                            </a:da>
                            <a:a name="LABEL" value="Adc External Dma Chan Config"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:2dbb0804-e88c-4f64-8bf9-b70ce22e5b50"/>
                            <a:da name="DEFAULT" value="false"/>
                          </v:var>

                          <!-- AdcGroupInBacktoBackMode -->
                          <v:var name="AdcGroupInBacktoBackMode" type="BOOLEAN">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>
                                    Enable/ Disable the channel conversions occuring in Back to Back mode.
                                    The PDB hardware unit is used to initiate individual channel conversions that are required for each group conversion, with one PDB pretrigger controlling the timing of each ADC channel conversion.
                                    When AdcGroupInBacktoBackMode is enabled, the PDB pretriggers will be confiugred to work in back to back mode: PDB_CH1n_C1[BB] bits are set for all the group channels, except the first one.
                                    The first channel conversion complete will trigger the PDB channel's second pretrigger, and so on until the last channel of the group. This ensures that the channel conversions occur in sequence, as quickly as possible and without causing internal PDB errors.
                                    The Adc driver can convert only up to N channels at once; for groups larger than N channels, Adc driver will split the group in sub-groups of N and convert them with sub-group conversions. Interrupt processing is needed between the sub-groups for register re-configuration. The 16 channels are converted using 2 PDB channels (each controlling 8 pretriggers), but the 2 channels do not work in back to back mode together, so a delay is needed for the 2nd PDB channel, otherwise PDB errors will occur. Adc driver will configure this delay value when Back to back mode is used, with the value defined by the user in AdcDelayNextPdb parameter. The sequences of 8 channels associated to a PDB channel will happen in back to back mode.
                                    If AdcGroupInBacktoBackMode is not enabled for a group, all pretriggers of the PDB channels will be triggered at the same time causing internal PDB errors, unless the coherence of channel conversions is ensured via the delay configured for each pretrigger. This is why at least one of AdcGroupInBacktoBackMode and AdcGroupUsesChannelDelays options needs to be configured for an Adc Group.
                                    If both parameters are configured for the Adc Group, the user can configure a delay only for the first channel conversion, and the rest will be converted in back to back mode.
                                    If AdcGroupUsesChannelDelays is not configured for the group, the first channel will have an associated delay of 0, and will convert immediately after the external trigger is received.</p></html>]]>
                              </a:v>
                            </a:a>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                type="IMPLEMENTATIONCONFIGCLASS">
                                <icc:v class="PostBuild">VariantPostBuild</icc:v>
                                <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group In Back to Back Mode"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:3ca7b97c-36e2-4d2a-a199-37c07804cb6c"/>
                            <a:da name="DEFAULT" value="true"/>
                            <a:da name="READONLY" value="false"/>
                            <a:da name="INVALID" type="XPath">
                            <a:tst expr="(node:fallback(.,'false') = 'false') and (node:fallback(../AdcGroupUsesChannelDelays,'false') = 'false')"
                              true="At least one of AdcGroupUsesChannelDelays and AdcGroupInBacktoBackMode has to be enabled for an Adc group."/>
                            <a:tst expr="(node:fallback(.,'false') = 'true') and (node:fallback(../AdcGroupUsesChannelDelays,'false') = 'false')
                            and (../AdcGroupTriggSrc='ADC_TRIGG_SRC_SW') and (node:fallback(../AdcOptimizeDmaStreamingGroups,'false') = 'true')"
                              true="Group double buffering for software trigger cannot be configured in only back-to-back mode"/>
                            </a:da>
                          </v:var>

                          <!-- AdcGroupUsesChannelDelays -->
                          <v:var name="AdcGroupUsesChannelDelays" type="BOOLEAN">
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="(node:fallback(.,'false') = 'false') and (node:fallback(../AdcGroupInBacktoBackMode,'false') = 'false')"
                              true="At least one of AdcGroupUsesChannelDelays and AdcGroupInBacktoBackMode has to be enabled for an Adc group."/>
                            </a:da>
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Enable/ Disable the usage of channel delays in PDB pretriggers.
                                    The PDB hardware unit is used to initiate individual channel conversions that are required for each group conversion, with one PDB pretrigger controlling the timing of each ADC channel conversion.
                                    When AdcGroupUsesChannelDelays is enabled, the PDB pretriggers will have individual delays configured. PDB_CH1nDLYx will be set with the values configured in AdcChannelDelay list for each channel. The values must not be equal or too close, otherwise PDB internal errors will occur.
                                    The Adc driver can convert only up to N channels at once, N = 16/24/32 channels - depending on derivative (refer to Reference Manual for details). For groups larger than N channels, Adc driver will split the group in sub-groups of N and convert them with sub-group conversions. Interrupt processing is needed between the sub-groups for register re-configuration. The timing of the channel conversions will be accurate only for the first 16 channels; for the next ones, the on top of the configured delay, the delay of previous conversions and interrupt processing will be implicitly added. For this reason, it's safe to confiugre a delay of 0 for the Nth + 1 channel. But the delay values for each group of 16 need to be increasing, so that the channel conversions occur in the order they were defined in the group.
                                    If AdcGroupInBacktoBackMode is also configured for the Adc Group, the user can configure a delay only for the first channel conversion, and the rest will be converted in back to back mode (see description of AdcGroupInBacktoBackMode). The delay value defined by the user in AdcDelayNextPdb parameter will be used for 2nd PDB channel to avoid PDB internal errors.</p></html>]]>
                              </a:v>
                            </a:a>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                type="IMPLEMENTATIONCONFIGCLASS">
                                <icc:v class="PostBuild">VariantPostBuild</icc:v>
                                <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Uses Channel Delays"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:3ca7b97c-36e2-4d2a-a199-37c07804cb6b"/>
                            <a:da name="DEFAULT" value="false"/>
                            <a:da name="READONLY" value="false"/>
                          </v:var>

                          <!-- AdcDelayNextPDB -->
                          <v:var name="AdcDelayNextPdb" type="INTEGER">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>The PDB unit can have one or more PDB Channels of 8 pretriggers each that will be used together for setting up conversions of large groups. The PDB Channels will be started together when the PDB unit is triggered, thus risking to request conversions at the same time and causing internal errors. For this reason, the value of AdcDelayNextPdb is needed to be added as delay between PDB channels when Back to Back mode is used. The AdcDelayNextPdb value should be greater than the timing to convert 8 channels. The maximum total conversion time is determined by the clock source chosen and the divide ratio selected. The clock source is selectable by CFG1[ADICLK], and the divide ratio is specified by CFG1[ADIV]. To calculate total conversion time for one channel the following formula is applied: ADC TOTAL CONVERSION TIME = Sample Phase Time (set by SMPLTS+1) + Hold Phase (1 ADC Cycle) + Compare Phase Time (8-bit Mode=20 ADC Cycles, 10-bit Mode=24 ADC Cycles, 12-bit Mode=28 ADC Cycles) + Single or First continuous time adder (5 ADC cycles + 5 bus clock cycles).</p></html>]]></a:v>
                            </a:a>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                type="IMPLEMENTATIONCONFIGCLASS">
                                <icc:v class="PostBuild">VariantPostBuild</icc:v>
                                <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Delay Next PDB"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:9a91442b-1277-4d7d-8059-624a47f18644c"/>
                            <a:da name="DEFAULT" value="0"/>
                            <a:da name="EDITABLE" type="XPath" expr="(num:i(count(../AdcGroupDefinition/*)) &gt; 8)"/>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=65535"/>
                              <a:tst expr="&gt;=0"/>
                            </a:da>
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="(../../../PdbHwUnit/PdbInterChnBackToBackEnable = 'false') and (num:i(count(../AdcGroupDefinition/*)) > 8) and (node:fallback(../AdcGroupInBacktoBackMode,'false') = 'true') and (. = 0)"
                                  true="If PdbInterChnBackToBackEnable = false, AdcDelayNextPdb shall be more than 0 when AdcGroupInBacktoBackMode is used with number of group channels are more than 8."/>
                            </a:da>
                          </v:var>

                          <!-- AdcPdbPeriodContinuousMode -->
                          <v:var name="AdcPdbPeriodContinuousMode" type="INTEGER">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>The period of PBD module in continuous mode. This is specific and only used for continuous group without interrupt. The PDB period should be big enough to ensure all of the channels complete the convertion before PDB restarts</p></html>]]></a:v>
                            </a:a>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                type="IMPLEMENTATIONCONFIGCLASS">
                                <icc:v class="PostBuild">VariantPostBuild</icc:v>
                                <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Pdb Period For Continuous Mode"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:9a91442b-1277-477d-8059-624a47f18644c"/>
                            <a:da name="DEFAULT" value="1000"/>
                            <a:da name="EDITABLE" type="XPath" expr="((../AdcWithoutInterrupts = 'true') or (../AdcEnableOptimizeDmaStreamingGroups = 'true')) and (../AdcGroupConversionMode='ADC_CONV_MODE_CONTINUOUS')"/>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=65535"/>
                              <a:tst expr="&gt;=0"/>
                            </a:da>
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="(. = 0) and (node:fallback(../AdcGroupInBacktoBackMode,'false') = 'true') and (node:fallback(../AdcWithoutInterrupts,'false') = 'true')
                              and (node:fallback(../AdcGroupUsesChannelDelays,'false') = 'false') and (../AdcGroupConversionMode='ADC_CONV_MODE_CONTINUOUS')"
                                  true="AdcPdbPeriodContinuousMode shall be more than 0 when only AdcGroupInBacktoBackMode and AdcWithoutInterrupts are used."/>
                            </a:da>
                          </v:var>

                          <!-- AdcChannelDelay -->
                          <v:lst name="AdcChannelDelay">
                            <a:da name="MIN" value="0"/>
                            <a:a name="EDITABLE" type="XPath">
                                <a:tst expr="node:fallback(../AdcGroupUsesChannelDelays,'false') = 'true'"/>
                            </a:a>
                            <a:da name="INVALID" type="XPath">
                              <a:tst expr="(node:fallback(../AdcGroupUsesChannelDelays,'false') = 'true') and (node:fallback(../AdcGroupInBacktoBackMode,'false') = 'true') and (num:i(count(node:current()/*)) != 1)"
                              true="Delay values must be defined just for the first channels of group."/>
                              <a:tst expr="(node:fallback(../AdcGroupUsesChannelDelays,'false') = 'true') and (node:fallback(../AdcGroupInBacktoBackMode,'false') = 'false') and (num:i(count(node:current()/*)) != num:i(count(../AdcGroupDefinition/*)))"
                              true="Every channel assigned to this group must have an associated delay value."/>
                            </a:da>

                            <!-- AdcChannelDelay -->
                            <v:var name="AdcChannelDelay" type="INTEGER">
                              <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>Delay of the associated PDB pretrigger for this channel. If Back to Back mode is not used for this group, the user must ensure the difference between the delays of different channels are big enough to accomodate the Adc conversions without PDB channel sequence errors. If Back to Back mode is used for this group, only the delay for the first channel will be considered - the rest of the channels will be converted in back to back mode. The delay value have to be a increasing numbers for each sequence of 16/24/32 channels - depending on derivative (refer to Reference Manual for details).</p></html>]]></a:v>
                              </a:a>
                              <a:a name="REQUIRES-INDEX" value="true"/>
                              <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                  type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                              </a:a>
                              <a:a name="LABEL" value="Adc Channel Delay"/>
                              <a:a name="ORIGIN" value="NXP"/>
                              <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                              <a:a name="UUID" value="ECUC:9a91442b-1277-4d7d-8059-624a47f1844d"/>
                              <a:da name="DEFAULT" type="XPath" expr="num:i((node:fallback(./@index, '0') mod num:i(ecu:get('Adc.AdcConfigSet.AdcScRegister'))) * 50)"/>
                              <a:da name="INVALID" type="Range">
                                <a:tst expr="&lt;=65535"/>
                                <a:tst expr="&gt;=0"/>
                              </a:da>
                              <a:da name="INVALID" type="XPath">
                                <a:tst expr="(. &gt;= (../../AdcChannelDelay/*[(@index &gt; node:current()/@index) and (@index &lt; (floor(((node:current()/@index) div ecu:get('Adc.AdcConfigSet.AdcScRegister')) + 1) * ecu:get('Adc.AdcConfigSet.AdcScRegister')))])) and (. != ../../AdcChannelDelay/*[last()]) and (((node:current()/@index + 1) mod ecu:get('Adc.AdcConfigSet.AdcScRegister')) != 0)"
                                        true="The delay values must be increasing numbers for each sequence of 16/24/32 channels - depending on derivative (refer to Reference Manual for details)."/>
                              </a:da>
                            </v:var>
                          </v:lst>

                          <!-- AdcGroupDefinition -->
                          <!-- ECUC_Adc_00014 -->
                          <!-- /** @implements AdcGroupDefinition_Object */ -->
                          <v:lst name="AdcGroupDefinition">
                            <!-- SWS_Adc_00091 -->
                            <a:da name="MIN" value="1"/>
                            <a:da name="INVALID" type="XPath">
                              <!-- SWS_Adc_00451 -->
                              <a:tst expr="(../../../../../../AdcGeneral/AdcEnableLimitCheck = 'true') and (num:i(count(node:current()/*)) &gt; 1) and (num:i(count(node:refs(./*)/AdcChannelLimitCheck[.='true'])) > 0)"
                              true="ADC Channel group must contain exactly one ADC Channel if the global limit checking feature is enabled and a channel with specific limit checking is into the group."/>
                              <a:tst expr="(count(./*) > ecu:get('Adc.AdcConfigSet.AdcScRegister')) and (../../../../../../AutosarExt/AdcOptimizeOneShotHwTriggerConversions = 'true')"
                              true="Number of group channels shouldn't be greater than maximum number of SC1 registers when AutosarExt/AdcOptimizeOneShotHwTriggerConversions is enabled."/>
                            </a:da>
                            <!-- /** @requirements SWS_Adc_00098 */ -->
                            <v:ref name="AdcGroupDefinition" type="REFERENCE">
                              <a:a name="DESC">
                                <a:v><![CDATA[EN:<html><p>Assignment of channels to a AdcGroups. For each AdcChannel that should belong to the group, a reference needs to be defined.</p></html>]]></a:v>
                              </a:a>
                              <a:a name="REQUIRES-INDEX" value="true"/>
                              <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                              <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                              <a:a name="SCOPE" value="LOCAL"/>
                              <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                   type="IMPLEMENTATIONCONFIGCLASS">
                                <icc:v class="PostBuild">VariantPostBuild</icc:v>
                                <icc:v class="PreCompile">VariantPreCompile</icc:v>
                              </a:a>
                              <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                              <a:a name="UUID" value="ECUC:26fd14c8-d5af-4316-acc3-ddf94411ff8c"/>
                              <a:da name="REF" value="ASPathDataOfSchema:/AUTOSAR/EcucDefs/Adc/AdcConfigSet/AdcHwUnit/AdcChannel"/>
                              <a:da name="INVALID" type="XPath">
                                <a:tst expr=".=''" true="Select an ADC channel for the configured group."/>
                                <!-- /** @requirements SWS_Adc_00277 */ -->
                                <a:tst expr="contains(., ../../../../@name)" false="The ADC channel must be mapped on the same Hw Unit Group."/>
                                <a:tst expr="count(text:grep(../../../../AdcChannel/*/@name, substring-after(substring-after(substring-after(substring-after(substring-after(string(.), '/'), '/'),'/'),'/'), '/')))>0"
                                   false="The ADC channel must be defined on the Hw Unit Group."/>
                              </a:da>
                            </v:ref>
                          </v:lst>

                          <!--  This node is required by Autosar but set editable false because not supported by driver implementation  -->
                          <!-- ECUC_Adc_00465 -->
                          <!--  @implements AdcGroupEcucPartitionRef_Object  -->
                          <v:lst name="AdcGroupEcucPartitionRef">
                              <a:a name="EDITABLE" value="false"/>
                              <v:ref name="AdcGroupEcucPartitionRef"
                                     type="REFERENCE">
                                <a:a name="DESC">
                                  <a:v>EN: Maps an ADC channel group to zero or multiple ECUC partitions to limit the access to this channel group. The ECUC partitions referenced are a subset of the ECUC partitions where the ADC driver is mapped to.</a:v>
                                  <a:v>EN: Tags: atp.Status=draft</a:v>
                                </a:a>
                                <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                     type="IMPLEMENTATIONCONFIGCLASS">
                                  <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                                  <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                                  <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                                  <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                                </a:a>
                                <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                                <a:a name="POSTBUILDVARIANTMULTIPLICITY"
                                     value="true"/>
                                <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                                <a:a name="SCOPE" value="ECU"/>
                                <a:a name="UUID"
                                     value="ECUC:39370532-a5e1-4b76-bb7a-609547382d1d"/>
                                <a:da name="REF"
                                      value="ASPathDataOfSchema:/AUTOSAR/EcucDefs/EcuC/EcucPartitionCollection/EcucPartition"/>
                              </v:ref>
                          </v:lst>

                          <!-- AdcGroupConversionConfiguration Big Container -->
                          <v:ctr name="AdcGroupConversionConfiguration" type="IDENTIFIABLE">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Configure the Sampling and Conversion TimeGroup.
                               Hardware averaging functionality is also available for configuration</p></html>]]></a:v>
                            </a:a>
                            <a:a name="UUID" value="ECUC:25c64cfd-fe5b-44bc-bd09-8239023d87f3"/>

                          <!-- AdcGroupHardwareAverageEnable -->
                          <v:var name="AdcGroupHardwareAverageEnable" type="BOOLEAN">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Enables the hardware average function of the ADC.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                            <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Hardware Average Enable"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:8fd361db-6ed5-41d7-9ecb-b2046cd3f993"/>
                            <a:da name="DEFAULT" value="false"/>
                            <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="node:fallback(../../../../../../../AutosarExt/AdcConvTimeOnce,'false') = 'false'"/>
                            </a:a>
                            <a:da name="WARNING" type="XPath">
                                <a:tst expr="(node:fallback(.,'false') = 'true') and not(node:fallback(../../../../../../../AutosarExt/AdcConvTimeOnce,'false') = 'false')"
                                true="If Averaging functionality is not intended to use, it should be disabled to reduce total ADC acquisition time"/>
                            </a:da>
                          </v:var>

                          <!-- AdcHardwareAverageSelect -->
                          <v:var name="AdcGroupHardwareAverageSelect" type="ENUMERATION">
                            <a:a name="DESC">
                                 <a:v><![CDATA[EN:<html><p>Determines how many ADC conversions will be averaged to create the ADC average result. This functionality is activated when ADCx_MCR[AVGEN] = 1.
                                      <ul>
                                      <li>SAMPLES_4        - 4 samples averaged.</li>
                                      <li>SAMPLES_8        - 8 samples averaged.</li>
                                      <li>SAMPLES_16       - 16 samples averaged.</li>
                                      <li>SAMPLES_32       - 32 samples averaged.</li>
                                      </ul>.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                            <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="LABEL" value="Adc Group Hardware Average Select"/>
                            <a:a name="UUID" value="ECUC:f1f0591f-5cc8-4ed5-be66-b24399ffed3e"/>
                            <a:da name="DEFAULT" value="SAMPLES_4"/>
                            <a:a name="EDITABLE" type="XPath">
                                <a:tst expr="(node:fallback(../AdcGroupHardwareAverageEnable,'true') = 'true') and (node:fallback(../../../../../../../AutosarExt/AdcConvTimeOnce,'false') = 'false')"/>
                            </a:a>
                            <a:da name="RANGE">
                                <a:v>SAMPLES_4</a:v>
                                <a:v>SAMPLES_8</a:v>
                                <a:v>SAMPLES_16</a:v>
                                <a:v>SAMPLES_32</a:v>
                            </a:da>
                          </v:var>

                          <!-- AdcGroupSampleTimeDuration -->
                          <v:var name="AdcGroupSampleTimeDuration" type="INTEGER">
                            <a:a name="DESC">
                                  <a:v><![CDATA[EN:<html><p>Input a value 1 to 255 means selecting a sample time of 2 to 256 ADCK clock cycles. The value written to this register is the desired sample time minus 1.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                  type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Sample Time Duration"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:6153a38d-da3e-4d9e-8564-f8fe85f7b2b3"/>
                            <a:da name="DEFAULT" value="2"/>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=255"/>
                              <a:tst expr="&gt;=1"/>
                            </a:da>
                            <a:a name="EDITABLE" type="XPath">
                                <a:tst expr="node:fallback(../../../../../../../AutosarExt/AdcConvTimeOnce,'false') = 'false'"/>
                            </a:a>
                          </v:var>
                        </v:ctr>

                        <v:ctr name="AdcAlternateGroupConvTimings" type="IDENTIFIABLE">
                          <a:a name ="DESC">
                          <a:v>
                              <![CDATA[<html><p> Selects Alternate values used for programming CTR Conversion Timing Registers in Adc_SetClockMode API. This is available when AdcEnableDualClockMode has been enabled and AdcConvTimeOnce has been disable. Hardware averaging functionality is also available for configuration</p></html>]]></a:v>
                          </a:a>
                          <a:a name="UUID" value="ECUC:0cb2a83c-677d-434e-80a6-169b5c6e63e4"/>

                          <!-- AdcGroupAltHardwareAverageEnable -->
                          <v:var name="AdcGroupAltHardwareAverageEnable" type="BOOLEAN">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Enables the alternate hardware average function of the ADC.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                            <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Alternate Hardware Average Enable"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:8fd361db-6ed5-41d7-9ecb-b2046cd31132"/>
                            <a:da name="DEFAULT" value="false"/>
                            <a:a name="EDITABLE" type="XPath">
                              <a:tst expr="node:fallback(../../../../../../../AutosarExt/AdcConvTimeOnce,'false') = 'false' and node:fallback(../../../../../../../AutosarExt/AdcEnableDualClockMode,'false') = 'true'"/>
                            </a:a>
                            <a:da name="WARNING" type="XPath">
                                <a:tst expr="(node:fallback(.,'false') = 'true') and not(node:fallback(../../../../../../../AutosarExt/AdcConvTimeOnce,'false') = 'false' and node:fallback(../../../../../../../AutosarExt/AdcEnableDualClockMode,'false') = 'true')"
                                true="If Averaging functionality is not intended to use, it should be disabled to reduce total ADC acquisition time"/>
                            </a:da>
                          </v:var>

                          <!-- AdcGroupAltHardwareAverageSelect -->
                          <v:var name="AdcGroupAltHardwareAverageSelect" type="ENUMERATION">
                            <a:a name="DESC">
                                 <a:v><![CDATA[EN:<html><p>Selects the Group Alternate Hardware Average to determine how many ADC conversions will be averaged to create the ADC average result. This functionality is activated when ADCx_MCR[AVGEN] = 1.
                                      <ul>
                                      <li>SAMPLES_4        - 4 samples averaged.</li>
                                      <li>SAMPLES_8        - 8 samples averaged.</li>
                                      <li>SAMPLES_16       - 16 samples averaged.</li>
                                      <li>SAMPLES_32       - 32 samples averaged.</li>
                                      </ul>.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                            <a:a name="SCOPE" value="LOCAL"/>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                type="IMPLEMENTATIONCONFIGCLASS">
                            <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                            <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="LABEL" value="Adc Group Alternate Hardware Average Select"/>
                            <a:a name="UUID" value="ECUC:f1f0591f-5cc8-4ed5-be66-b24399ff1133"/>
                            <a:da name="DEFAULT" value="SAMPLES_4"/>
                            <a:a name="EDITABLE" type="XPath">
                                <a:tst expr="(node:fallback(../AdcGroupAltHardwareAverageEnable,'false') = 'true')
                                and (node:fallback(../../../../../../../AutosarExt/AdcConvTimeOnce,'false') = 'false')
                                and (node:fallback(../../../../../../../AutosarExt/AdcEnableDualClockMode,'false') = 'true')"/>
                            </a:a>
                            <a:da name="RANGE">
                                <a:v>SAMPLES_4</a:v>
                                <a:v>SAMPLES_8</a:v>
                                <a:v>SAMPLES_16</a:v>
                                <a:v>SAMPLES_32</a:v>
                            </a:da>
                          </v:var>

                          <!-- AdcGroupAltSampleTimeDuration -->
                          <v:var name="AdcGroupAltSampleTimeDuration" type="INTEGER">
                            <a:a name="DESC">
                              <a:v><![CDATA[EN:<html><p>Selects a alternate sample time of 2 to 256 ADCK clock cycles. The alternate value written to this register is the desired sample time minus 1.</p></html>]]></a:v>
                            </a:a>
                            <a:a name="IMPLEMENTATIONCONFIGCLASS"
                                  type="IMPLEMENTATIONCONFIGCLASS">
                              <icc:v class="PostBuild">VariantPostBuild</icc:v>
                              <icc:v class="PreCompile">VariantPreCompile</icc:v>
                            </a:a>
                            <a:a name="LABEL" value="Adc Group Alternate Sample Time Duration"/>
                            <a:a name="ORIGIN" value="NXP"/>
                            <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                            <a:a name="UUID" value="ECUC:6153a38d-da3e-4d9e-8564-f8fe85f71134"/>
                            <a:da name="DEFAULT" value="2"/>
                            <a:da name="INVALID" type="Range">
                              <a:tst expr="&lt;=255"/>
                              <a:tst expr="&gt;=1"/>
                            </a:da>
                            <a:a name="EDITABLE" type="XPath">
                                <a:tst expr="(node:fallback(../../../../../../../AutosarExt/AdcConvTimeOnce,'false') = 'false') and
                                (node:fallback(../../../../../../../AutosarExt/AdcEnableDualClockMode,'false') = 'true')"/>
                            </a:a>
                          </v:var>
                        </v:ctr>
                      </v:ctr>
                      </v:lst>

                      <v:lst name="AdcHwUnitEcucPartitionRef">
                        <a:a name="EDITABLE" value="false"/>
                      <v:ref name="AdcHwUnitEcucPartitionRef" type="REFERENCE">
                        <a:a name="DESC">
                          <a:v>Maps a ADC hardware unit to zero or one ECUC partition to limit the access to this hardware unit. The ECUC partitions referenced are a subset of the ECUC partitions where the ADC driver is mapped to. This parameter is disabled, there is no multicore support implemented for this platform.</a:v>
                        </a:a>
                        <a:a name="IMPLEMENTATIONCONFIGCLASS"
                             type="IMPLEMENTATIONCONFIGCLASS">
                          <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                          <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                          <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                          <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                        </a:a>
                        <a:a name="ORIGIN" value="NXP"/>
                        <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                        <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                        <a:a name="SCOPE" value="ECU"/>
                        <a:a name="UUID"
                             value="ECUC:14cc6e73-619e-4029-a793-3535990384ae"/>
                        <a:da name="REF"
                              value="ASPathDataOfSchema:/AUTOSAR/EcucDefs/EcuC/EcucPartitionCollection/EcucPartition"/>
                      </v:ref>
                      </v:lst>
                    </v:ctr>
                  </v:lst>

                <!-- AdcHwTrigger Big container -->
                <v:lst name="AdcHwTrigger" type="MAP">
                <a:da name="MIN" value="0"/>
                <a:da name="EDITABLE" value="true"/>
                <!-- <a:da name="EDITABLE" type="XPath" expr="count(../AdcHwUnit/*/AdcGroup/*[AdcGroupTriggSrc='ADC_TRIGG_SRC_HW']) > 0"/> Editable only if at least one group has HW trigger source selected. -->
                <v:ctr name="AdcHwTrigger" type="IDENTIFIABLE">
                    <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>This container contains the Hardware trigger source configured for the group. Editable only if at least one group has HW trigger source selected. </p></html>]]></a:v>
                    </a:a>
                    <a:a name="REQUIRES-INDEX" value="true"/>
                    <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                    <a:a name="IMPLEMENTATIONCONFIGCLASS"
                        type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                    </a:a>
                    <a:a name="UUID" value="ECUC:1df7a136-db83-44a5-ac85-ff21c8db3f05"/>

                    <!-- AdcHwTrigSrc -->
                    <!--  @implements AdcHwTrigSrc_Object  -->
                    <v:var name="AdcHwTrigSrc" type="ENUMERATION">
                    <a:a name="DESC">
                        <a:v><![CDATA[EN:<html><p>
                        On this implementation the HW triggers available are from PDB.
                        (Note: This is an Implementation Specific Parameter.)</p></html>]]>
                        </a:v>
                    </a:a>
                    <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                    <a:a name="SCOPE" value="LOCAL"/>
                    <a:a name="IMPLEMENTATIONCONFIGCLASS"
                        type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PostBuild">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                    </a:a>
                    <a:a name="LABEL" value="Adc Group Hardware Trigger Source"/>
                    <a:a name="ORIGIN" value="NXP"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:a name="UUID" value="ECUC:c9e2c854-915c-43a8-a537-c90d7f023a71"/>
                    <a:da name="DEFAULT" value="TRIGGER_IN0"/>
                    <a:a name="INVALID" type="XPath">
                    <a:tst expr="text:uniq(../../*/AdcHwTrigSrc, .)" false="Duplicate trigger source for ADC Group."/>
                    </a:a>
                    <a:da name="RANGE" type="XPath" expr="ecu:list('Adc.AdcConfigSet.AdcHwTrigSrc')"/>
                    </v:var>
                </v:ctr>
                </v:lst>

              </v:ctr>

              <!-- AdcGeneral Big Container -->
              <!-- ECUC_Adc_00027 -->
              <!-- /** @implements AdcGeneral_Object */ -->
              <v:ctr name="AdcGeneral" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>General configuration (parameters) of the ADC Driver software module.</p></html>]]></a:v>
                </a:a>
                <a:a name="UUID" value="ECUC:5d3d9066-300f-4ba4-9d89-02717f28d967"/>

                <!-- AdcDeInitApi -->
                <!-- ECUC_Adc_00404, SWS_Adc_00228 -->
                <v:var name="AdcDeInitApi" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Adds/removes the service Adc_DeInit() from the code.
                            <li>true: Adc_DeInit() can be used.</li>
                            <li>false: Adc_DeInit() can not be used.</li></p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc_DeInit API"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:c2a39725-ca66-4165-9aa8-dc51d263ef72"/>
                  <a:da name="DEFAULT" value="true"/>
                </v:var>

                <!-- AdcDevErrorDetect -->
                <!-- ECUC_Adc_00405 -->
                <v:var name="AdcDevErrorDetect" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Switches the development error detection and notification on or off.
                            <li>true: detection and notification is enabled.</li>
                            <li>false: detection and notification is disabled.</li></p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Development Error Detection"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:ab29d43a-e9a4-4eed-9f4d-8559b4e39e89"/>
                  <a:da name="DEFAULT" value="true"/>
                </v:var>

                <!-- AdcEnableLimitCheck -->
                <!-- ECUC_Adc_00452 -->
                <v:var name="AdcEnableLimitCheck" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Enables or disables limit checking feature in the ADC driver.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Enable Limit Check"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:1f75320a-0500-4767-b096-d9f9b2a372e6"/>
                  <a:da name="DEFAULT" value="true"/>
                </v:var>

                <!-- AdcEnableQueuing -->
                <!-- ECUC_Adc_00391, SWS_Adc_00333 -->
                <v:var name="AdcEnableQueuing" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Determines, if the queuing mechanism is active in case of priority mechanism disabled.
                        Note: If priority mechanism is enabled, queuing mechanism is always active and the parameter ADC_ENABLE_QUEUING is not evaluated.
                        <li>true: Enabled.</li>
                        <li>false: Disabled.</li></p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Enable Queuing"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:30a4f3cf-e092-4deb-8353-a92a1738229d"/>
                  <a:da name="DEFAULT" value="true"/>
                  <a:a name="EDITABLE" type="XPath">
                    <a:tst expr="../AdcPriorityImplementation = 'ADC_PRIORITY_NONE'"/>
                  </a:a>
                </v:var>

                <!-- AdcPriorityQueueMaxDepth -->
                <v:var name="AdcPriorityQueueMaxDepth" type="INTEGER">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Maximum depth of queue used for queuing of incoming conversion requests when hardware unit is busy.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Max Queue Depth"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:33cfe352-1333-43a6-b6d2-54239b433f1b"/>
                  <a:da name="DEFAULT" value="1"/>
                  <a:da name="RANGE" type="XPath">
                    <a:tst expr="../AdcPriorityImplementation = 'ADC_PRIORITY_NONE' and ../AdcEnableQueuing = 'false' and . !=1" true="The depth must be 1 if the AdcGeneral/AdcEnableQueuing is disabled and AdcGeneral/AdcPriorityImplementation is set as ADC_PRIORITY_NONE."/>
                  </a:da>
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&lt;=1024"/>
                    <a:tst expr="&gt;=1"/>
                  </a:da>
                </v:var>

                <!-- AdcEnableStartStopGroupApi -->
                <!-- ECUC_Adc_00406, SWS_Adc_00259, SWS_Adc_00260, SWS_Adc_00356 -->
                <v:var name="AdcEnableStartStopGroupApi" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Adds / removes the services Adc_StartGroupConversion() and Adc_StopGroupConversion() from the code.
                      <li>true: Adc_StartGroupConversion() and Adc_StopGroupConversion() can be used.</li>
                      <li>false: Adc_StartGroupConversion() and Adc_StopGroupConversion() can not be used.</li>
                    </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc_StartStopGroup API"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:e72dfb05-6a85-4661-8a6b-2aded1691995"/>
                  <a:da name="DEFAULT" value="true"/>
                  <a:a name="INVALID" type="XPath">
                    <a:tst expr="(. = 'false') and (../AdcHwTriggerApi = 'false')"
                           true="At least one of 2 parameters AdcEnableStartStopGroupApi or AdcHwTriggerApi has to be enabled in order to be able to use the ADC driver."/>
                  </a:a>
                </v:var>

                <!-- AdcGrpNotifCapability -->
                <!-- ECUC_Adc_00105, SWS_Adc_00100, SWS_Adc_00101 -->
                <v:var name="AdcGrpNotifCapability" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Determines, if the group notification mechanism (the functions to enable and disable the notifications) is available at runtime.
                        <li>true: Enabled.</li>
                        <li>false: Disabled.</li></p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Notification Capability"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:0b3ecae2-f557-4f90-94f0-5452e9c03659"/>
                  <a:da name="DEFAULT" value="true"/>
                </v:var>

                <!-- AdcHwTriggerApi -->
                <!-- ECUC_Adc_00408, SWS_Adc_00265, SWS_Adc_00266 -->
                <v:var name="AdcHwTriggerApi" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Adds / removes the services Adc_EnableHardwareTrigger() and Adc_DisableHardwareTrigger() from the code.
                      <li>true: Adc_EnableHardwareTrigger() and Adc_DisableHardwareTrigger() can be used.</li>
                      <li>false: Adc_EnableHardwareTrigger() and Adc_DisableHardwareTrigger() can not be used.</li>
                    </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Hw Trigger  API"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:e2930cb1-2824-42e0-84fd-4e72fb180f7d"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>

                <!-- AdcPriorityImplementation -->
                <!-- ECUC_Adc_00393, SWS_Adc_00315, SWS_Adc_00340 -->
                <v:var name="AdcPriorityImplementation" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Determines whether a priority mechanism is available for prioritization of the conversion requests and if available, the type of prioritization mechanism. The selection applies for groups with trigger source software and trigger source hardware. Two types of prioritization mechanism can be selected.
                      The hardware prioritization mechanism (AdcPriorityHw) uses the ADC hardware features for prioritization of the software conversion requests and hardware trigger signals for groups with trigger source hardware.
                      The mixed hardware and software prioritization mechanism (AdcPriorityHwSw) uses the ADC hardware features for prioritization of ADC hardware trigger for groups with trigger source hardware and a software implemented prioritization mechanism for groups with trigger source software.
                      The group priorities for software triggered groups are typically configured with lower priority levels than the group priorities for hardware triggered groups.
                      ImplementationType: Adc_PriorityImplementationType.
                      Note: In this version the ADC_PRIORITY_HW isn't used.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Priority Mechanism"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:5c9c40fe-a13c-4501-8290-443b3417ebdd"/>
                  <a:da name="DEFAULT" value="ADC_PRIORITY_NONE"/>
                  <a:da name="RANGE">
                    <a:v>ADC_PRIORITY_HW</a:v>
                    <a:v>ADC_PRIORITY_HW_SW</a:v>
                    <a:v>ADC_PRIORITY_NONE</a:v>
                  </a:da>
                  <a:da name="INVALID" type="XPath">
                    <a:tst expr=".='ADC_PRIORITY_HW'"
                    true="Priority Hardware mechanism is not supported."/>
                  </a:da>
                </v:var>

                <!-- AdcReadGroupApi -->
                <!-- ECUC_Adc_00394, SWS_Adc_00359, SWS_Adc_00383 -->
                <v:var name="AdcReadGroupApi" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Adds / removes the service Adc_ReadGroup() from the code.
                      <li>true: Adc_ReadGroup() can be used.</li>
                      <li>false: Adc_ReadGroup() can not be used.</li>
                    </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc_ReadGroup API"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:b30e7432-c589-413d-bb14-fa157c615067"/>
                  <a:da name="DEFAULT" value="true"/>
                </v:var>

                <!-- AdcResultAlignment -->
                <!-- ECUC_Adc_00444, CPR-MCAL-740.adc -->
                <v:var name="AdcResultAlignment" type="ENUMERATION">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Alignment of ADC raw results in ADC result buffer (left/right alignment).
                      Implementation Type: Adc_ResultAlignmentType.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Result Alignment"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:aa2aec7d-5ef6-4d53-838a-1712f99bf11c"/>
                  <a:da name="DEFAULT" value="ADC_ALIGN_RIGHT"/>
                  <a:da name="RANGE">
                    <a:v>ADC_ALIGN_RIGHT</a:v>
                    <a:v>ADC_ALIGN_LEFT</a:v>
                  </a:da>
                </v:var>

                <!-- AdcVersionInfoApi -->
                <!-- ECUC_Adc_00409 -->
                <v:var name="AdcVersionInfoApi" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Adds / removes the service Adc_GetVersionInfo() from the code.
                      <li>true: Adc_GetVersionInfo() can be used.</li>
                      <li>false: Adc_GetVersionInfo() can not be used.</li>
                    </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc_VersionInfo API"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:6dde8f53-d250-4c27-bb2b-3c64b3d20df9"/>
                  <a:da name="DEFAULT" value="true"/>
                </v:var>

                <!-- ECUC_Adc_00463 -->
                <!--  @implements AdcEcucPartitionRef_Object  -->
                <v:lst name="AdcEcucPartitionRef">
                    <a:a name="EDITABLE" value="false"/>
                  <v:ref name="AdcEcucPartitionRef" type="REFERENCE">
                    <a:a name="DESC">
                      <a:v>EN: Maps the ADC driver to zero or multiple ECUC partitions to make the driver API available in the according partition.</a:v>
                      <a:v>EN: Tags: atp.Status=draft</a:v>
                    </a:a>
                    <a:a name="IMPLEMENTATIONCONFIGCLASS"
                         type="IMPLEMENTATIONCONFIGCLASS">
                      <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                      <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                      <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                      <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                    </a:a>
                    <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                    <a:a name="REQUIRES-INDEX" value="true"/>
                    <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                    <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                    <a:a name="SCOPE" value="ECU"/>
                    <a:a name="UUID"
                         value="ECUC:f86d720b-a1e5-4f3f-a656-0f49601b8563"/>
                    <a:da name="REF"
                          value="ASPathDataOfSchema:/AUTOSAR/EcucDefs/EcuC/EcucPartitionCollection/EcucPartition"/>
                  </v:ref>
                </v:lst>

                <!--  This node is required by Autosar but set editable false because not supported by driver implementation  -->
                <!-- ECUC_Adc_00464 -->
                <!--  @implements AdcKernelEcucPartitionRef_Object  -->
                <v:ref name="AdcKernelEcucPartitionRef" type="REFERENCE">
                  <a:a name="EDITABLE" value="false"/>
                  <a:a name="DESC">
                    <a:v>EN: Maps the ADC kernel to zero or one ECUC partition to assign the driver kernel to a certain core. The ECUC partition referenced is a subset of the ECUC partitions where the ADC driver is mapped to.</a:v>
                    <a:v>EN: Tags: atp.Status=draft</a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="true"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="true"/>
                  <a:a name="SCOPE" value="ECU"/>
                  <a:a name="UUID"
                       value="ECUC:2257ea54-1810-4b76-84b2-e12939218b57"/>
                  <a:da name="REF"
                        value="ASPathDataOfSchema:/AUTOSAR/EcucDefs/EcuC/EcucPartitionCollection/EcucPartition"/>
                  <a:a name="OPTIONAL" value="true"/>
                </v:ref>

                <!--  ECUC_Adc_00457 -->
                <!-- @implements AdcLowPowerStatesSupport_Object -->
                <v:var name="AdcLowPowerStatesSupport" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Adds / removes all power state management related APIs (ADC_SetPowerState, ADC_GetCurrentPowerState, ADC_GetTargetPowerState, ADC_PreparePowerState, ADC_Main_PowerTransitionManager), indicating if the HW offers low power state management.
                    NOTE: K1 platform does not support low power modes for ADC so this feature is always disabled.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v class="PreCompile">VariantPostBuild</icc:v>
                    <icc:v class="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Low Power States Support"/>
                  <a:a name="OPTIONAL" value="true"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:e2930cb1-2824-42e0-84fd-4e72fb180e7d"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="READONLY" value="true"/>
                </v:var>

                <!-- ECUC_Adc_00458 -->
                <!-- @implements AdcPowerStateAsynchTransitionMode_Object -->
                <v:var name="AdcPowerStateAsynchTransitionMode" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Enables / disables support of the ADC Driver to the asynchronous power state transition. This feature is not implemented on this platform.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v class="PreCompile">VariantPostBuild</icc:v>
                    <icc:v class="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Power State Asynch Transition Mode"/>
                  <a:a name="OPTIONAL" value="true"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:c20b0644-70bf-435d-ace6-8626ec469675"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="EDITABLE" type="XPath" expr="(node:exists(../AdcLowPowerStatesSupport) and (../AdcLowPowerStatesSupport = 'true'))"/>
                  <a:da name="READONLY" value="true"/>
                </v:var>

                <!-- @implements ECUC_Adc_00459 -->
                <!-- @implements AdcPowerStateConfig_Object -->
                <v:lst name="AdcPowerStateConfig" type="MAP">
                  <a:da name="EDITABLE"  type="XPath" expr="(node:exists(../AdcPowerStateAsynchTransitionMode) and (../AdcPowerStateAsynchTransitionMode = 'true' ))"/>
                  <v:ctr name="AdcPowerStateConfig" type="IDENTIFIABLE">
                    <a:a name="DESC">
                        <a:v><![CDATA[EN:<html><p>Each instance of this parameter defines a power state and the callback to be called when this power state is reached.</p></html>]]></a:v>
                    </a:a>
                    <a:a name="POSTBUILDVARIANTMULTIPLICITY" value="false"/>
                    <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                        <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                        <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                    </a:a>
                    <a:a name="UUID" value="ECUC:66904f78-ff07-4ed3-878e-401a3430cd38"/>

                    <!-- @implements ECUC_Adc_00461 -->
                    <!-- @implements AdcPowerState_Object -->
                    <v:var name="AdcPowerState" type="INTEGER">
                      <a:a name="DESC">
                        <a:v><![CDATA[EN:<html><p>Each instance of this parameter describes a different power state
                             supported by the ADC HW. It should be defined by the HW supplier and
                             used by the ADCDriver to reference specific HW configurations which set
                             the ADC HW module in the referenced power state. At least the power mode
                             corresponding to full power state shall be always configured.
                             This parameter shall only be configured if the parameter AdcLowPowerStatesSupport is set to true.</p></html>]]>
                        </a:v>
                      </a:a>
                      <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                      <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                        <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                        <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                      </a:a>
                      <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                      <a:a name="SCOPE" value="LOCAL"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="true"/>
                      <a:a name="UUID"  value="ECUC:41902199-e783-4afe-bef3-41c69e08b32d"/>
                      <a:da name="DEFAULT" value="0"/>
                      <a:da name="INVALID" type="Range">
                        <a:tst expr="&lt;=18446744073709551615"/>
                        <a:tst expr="&gt;=0"/>
                      </a:da>
                    </v:var>

                    <!-- @implements ECUC_Adc_00460 -->
                    <!-- @implements AdcPowerStateReadyCbkRef_Object -->
                    <v:var name="AdcPowerStateReadyCbkRef" type="FUNCTION-NAME">
                      <a:a name="DESC">
                        <a:v><![CDATA[EN:<html><p>Each instance of this parameter contains a reference to a power mode callback defined in a CDD or IoHwAbs component.
                             This parameter shall only be configured if the parameter AdcLowPowerStatesSupport is set to true</p></html>]]>
                        </a:v>
                      </a:a>
                      <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                      <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                        <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                        <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                      </a:a>
                      <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                      <a:a name="SCOPE" value="LOCAL"/>
                      <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                      <a:a name="UUID" value="ECUC:b9c222fc-6b92-40e9-922e-f73addaf2320"/>
                      <a:da name="DEFAULT" value="NULL_PTR"/>
                    </v:var>
                  </v:ctr>
                </v:lst>
              </v:ctr>

              <v:lst name="AdcInterrupt" type="MAP">
                  <a:da name="MIN" value="1"/>
                  <a:da name="INVALID" type="XPath">
                      <a:tst expr="count(./*) &lt; count(ecu:list('Adc.AdcInterrupts.List'))"
                          true="The number of containers in the AdcInterrupts list is not sufficient."/>
                      <a:tst expr="count(./*) &gt; count(ecu:list('Adc.AdcInterrupts.List'))"
                          true="The number of containers in the AdcInterrupts list is too many."/>
                  </a:da>

                <v:ctr name="AdcInterrupt" type="IDENTIFIABLE">
                  <a:a name ="DESC">
                  <a:v>
                      <![CDATA[<html><p> Selects whether the interrupt for each ADC Unit will be enabled. These settings are used for optimizing the code size by removing the interrupt handling code for interrupts that are not needed. . </p></html>]]></a:v>
                  </a:a>
                  <a:a name="UUID" value="ECUC:0cb2283c-677d-434e-80a6-169b5c6e63e8"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v mclass="PreCompile">VariantPreCompile</icc:v>
                    <icc:v mclass="PreCompile">VariantPostBuild</icc:v>
                  </a:a>

                  <v:var name="AdcInterruptSource" type="ENUMERATION">
                    <a:a name="DESC">
                      <a:v>
                        <![CDATA[EN:<html>
                            The name of the interrupt.<p/>
                            Note: Implementation Specific Parameter.
                        </html>]]>
                      </a:v>
                    </a:a>
                    <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                    <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                      <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                      <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    </a:a>
                    <a:a name="ORIGIN" value="NXP"/>
                    <a:a name="LABEL" value="Adc Interrupt Name"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:a name="SCOPE" value="LOCAL"/>
                    <a:a name="UUID" value="ECUC:0fef779b-bf2c-466a-9110-5f848d8e3e17"/>
                    <a:da name="DEFAULT" type="XPath" expr="ecu:list('Adc.AdcInterrupts.List')[num:i(node:fallback(node:current()/../@index, num:i(0)) + 1)]"/>
                    <a:da name="RANGE" type="XPath" expr="ecu:list('Adc.AdcInterrupts.List')"/>
                    <a:da name="INVALID" type="XPath">
                      <a:tst expr="text:uniq(node:fallback(../../*/AdcInterruptSource, ecu:list('Adc.AdcInterrupts.List')), node:fallback(., 'ADC0_COCO'))"
                          false="Duplicated value, AdcInterruptSource must be unique across AdcInterrupt."/>
                    </a:da>
                  </v:var>

                  <!-- Adc Interrupt Enable -->
                  <v:var name="AdcInterruptEnable" type="BOOLEAN">
                    <a:a name="DESC">
                      <a:v><![CDATA[EN:<html><p>Adds / removes the interrupt handling routine from the ADC driver code.</p></html>]]></a:v>
                    </a:a>
                    <a:a name="SCOPE" value="LOCAL"/>
                    <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                    <a:a name="IMPLEMENTATIONCONFIGCLASS"
                          type="IMPLEMENTATIONCONFIGCLASS">
                      <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                      <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                    </a:a>
                    <a:a name="LABEL" value="Adc Interrupt Enable"/>
                    <a:a name="ORIGIN" value="NXP"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:a name="UUID" value="ECUC:15707a07-29a2-4f44-9d3a-823d0cd58da9"/>
                    <a:da name="DEFAULT" value="false"/>
                  </v:var>
                </v:ctr>
              </v:lst>

              <!-- ECUC_Adc_00030 -->
              <!-- /** @implements AdcPublishedInformation_Object */ -->
              <v:ctr name="AdcPublishedInformation" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>Additional published parameters not covered by CommonPublishedInformation container.
                    Note that these parameters do not have any configuration class setting, since they are published information.</p></html>]]></a:v>
                </a:a>
                <a:a name="UUID" value="ECUC:3e265978-346e-4de7-be8c-c406a7ef02e0"/>

                <!-- AdcChannelValueSigned */ -->
                <!-- ECUC_Adc_00410 -->
                <v:var name="AdcChannelValueSigned" type="BOOLEAN_LABEL">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Information whether the result value of the ADC driver has sign information (true) or not (false). If the result shall be interpreted as signed value it shall apply to C-language rules.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Channel Value Signed"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:acb88fcc-ebdd-4232-b93f-d6c818ced64e"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>

                <!--  AdcGroupFirstChannelFixed */ -->
                <!--  ECUC_Adc_00411 -->
                <v:var name="AdcGroupFirstChannelFixed" type="BOOLEAN_LABEL">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Information whether the first channel of an ADC Channel group can be configured (false) or is fixed (true) to a value determined by the ADC HW Unit.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Group First Channel Fixed"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:d70338f5-2be1-4d89-9cdf-d012ba5db883"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>

                <!--  AdcMaxChannelResolution */ -->
                <!--  ECUC_Adc_00412 -->
                <v:var name="AdcMaxChannelResolution" type="INTEGER_LABEL">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Maximum Channel resolution in bits (does not specify accuracy).</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Max Channel Resolution"/>
                  <a:a name="ORIGIN" value="AUTOSAR_ECUC"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:dbe4e009-1c76-47ef-861c-9a4ea2871965"/>
                  <a:da name="DEFAULT" value="12"/>
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&lt;=63"/>
                    <a:tst expr="&gt;=1"/>
                  </a:da>
                </v:var>
              </v:ctr>

              <!-- PR-MCAL-3120.adc, PR-MCAL-3095.adc -->
              <!--  @implements CommonPublishedInformation_Object  -->
              <v:ctr name="CommonPublishedInformation" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>
                      Common container, aggregated by all modules. It contains published information about vendor and versions.
                  </p></html>]]></a:v>
                </a:a>
                <a:a name="UUID" value="ECUC:8a492572-bd3e-4c18-b2b3-4923f25b9b1e"/>
                <!--   @implements ArReleaseMajorVersion_Object   -->
                <v:var name="ArReleaseMajorVersion" type="INTEGER_LABEL">
                  <a:a name="DESC">
                      <a:v><![CDATA[EN:<html><p>
                      Major version number of AUTOSAR specification on which the appropriate implementation is based on.
                      </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:e7e9d572-8eef-4b6c-9433-8aad276eec7c"/>
                  <a:da name="DEFAULT" value="4"/>
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&gt;=4"/>
                    <a:tst expr="&lt;=4"/>
                  </a:da>
                </v:var>
                <!--  @implements ArReleaseMinorVersion_Object   -->
                <v:var name="ArReleaseMinorVersion" type="INTEGER_LABEL">
                  <a:a name="DESC">
                      <a:v><![CDATA[EN:<html><p>
                      Minor version number of AUTOSAR specification on which the appropriate implementation is based on.
                      </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:3d870209-be10-47c3-9857-538e620076c9"/>
                  <a:da name="DEFAULT" value="4"/>
                  <a:da name="INVALID" type="Range">
                      <a:tst expr="&gt;=4"/>
                      <a:tst expr="&lt;=4"/>
                  </a:da>
                </v:var>
                <!--  @implements ArReleaseRevisionVersion_Object   -->
                <v:var name="ArReleaseRevisionVersion" type="INTEGER_LABEL">
                  <a:a name="DESC">
                      <a:v><![CDATA[EN:<html><p>
                      Revision version number of AUTOSAR specification on which the appropriate implementation is based on.
                      </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:a83e5ff1-972e-4db3-8da8-0bbbc7689ec2"/>
                  <a:da name="DEFAULT" value="0"/>
                  <a:da name="INVALID" type="Range">
                      <a:tst expr="&gt;=0"/>
                      <a:tst expr="&lt;=0"/>
                  </a:da>
                </v:var>
                <!--   @implements ModuleId_Object   -->
                <v:var name="ModuleId" type="INTEGER_LABEL">
                  <a:a name="DESC">
                      <a:v><![CDATA[EN:<html><p>
                      Module ID of this module from Module List.
                      </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:dace0d32-017d-481a-844b-ca56c5fe5d98"/>
                  <a:da name="DEFAULT" value="123"/>
                  <a:da name="INVALID" type="Range">
                      <a:tst expr="&gt;=123"/>
                      <a:tst expr="&lt;=123"/>
                  </a:da>
                </v:var>
                <!--   @implements SwMajorVersion_Object   -->
                <v:var name="SwMajorVersion" type="INTEGER_LABEL">
                  <a:a name="DESC">
                      <a:v><![CDATA[EN:<html><p>
                      Major version number of the vendor specific implementation of the module. The numbering is vendor specific.
                      </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:931ea035-fc4a-451a-a9d6-8a45883e4cf1"/>
                  <a:da name="DEFAULT" value="1"/>
                  <a:da name="INVALID" type="Range">
                      <a:tst expr="&gt;=1"/>
                      <a:tst expr="&lt;=1"/>
                  </a:da>
                </v:var>
                <!--   @implements SwMinorVersion_Object  -->
                <v:var name="SwMinorVersion" type="INTEGER_LABEL">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>
                    Minor version number of the vendor specific implementation of the module. The numbering is vendor specific.
                    </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:bc6133b1-3991-449e-8584-49b11eff3a7f"/>
                  <a:da name="DEFAULT" value="0"/>
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&gt;=0"/>
                    <a:tst expr="&lt;=0"/>
                  </a:da>
                </v:var>
                <!--   @implements SwPatchVersion_Object  -->
                <v:var name="SwPatchVersion" type="INTEGER_LABEL">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>
                    Patch level version number of the vendor specific implementation of the module. The numbering is vendor specific.
                    </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:7f523334-ef23-4b15-b142-694a9d63fab9"/>
                  <a:da name="DEFAULT" value="1"/>
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&gt;=1"/>
                    <a:tst expr="&lt;=1"/>
                  </a:da>
                </v:var>
                <!--   @implements VendorApiInfix_Object   -->
                <v:var name="VendorApiInfix" type="STRING_LABEL">
                  <a:a name="DESC">
                      <a:v><![CDATA[EN:<html><p>
                      In driver modules which can be instantiated several times on a single ECU, BSW00347 requires that the name of APIs is extended by the VendorId and a vendor specific name.
                      This parameter is used to specify the vendor specific name. In total, the implementation specific name is generated as follows:
                      &lt;ModuleName&gt;_&gt;VendorId&gt;_&lt;VendorApiInfix&gt;&lt;Api name from SWS&gt;.
                      E.g.  assuming that the VendorId of the implementor is 123 and the implementer chose a VendorApiInfix of &quot;v11r456&quot; a api name Can_Write defined in the SWS will translate to Can_123_v11r456Write.
                      This parameter is mandatory for all modules with upper multiplicity &gt; 1. It shall not be used for modules with upper multiplicity =1.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:36a6319a-24af-44aa-bde8-4119ca8e61fd"/>
                  <a:da name="DEFAULT" value=""/>
                  <a:da name="READONLY" value="true"/>
                </v:var>
                <!--   @implements VendorId_Object  -->
                <v:var name="VendorId" type="INTEGER_LABEL">
                    <a:a name="DESC">
                        <a:v><![CDATA[EN:<html><p>
                          Vendor ID of the dedicated implementation of this module according to the AUTOSAR vendor list.
                        </p></html>]]></a:v>
                    </a:a>
                    <a:a name="SCOPE" value="LOCAL"/>
                    <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                    <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PublishedInformation">VariantPostBuild</icc:v>
                    <icc:v vclass="PublishedInformation">VariantPreCompile</icc:v>
                  </a:a>
                    <a:a name="ORIGIN" value="NXP"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:a name="UUID" value="ECUC:4fec8752-a2fc-44db-811a-3ee2a51d5ae1"/>
                    <a:da name="DEFAULT" value="43"/>
                    <a:da name="INVALID" type="Range">
                        <a:tst expr="&gt;=43"/>
                        <a:tst expr="&lt;=43"/>
                    </a:da>
                </v:var>
              </v:ctr>

              <!-- AutosarExt Big Container -->
              <v:ctr name="AutosarExt" type="IDENTIFIABLE">
                <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>Autosar Extension API settings.</p></html>]]></a:v>
                </a:a>
                <a:a name="UUID" value="ECUC:a840d02b-4967-4e98-8e41-b89fd1272780"/>

                <!-- @implements Adc Timeout Method -->
                <v:var name="AdcTimeoutMethod" type="ENUMERATION">
                  <a:a name="LABEL" value="Adc Timeout Method"/>
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html>
                      <p>Configures the timeout method for Adc.</p>
                      <p>Based on this selection a certain timeout method from OsIf will be used in the driver.</p>
                      <p>Note: If OSIF_COUNTER_SYSTEM or OSIF_COUNTER_CUSTOM are selected make sure the corresponding timer is enabled in OsIf General configuration. </p>
                      <p>Note: Implementation Specific Parameter.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                  <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:040e7ff3-d837-4037-9a81-c284bbad9a32"/>
                  <a:a name="DEFAULT" value="OSIF_COUNTER_DUMMY"/>
                  <a:da name="INVALID" type="XPath">
                    <a:tst expr="node:refs('ASPathDataOfSchema:/TS_T40D2M10I1R0/Base/OsIfGeneral/OsIfUseCustomTimer') = 'false' and node:fallback(.,'OSIF_COUNTER_DUMMY') = 'OSIF_COUNTER_CUSTOM'" true="Custom Timer is not enabled in OsIf (OsIfGeneral/OsIfUseCustomTimer checkbox)"/>
                    <a:tst expr="node:refs('ASPathDataOfSchema:/TS_T40D2M10I1R0/Base/OsIfGeneral/OsIfUseSystemTimer') = 'false' and node:fallback(.,'OSIF_COUNTER_DUMMY') = 'OSIF_COUNTER_SYSTEM'" true="System Timer is not enabled in OsIf (OsIfGeneral/OsIfUseSystemTimer checkbox)"/>
                  </a:da>
                  <a:da name="RANGE">
                    <a:v>OSIF_COUNTER_DUMMY</a:v>
                    <a:v>OSIF_COUNTER_SYSTEM</a:v>
                    <a:v>OSIF_COUNTER_CUSTOM</a:v>
                  </a:da>
                </v:var>

                <!-- @implements Adc Timeout Value -->
                <v:var name="AdcTimeoutVal" type="INTEGER">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>The timeout is used for preventing endless loops as resulted from driver FMEA analysis.</p>
                    <p>The hardware failure mode which is preventing, is potential cases with frozen peripheral status used for driver synchronization.</p>
                    <p>The timeout is used as escape for avoidance of endless loops. For more details please refer to driver FMEA.</p></html>]]></a:v>
                  </a:a>
                <a:a name="SCOPE" value="LOCAL"/>
                <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                <a:a name="IMPLEMENTATIONCONFIGCLASS"
                     type="IMPLEMENTATIONCONFIGCLASS">
                  <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                </a:a>
                  <a:a name="LABEL" value="Adc Timeout Value"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:33cfe352-1233-43a6-b6d2-54239cb433f1b"/>
                  <a:da name="DEFAULT" value="100000"/>
                  <a:da name="INVALID" type="Range">
                    <a:tst expr="&lt;=4294967295" />
                    <a:tst expr="&gt;=0" />
                  </a:da>
                </v:var>

                <!-- @implements AdcIpDevErrorDetect_Object -->
                <v:var name="AdcIpDevErrorDetect" type="BOOLEAN">
                  <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>This parameter Enables / Disables development error detection for Adc IPL module.
                        </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc IPL Module Dev Error Detect"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false" />
                  <a:a name="UUID" value="ECUC:8436de9b-c7e1-4720-9e80-155e3870a2ab" />
                  <a:da name="DEFAULT" value="false" />
                </v:var>

                <!-- @implements PdbIpDevErrorDetect_Object -->
                <v:var name="PdbIpDevErrorDetect" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>This parameter Enables / Disables development error detection for Pdb.
                          </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Pdb Dev Error Detect"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false" />
                  <a:a name="UUID" value="ECUC:8436de9b-c7e1-4730-9e80-145e3870a2ab" />
                  <a:da name="DEFAULT" value="false" />
                </v:var>

                <!-- This node is required by Autosar but not supported on this platform -->
                <!-- @implements AdcMulticoreSupport_Object -->
                <v:var name="AdcMulticoreSupport" type="BOOLEAN">
                  <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>This parameter globally enables the possibility to support multicore. If this parameter is enabled, at least one EcucPartition needs to be defined (in all variants).<br>
                  <h1>Note</h1>This is not supported on this platform.
                        </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Multicore Support"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false" />
                  <a:a name="UUID" value="ECUC:8436de9b-c7e1-4720-9e80-145e3870a2ab" />
                  <a:da name="DEFAULT" value="false" />
                  <a:a name="READONLY" value="true"/>
                </v:var>

                <!-- CPR_RTD_00046.adc -->
                <!-- @implements AdcEnableGroupDependentChannelNames_Object -->
                <v:var name="AdcEnableGroupDependentChannelNames" type="BOOLEAN">
                  <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>This is used to generate ADC symbolic names, that depend also on the ADC group
                        to which each ADC channel is mapped. The generated symbolic name will be something
                        like:
                        #define "ADC_GroupName"_"ADC_ChannelName"  "Channel index value",
                        where "Channel index value" is the channel index in the current group.
                        Channel indexes in each group are generated to allow result buffer access by symbolic names.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Channel Indexes Symbolic Names"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false" />
                  <a:a name="UUID" value="ECUC:cf08470c-77d7-4326-a615-90a0e35c390f" />
                  <a:da name="DEFAULT" value="false"/>
                </v:var>

                <!-- AdcBypassAbortChainCheck -->
                <v:var name="AdcBypassAbortChainCheck" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Bypass the delay introduced to check if an aborted conversion chain has stopped.
                      This increases ADC driver performance at the cost of HW-SW coherency no longer being guaranteed.
                      The user must make sure he does not call an ADC service before the hardware reaches the correct state.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Bypass Abort Chain Check"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false" />
                  <a:a name="UUID" value="ECUC:b55a0f78-06d7-4d3c-91e5-ef1538b996ca" />
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="INVALID" type="XPath">
                    <a:tst expr="node:fallback(.,'true') = 'true' and node:fallback(../../AdcGeneral/AdcPriorityImplementation, 'ADC_PRIORITY_HW_SW') = 'ADC_PRIORITY_HW_SW'"
                    true="AdcBypassAbortChainCheck parameter can be true if and only if there is NO priority."/>
                    <a:tst expr="node:fallback(.,'true') = 'true' and node:fallback(../../AdcGeneral/AdcEnableQueuing, 'true') = 'true'"
                    true="AdcBypassAbortChainCheck parameter can be true if and only if there is NO queue."/>
                  </a:da>
                </v:var>

                <!-- @implements AdcConvTimeOnce_Object -->
                <v:var name="AdcConvTimeOnce" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>
                    <![CDATA[EN:<html><p> Implementation Specific Parameter.
                         Enable/Disable one time setting of the registers.
                         If Enabled, the setting of the conversion time registers will be done only once in Adc_Init() function
                        for the configured hardware unit.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Conversion Time Once"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:6d78d92b-c387-4656-ba8c-8113fdef7242"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:da name="INVALID" type="XPath">
                    <a:tst expr="(.= 'true') and (num:i(count(../../AdcConfigSet/AdcHwUnit/*)) > num:i(count(../../AdcConfigSet/AdcHwUnit/*/AdcNormalConvTimings)))"
                    true="AdcNormalConvTimings for all AdcHwUnits must be configured when Adc Conversion Time Once is enabled."/>
                  </a:da>
                </v:var>

                <!--  @implements AdcOptimizeOneShotHwTriggerConversions_Object  -->
                <v:var name="AdcOptimizeOneShotHwTriggerConversions" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>
                    <![CDATA[EN:<html><p> Implementation Specific Parameter.
                         Enable/Disable The Adc driver optimization for HW Triggered groups, OneShot, Single access.
                         If Enabled, other types of groups cannot be configured in ADC driver and the code for interrupt routine / Dma notification will be optimized for speed.
                         Also, all groups must have configured channels no greater than number of available SC1 register.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Optimize OneShot HwTrigger Conversions"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:6d78d92b-c387-4656-ba8c-8113fdef7243"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:da name="INVALID" type="XPath">
                    <a:tst expr="(.= 'true') and (../AdcOptimizeDmaStreamingGroups = 'true')"
                    true="AdcOptimizeDmaStreamingGroups and AdcOptimizeOneShotHwTriggerConversions cannot be enabled simultaneously"/>
                    <a:tst expr="(.= 'true') and (../../AdcGeneral/AdcEnableStartStopGroupApi = 'true')"
                    true="AdcEnableStartStopGroupApi and AdcOptimizeOneShotHwTriggerConversions cannot be enabled simultaneously"/>
                  </a:da>
                </v:var>

                <!-- CPR-MCAL-859.adc -->
                <!--  @implements AdcOptimizeDmaStreamingGroups_Object  -->
                <v:var name="AdcOptimizeDmaStreamingGroups" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v>
                    <![CDATA[EN:<html><p> Implementation Specific Parameter.
                                Enable/Disable The Adc driver enable Optimize DMA streaming groups for reducing the number of interrupts required for processing the conversions of Adc Groups that consist of one or more channels (depending on HW capabilities) and which are configured as ADC_ACCESS_MODE_STREAMING.
                                When this feature is enabled, only one interrupt will be raised after the completion of all stream conversions (as configured by AdcStreamingNumSamples parameter). An additional interrupt to be raised after half of the stream is converted shall also be configurable.
                                This feature is enabled if Adc Global Enable DMA Transfer from General/AutosarExt is also enabled.
                                Note:
                                    - SetChannel(), Enable/DisableChannel() and Optimize one-shot hardware trigger cannot be use concurrently with this feature.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Optimize DMA Streaming Groups"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:6d78d92b-c387-4656-ba8c-8113fdef7247"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:da name="INVALID" type="XPath">
                    <a:tst expr="(.= 'true') and (../AdcOptimizeOneShotHwTriggerConversions = 'true')"
                    true="AdcOptimizeDmaStreamingGroups and AdcOptimizeOneShotHwTriggerConversions cannot be enabled simultaneous."/>
                  </a:da>
                </v:var>

                <!-- AdcContinuousWithoutInterrupt -->
                <v:var name="AdcContinuousWithoutInterrupt" type="BOOLEAN">
                  <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>This parameter globally enables the possibility to configure Adc Continuous Group Without Interrupt.
                        This is an Implementation Specific Parameter.</p></html>]]></a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Continuous Group Without Interrupt"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false" />
                  <a:a name="UUID" value="ECUC:a96c8639-2d95-4d33-8b2a-059d614eb2bc" />
                  <a:da name="DEFAULT" value="false"/>
                </v:var>

                <!-- PR-MCAL-3233.adc -->
                <!-- AdcEnableChDisableChApi -->
                <v:var name="AdcEnableChDisableChApi" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>
                          Enable/disable the Autosar Extension implementation api(s) Adc_EnableChannel() and Adc_DisableChannel() in ADC driver.<br>
                          <h1>Note</h1>this feature is not implemented on this platform.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Enable/Disable Channels API"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:4f1d5462-9533-4d1c-a9d1-5f66a0a824af"/>
                  <a:da name="DEFAULT" value="false"/>
                  <a:da name="EDITABLE" value="false"/>
                </v:var>

                <!-- CPR_RTD_00328.adc -->
                <!-- AdcEnableInitialNotification_Object -->
                <v:var name="AdcEnableInitialNotification" type="BOOLEAN">
                <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>Enable/disable an extra notification to be called for each Adc Group conversion.
                          <h1>Note</h1>This feature is intended to be used together with Adc_SetChannel service. The initial notification can be used by the user application to call Adc_SetChannel API before ADC driver updates the hardware configuration for the next conversion.</p></html>]]>
                    </a:v>
                  </a:a>
                <a:a name="IMPLEMENTATIONCONFIGCLASS"
                    type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                </a:a>
                <a:a name="LABEL" value="Adc Initial Notification Capability"/>
                <a:a name="ORIGIN" value="NXP"/>
                <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                <a:a name="UUID" value="ECUC:e06b25fe-9949-46fe-b350-3deb0f8d5679"/>
                <a:da name="DEFAULT" value="false"/>
                <a:da name="EDITABLE" type="XPath" expr="node:fallback(../AdcEnableSetChannel,'false') = 'true'"/>
                <a:da name="INVALID" type="XPath">
                    <a:tst expr="(. = 'true') and (node:fallback(../AdcEnableSetChannel,'false') = 'false')"
                    true="AdcEnableInitialNotification can only be enabled if AdcEnableSetChannel is also enabled"/>
                </a:da>
                </v:var>

                <v:var name="AdcEnableDmaTransferMode" type="BOOLEAN">
                  <a:a name="DESC">
                  <a:v><![CDATA[EN:<html><p>This parameter globally enables the possibility to configure DMA transfer for ADC converted data. If this parameter is disabled then DMA handling code will be removed at pre-compile time and DMA transfer cannot be configure for any Adc unit in any variant. If this parameter is enabled then the DMA configuration code will not be removed.<br>
                  <h1>Note</h1>This is an Implementation Specific Parameter.
                        </p></html>]]></a:v>
                  </a:a>
                  <a:a name="SCOPE" value="LOCAL"/>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Global Enable DMA support"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false" />
                  <a:a name="UUID" value="ECUC:8436de9b-c7e1-4720-9e80-145e3870a2cb" />
                  <a:da name="DEFAULT" value="false" />
                  <a:da name="EDITABLE" value="true"/>
                  <!-- <a:a name="INVALID" type="XPath">
                     <a:tst expr="(. = 'true') and (../AdcEnableSetChannel = 'true')"
                           true="AdcEnableDmaTransferMode shouldn't be configured simultaneously with Adc_SetChannel because of the risk of modification DMA TCD size at runtime"/>
                  </a:a> -->
                </v:var>

                <!-- CPR-MCAL-825.adc -->
                <!--  @implements AdcEnableUserModeSupport_Object  -->
                <v:var name="AdcEnableUserModeSupport" type="BOOLEAN">
                    <a:a name="DESC">
                        <a:v>
                            <![CDATA[EN:<html>
                                When this parameter is enabled, the Adc module will adapt to run from User Mode, by configuring REG_PROT for ADC IPs <p/>
                                Note: The Adc driver code can be executed at any time from both supervisor and user mode.
                            </html>]]>
                        </a:v>
                    </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                    <a:a name="LABEL" value="Enable Adc User Mode Support"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:a name="UUID" value="ECUC:6d78d92b-c387-4656-ba8c-8113fdef7061"/>
                    <a:da name="DEFAULT" value="false"/>
                    <a:a name="ORIGIN" value="NXP"/>
                    <a:a name="EDITABLE" type="XPath" expr="(ecu:get(&apos;AdcAdcRegProtAvailable&apos;) = 'TRUE') or (ecu:get(&apos;AdcPdbRegProtAvailable&apos;) = 'TRUE') or (../AdcEnableSimSupplyMonitor = 'true') or (../AdcEnablePdbInterChannelBackToBackSupport = 'true')"/>
                </v:var>

                <v:var name="AdcEnableSimSupplyMonitor" type="BOOLEAN">
                    <a:a name="DESC">
                        <a:v>
                            <![CDATA[EN:<html>
                                When this parameter is enabled, the Adc module allows to use the internal channels on SIM. <p/>
                                Note: If Adc runs from User Mode, AdcEnableUserModeSupport must be enabled in order to configure SIM register.
                            </html>]]>
                        </a:v>
                    </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                    <a:a name="LABEL" value="Enable SIM Supply Monitoring Channels"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:a name="UUID" value="ECUC:29b2dea8-a253-450b-bfdc-bb26e4489190"/>
                    <a:da name="DEFAULT" value="false"/>
                    <a:a name="ORIGIN" value="NXP"/>
                </v:var>

                <v:var name="AdcEnablePdbInterChannelBackToBackSupport" type="BOOLEAN">
                    <a:a name="DESC">
                        <a:v>
                            <![CDATA[EN:<html>
                                When this parameter is enabled, PDB Inter-channel back to back feature can be configured in PdbHwUnit.
                                In this case, PDB CH0 and CH1 will be in back to back acknowledgement connections as a ring (E.g: PDB0 CH 0 pre-trigger 0 ->... -> PDB0 CH 0 pre-trigger 7 -> PDB0 CH 1 pre-trigger 0 -> .... -> PDB0 CH 1 pre-trigger 7 -> PDB0 CH 0 pre-trigger 0)
                                Note: If Pdb runs from User Mode, AdcEnableUserModeSupport must be enabled in order to configure SIM register.
                            </html>]]>
                        </a:v>
                    </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                    <a:a name="LABEL" value="Enable PDB Inter-channel Back To Back"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:a name="UUID" value="ECUC:29b2dea8-a253-450b-bfdc-bb26e4489191"/>
                    <a:da name="DEFAULT" value="false"/>
                    <a:a name="ORIGIN" value="NXP"/>
                    <a:a name="EDITABLE" type="XPath" expr="(ecu:get('Adc.Pdb.ChannelBackToBack') = 'TRUE')"/>
                </v:var>

                <!-- @implements AdcEnableSetChannel_Object -->
                <v:var name="AdcEnableSetChannel" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>
                          If this parameter has been configured to &quot;TRUE&quot;, the Autosar Extension function &quot;Adc_SetChannel()&quot;  shall be accessible, otherwise this function shall be removed from the code.
                          <h1>Note</h1>This is an Implementation Specific Parameter.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS" type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Set Channel API"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:00118f07-32be-429d-8b41-3f7dc39d1849"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>

                <!-- AdcEnableDualClockMode -->
                <v:var name="AdcEnableDualClockMode" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[<html><p>Adds/removes the Dual Clock mode service Adc_SetClockMode from the code.
                          Also it enables the Programming of Conversion Timing registers in Adc_SetClockMode.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Set Clock Mode API"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:100169f9-9894-40a7-ac10-a9b20a7a3222"/>
                  <a:da name="INVALID" type="XPath">
                    <a:tst expr="(.= 'true') and (../AdcConvTimeOnce = 'true') and (num:i(count(../../AdcConfigSet/AdcHwUnit/*)) > num:i(count(../../AdcConfigSet/AdcHwUnit/*/AdcAlternateConvTimings)))"
                    true="AdcAlternateConvTimings for all AdcHwUnits must be configured when Adc Conversion Time Once and Adc Set Clock Mode API are enabled."/>
                  </a:da>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>

                <!-- @implements AdcEnableCalibration_Object -->
                <v:var name="AdcEnableCalibration" type="BOOLEAN">
                  <a:a name="DESC">
                    <a:v><![CDATA[EN:<html><p>
                          If this parameter has been configured to &quot;TRUE&quot;, the Autosar Extension function &quot;Adc_Calibrate()&quot;  shall be accessible, otherwise this function shall be removed from the code.
                          <h1>Note</h1>This is an Implementation Specific Parameter.</p></html>]]>
                    </a:v>
                  </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                  <a:a name="LABEL" value="Adc Enable Calibration API"/>
                  <a:a name="ORIGIN" value="NXP"/>
                  <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                  <a:a name="UUID" value="ECUC:00118f07-32be-429d-8b41-3f7dc39d1848"/>
                  <a:da name="DEFAULT" value="false"/>
                </v:var>

                <!-- CPR_RTD_00508 type -->
                <!--  @implements AdcEnableReadRawDataApi_Object  -->
                <v:var name="AdcEnableReadRawDataApi" type="BOOLEAN">
                    <a:a name="DESC">
                        <a:v>
                            <![CDATA[EN:<html>
                                When this parameter is enabled, the Api for reading the raw result data from an ADC unit is available to use at runtime.
                            </html>]]>
                        </a:v>
                    </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                    <a:a name="LABEL" value="Adc Enable Raw Data Read Api"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:a name="UUID" value="ECUC:a8437e2c-860e-4fed-9d3f-a108d4948df3"/>
                    <a:da name="DEFAULT" value="false"/>
                    <a:a name="ORIGIN" value="NXP"/>
                    <a:a name="READONLY" value="false"/>
                </v:var>

                <!--  @implements AdcEnableGroupStreamingResultReorder_Object  -->
                <v:var name="AdcEnableGroupStreamingResultReorder" type="BOOLEAN">
                    <a:a name="DESC">
                        <a:v>
                            <![CDATA[EN:<html>
                                When this parameter is enabled, the adc results can be arranged as multiple sets of group result buffer if AdcStreamResultGroup is enabled for that selected group.
                                E.g: for a group with channels {CH1 CH5 CH7} the resulting stream buffer shall be:
                                { CH1, CH5, CH7, CH1, CH5, CH7, CH1, CH5, CH7}
                                instead of
                                { CH1, CH1, CH1, CH5, CH5, CH5, CH7, CH7, CH7} like supported by AUTOSAR standard.
                                Apply only for ADC_ACCESS_MODE_STREAMING Access Mode.
                            </html>]]>
                        </a:v>
                    </a:a>
                  <a:a name="POSTBUILDVARIANTVALUE" value="false"/>
                  <a:a name="IMPLEMENTATIONCONFIGCLASS"
                       type="IMPLEMENTATIONCONFIGCLASS">
                    <icc:v vclass="PreCompile">VariantPostBuild</icc:v>
                    <icc:v vclass="PreCompile">VariantPreCompile</icc:v>
                  </a:a>
                    <a:a name="LABEL" value="Adc Enable Group Streaming Results Reorder"/>
                    <a:a name="SYMBOLICNAMEVALUE" value="false"/>
                    <a:a name="UUID" value="ECUC:a1598h2c-123e-4fed-9d3f-d108d0408df3"/>
                    <a:da name="DEFAULT" value="false"/>
                    <a:a name="ORIGIN" value="NXP"/>
                    <a:a name="READONLY" value="false"/>
                </v:var>

              </v:ctr>

              <d:ref type="REFINED_MODULE_DEF" value="ASPath:/AUTOSAR/EcucDefs/Adc"/>
            </v:ctr>
          </d:chc>
          <d:chc name="Adc_EcuParameterDefinition"
                 type="AR-ELEMENT" value="ECU_PARAMETER_DEFINITION">
            <d:ctr type="AR-ELEMENT">
              <a:a name="UUID" value="ECUC:67590c1f-f952-4b87-b78c-94f327edc863"/>
              <a:a name="DEF"
                   value="ASPath:/AR_PACKAGE_SCHEMA/ECU_PARAMETER_DEFINITION"/>
              <d:lst name="MODULE_REF">
                <d:ref type="MODULE_REF" value="ASPath:/TS_T40D2M10I1R0/Adc"/>
              </d:lst>
            </d:ctr>
          </d:chc>
          <d:chc name="Adc_ModuleDescription"
                 type="AR-ELEMENT" value="BSW_MODULE_DESCRIPTION">
            <d:ctr type="AR-ELEMENT">
              <a:a name="DEF"
                   value="ASPath:/AR_PACKAGE_SCHEMA/BSW_MODULE_DESCRIPTION"/>
              <d:var name="MODULE_ID" type="INTEGER" >
                <a:a name="EDITABLE" value="false"/>
                <a:a name="IMPORTER_INFO" value="@DEF"/>
              </d:var>
              <d:ref type="RECOMMENDED_CONFIGURATION" >
                <a:a name="EDITABLE" value="false"/>
                <a:a name="IMPORTER_INFO" value="@DEF"/>
              </d:ref>
              <d:ref type="PRE_CONFIGURED_CONF" >
                <a:a name="EDITABLE" value="false"/>
                <a:a name="IMPORTER_INFO" value="@DEF"/>
              </d:ref>
              <d:ref type="VENDOR_SPECIFIC_MODULE_DEF"
                     value="ASPath:/TS_T40D2M10I1R0/Adc"/>
            </d:ctr>
          </d:chc>
        </d:lst>
      </d:ctr>
    </d:lst>
  </d:ctr>

</datamodel>
