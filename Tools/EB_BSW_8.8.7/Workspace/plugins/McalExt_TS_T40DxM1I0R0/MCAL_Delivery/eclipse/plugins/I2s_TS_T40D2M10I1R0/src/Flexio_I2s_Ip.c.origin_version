/*==================================================================================================
*   Project              : RTD AUTOSAR 4.4
*   Platform             : CORTEXM
*   Peripheral           : I2S
*   Dependencies         : none
*
*   Autosar Version      : 4.4.0
*   Autosar Revision     : ASR_REL_4_4_REV_0000
*   Autosar Conf.Variant :
*   SW Version           : 1.0.1
*   Build Version        : S32K1_RTD_1_0_1_D2202_ASR_REL_4_4_REV_0000_20220224
*
*   (c) Copyright 2020-2022 NXP Semiconductors
*   All Rights Reserved.
*
*   NXP Confidential. This software is owned or controlled by NXP and may only be
*   used strictly in accordance with the applicable license terms. By expressly
*   accepting such terms or by downloading, installing, activating and/or otherwise
*   using the software, you are agreeing that you have read, and that you agree to
*   comply with and are bound by, such license terms. If you do not agree to be
*   bound by the applicable license terms, then you may not retain, install,
*   activate or otherwise use the software.
==================================================================================================*/

/**
*   @file
*
*   @addtogroup flexio_i2s_ip FLEXIO_I2S IPL
*   @{
*/

#ifdef __cplusplus
extern "C"{
#endif


/*==================================================================================================
*                                          INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/

#include "Flexio_I2s_Ip.h"
#include "Flexio_I2s_Ip_HwAccess.h"
#include "OsIf.h"
#include "Devassert.h"

/*==================================================================================================
*                                 SOURCE FILE VERSION INFORMATION
==================================================================================================*/
#define FLEXIO_I2S_IP_VENDOR_ID_C                    43
#define FLEXIO_I2S_IP_AR_RELEASE_MAJOR_VERSION_C     4
#define FLEXIO_I2S_IP_AR_RELEASE_MINOR_VERSION_C     4
#define FLEXIO_I2S_IP_AR_RELEASE_REVISION_VERSION_C  0
#define FLEXIO_I2S_IP_SW_MAJOR_VERSION_C             1
#define FLEXIO_I2S_IP_SW_MINOR_VERSION_C             0
#define FLEXIO_I2S_IP_SW_PATCH_VERSION_C             1

/*==================================================================================================
*                                       FILE VERSION CHECKS
==================================================================================================*/

/*==================================================================================================
*                           LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
==================================================================================================*/

/*==================================================================================================
*                                          LOCAL MACROS
==================================================================================================*/
#if (STD_ON == FLEXIO_I2S_IP_ENABLE)

/* Constraints used for baud rate computation */
#define FLEXIO_I2S_IP_DIVIDER_MIN_VALUE_U32  1
#define FLEXIO_I2S_IP_DIVIDER_MAX_VALUE_U32  0xFF

    /* Shifters/Timers used for I2S simulation The parameter x represents the
       ResourceIndex value for the current driver Instance */
#define TX_SHIFTER(x)           (x)
#define RX_SHIFTER(x)           (uint8)((x) + 1U)
#define SCK_TIMER(x)            (x)
#define WS_TIMER(x)             (uint8)((x) + 1U)
#define WS_TIMER_RISING_BLK(x)  (uint8)((x) + 2U)

/*==================================================================================================
*                                         LOCAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                         LOCAL VARIABLES
==================================================================================================*/
#define I2S_START_SEC_VAR_CLEARED_UNSPECIFIED
#include "I2s_MemMap.h"

#if(FLEXIO_I2S_IP_NUMBER_OF_MASTER_CHANNEL != 0U)
Flexio_I2s_Ip_MasterStateType Flexio_I2s_Ip_MasterState[FLEXIO_I2S_IP_NUMBER_OF_MASTER_CHANNEL];
#endif

#if(FLEXIO_I2S_IP_NUMBER_OF_SLAVE_CHANNEL != 0U)
Flexio_I2s_Ip_SlaveStateType Flexio_I2s_Ip_SlaveState[FLEXIO_I2S_IP_NUMBER_OF_SLAVE_CHANNEL];
#endif

/* Pointer to runtime Master/Slave state structures.*/
Flexio_I2s_Ip_MasterStateType * Flexio_I2s_Ip_pxState[FLEXIO_I2S_IP_INSTANCE_COUNT][FLEXIO_I2S_IP_MAX_CHANNEL_COUNT];

#define I2S_STOP_SEC_VAR_CLEARED_UNSPECIFIED
#include "I2s_MemMap.h"

#define I2S_START_SEC_CONST_UNSPECIFIED
#include "I2s_MemMap.h"
static FLEXIO_Type * const Flexio_I2s_Ip_pBaseAddr[FLEXIO_I2S_IP_INSTANCE_COUNT] = IP_FLEXIO_BASE_PTRS;

#define I2S_STOP_SEC_CONST_UNSPECIFIED
#include "I2s_MemMap.h"

#define I2S_START_SEC_VAR_CLEARED_8
#include "I2s_MemMap.h"
/* I2s channel init status*/
static uint8 Flexio_I2s_Ip_au8ChannelStatus[FEATURE_FLEXIO_MAX_CHANNEL_COUNT];

#define I2S_STOP_SEC_VAR_CLEARED_8
#include "I2s_MemMap.h"


#define I2S_START_SEC_CODE
#include "I2s_MemMap.h"
/*==================================================================================================
*                                        GLOBAL CONSTANTS
==================================================================================================*/

/*==================================================================================================
*                                        GLOBAL VARIABLES
==================================================================================================*/

/*==================================================================================================
*                                    LOCAL FUNCTION PROTOTYPES
==================================================================================================*/

/*==================================================================================================
*                                         LOCAL FUNCTIONS
==================================================================================================*/

/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_ComputeByteWidth
 * Description   : Computes the baud rate divider for a target baud rate
 *
 *END**************************************************************************/
static uint8 Flexio_I2s_Ip_ComputeByteWidth(uint8 bitsWidth)
{
    uint8 byteWidth;

    if (bitsWidth <= 8U)
    {
        byteWidth = 1U;
    }
    else if (bitsWidth <= 16U)
    {
        byteWidth = 2U;
    }
    else
    {
        byteWidth = 4U;
    }

    return byteWidth;
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterConfigure
 * Description   : configures the FLEXIO module as I2S Master
 *
 *END**************************************************************************/
static void Flexio_I2s_Ip_MasterConfigure(Flexio_I2s_Ip_MasterStateType *Master,
                                           const Flexio_I2s_Ip_MasterConfigType * ConfigPtr)
{
    FLEXIO_Type *baseAddr;
    uint16 divider;
    uint16 bits;
    uint8 ResourceIndex;    /* Index of first used internal resource Instance (shifter and timer) */

    baseAddr = Flexio_I2s_Ip_pBaseAddr[Master->FlexioCommon.Instance];
    ResourceIndex = Master->FlexioCommon.ResourceIndex;

    bits = ConfigPtr->bitsWidth;
    divider = ConfigPtr->DividerValue;

    /* Configure tx shifter */
    Flexio_I2s_Ip_SetShifterConfig(baseAddr,
                                TX_SHIFTER(ResourceIndex),
                                FLEXIO_SHIFTER_START_BIT_DISABLED_SH,
                                FLEXIO_SHIFTER_STOP_BIT_DISABLED,
                                FLEXIO_SHIFTER_SOURCE_PIN);
    Flexio_I2s_Ip_SetShifterControl(baseAddr,
                                 TX_SHIFTER(ResourceIndex),
                                 FLEXIO_SHIFTER_MODE_DISABLED,
                                 ConfigPtr->txPin,             /* output on tx pin */
                                 FLEXIO_PIN_POLARITY_HIGH,
                                 FLEXIO_PIN_CONFIG_DISABLED,       /* disable for now, will enable on transmit */
                                 SCK_TIMER(ResourceIndex),         /* use clock timer to drive the shifter */
                                 FLEXIO_TIMER_POLARITY_POSEDGE);

    /* Configure rx shifter */
    Flexio_I2s_Ip_SetShifterConfig(baseAddr,
                                RX_SHIFTER(ResourceIndex),
                                FLEXIO_SHIFTER_START_BIT_DISABLED,
                                FLEXIO_SHIFTER_STOP_BIT_DISABLED,
                                FLEXIO_SHIFTER_SOURCE_PIN);
    Flexio_I2s_Ip_SetShifterControl(baseAddr,
                                 RX_SHIFTER(ResourceIndex),
                                 FLEXIO_SHIFTER_MODE_DISABLED,
                                 ConfigPtr->rxPin,                    /* output to rx pin */
                                 FLEXIO_PIN_POLARITY_HIGH,
                                 FLEXIO_PIN_CONFIG_DISABLED,
                                 SCK_TIMER(ResourceIndex),     /* use control timer to drive the shifter */
                                 FLEXIO_TIMER_POLARITY_NEGEDGE);

    /* Configure SCK timer */
    Flexio_I2s_Ip_SetTimerCompare(baseAddr, SCK_TIMER(ResourceIndex), (uint16)((uint16)(((uint16)(bits << 1U) - 1U) << 8U) + divider));
    Flexio_I2s_Ip_SetTimerConfig(baseAddr,
                              SCK_TIMER(ResourceIndex),
                              FLEXIO_TIMER_START_BIT_ENABLED,
                              FLEXIO_TIMER_STOP_BIT_DISABLED,
                              FLEXIO_TIMER_ENABLE_TRG_HIGH,         /* enable when Tx data is available */
                              FLEXIO_TIMER_DISABLE_NEVER,
                              FLEXIO_TIMER_RESET_NEVER,
                              FLEXIO_TIMER_DECREMENT_CLK_SHIFT_TMR, /* decrement on FlexIO clock */
                              FLEXIO_TIMER_INITOUT_ONE);
    Flexio_I2s_Ip_SetTimerControl(baseAddr,
                               SCK_TIMER(ResourceIndex),
                               (uint8)((uint8)(TX_SHIFTER(ResourceIndex) << 2U) + 1U),  /* trigger on tx shifter status flag */
                               FLEXIO_TRIGGER_POLARITY_LOW,
                               FLEXIO_TRIGGER_SOURCE_INTERNAL,
                               ConfigPtr->sckPin,                 /* output on SCK pin */
                               FLEXIO_PIN_POLARITY_LOW,
                               FLEXIO_PIN_CONFIG_OUTPUT,              /* enable output */
                               FLEXIO_TIMER_MODE_DISABLED);

    /* Configure WS timer */

    Flexio_I2s_Ip_SetTimerCompare(baseAddr, WS_TIMER(ResourceIndex), (uint16)((bits * ((divider + 1U) * 2U)) - 1U));
    Flexio_I2s_Ip_SetTimerConfig(baseAddr,
                              WS_TIMER(ResourceIndex),
                              FLEXIO_TIMER_START_BIT_DISABLED,
                              FLEXIO_TIMER_STOP_BIT_DISABLED,
                              FLEXIO_TIMER_ENABLE_TIM_ENABLE,       /* enable when SCK timer is enabled */
                              FLEXIO_TIMER_DISABLE_NEVER,
                              FLEXIO_TIMER_RESET_NEVER,
                              FLEXIO_TIMER_DECREMENT_CLK_SHIFT_TMR, /* decrement on FlexIO clock */
                              FLEXIO_TIMER_INITOUT_ONE);
    Flexio_I2s_Ip_SetTimerControl(baseAddr,
                               WS_TIMER(ResourceIndex),
                               0U,                                  /* trigger not used */
                               FLEXIO_TRIGGER_POLARITY_HIGH,
                               FLEXIO_TRIGGER_SOURCE_EXTERNAL,
                               ConfigPtr->wsPin,                /* output on WS pin */
                               FLEXIO_PIN_POLARITY_LOW,
                               FLEXIO_PIN_CONFIG_OUTPUT,            /* enable output */
                               FLEXIO_TIMER_MODE_DISABLED);
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_SlaveConfigure
 * Description   : configures the FLEXIO module as I2S Slave
 *
 *END**************************************************************************/
static void Flexio_I2s_Ip_SlaveConfigure(const Flexio_I2s_Ip_SlaveStateType *Slave,
                                          const Flexio_I2s_Ip_SlaveConfigType * ConfigPtr)
{
    FLEXIO_Type *baseAddr;
    uint16 bits;
    uint8 ResourceIndex;    /* Index of first used internal resource Instance (shifter and timer) */

    baseAddr = Flexio_I2s_Ip_pBaseAddr[Slave->FlexioCommon.Instance];
    ResourceIndex = Slave->FlexioCommon.ResourceIndex;
    bits = ConfigPtr->bitsWidth;


    /* Configure tx shifter */
    Flexio_I2s_Ip_SetShifterConfig(baseAddr,
                                TX_SHIFTER(ResourceIndex),
                                FLEXIO_SHIFTER_START_BIT_DISABLED,
                                FLEXIO_SHIFTER_STOP_BIT_DISABLED,
                                FLEXIO_SHIFTER_SOURCE_PIN);
    Flexio_I2s_Ip_SetShifterControl(baseAddr,
                                 TX_SHIFTER(ResourceIndex),
                                 FLEXIO_SHIFTER_MODE_DISABLED,
                                 ConfigPtr->txPin,             /* output on tx pin */
                                 FLEXIO_PIN_POLARITY_HIGH,
                                 FLEXIO_PIN_CONFIG_DISABLED,       /* disable for now, will enable on transmit */
                                 WS_TIMER(ResourceIndex),          /* use clock timer to drive the shifter */
                                 FLEXIO_TIMER_POLARITY_POSEDGE);

    /* Configure rx shifter */
    Flexio_I2s_Ip_SetShifterConfig(baseAddr,
                                RX_SHIFTER(ResourceIndex),
                                FLEXIO_SHIFTER_START_BIT_DISABLED,
                                FLEXIO_SHIFTER_STOP_BIT_DISABLED,
                                FLEXIO_SHIFTER_SOURCE_PIN);
    Flexio_I2s_Ip_SetShifterControl(baseAddr,
                                 RX_SHIFTER(ResourceIndex),
                                 FLEXIO_SHIFTER_MODE_DISABLED,
                                 ConfigPtr->rxPin,                    /* output to rx pin */
                                 FLEXIO_PIN_POLARITY_HIGH,
                                 FLEXIO_PIN_CONFIG_DISABLED,
                                 WS_TIMER(ResourceIndex),     /* use control timer to drive the shifter */
                                 FLEXIO_TIMER_POLARITY_NEGEDGE);

    /* Configure SCK timer */
    Flexio_I2s_Ip_SetTimerCompare(baseAddr, SCK_TIMER(ResourceIndex), (uint16)((uint16)(bits << 2U) - 3U));
    Flexio_I2s_Ip_SetTimerConfig(baseAddr,
                              SCK_TIMER(ResourceIndex),
                              FLEXIO_TIMER_START_BIT_DISABLED,
                              FLEXIO_TIMER_STOP_BIT_DISABLED,
                              FLEXIO_TIMER_ENABLE_PIN_POSEDGE,      /* enable on WS positive edge */
                              FLEXIO_TIMER_DISABLE_TIM_CMP,
                              FLEXIO_TIMER_RESET_NEVER,
                              FLEXIO_TIMER_DECREMENT_TRG_SHIFT_TRG, /* decrement on SCK input  */
                              FLEXIO_TIMER_INITOUT_ONE);
    Flexio_I2s_Ip_SetTimerControl(baseAddr,
                               SCK_TIMER(ResourceIndex),
                               (uint8)(ConfigPtr->sckPin << 1U), /* trigger on SCK pin */
                               FLEXIO_TRIGGER_POLARITY_LOW,
                               FLEXIO_TRIGGER_SOURCE_INTERNAL,
                               ConfigPtr->wsPin,                 /* use WS input pin */
                               FLEXIO_PIN_POLARITY_LOW,
                               FLEXIO_PIN_CONFIG_DISABLED,
                               FLEXIO_TIMER_MODE_DISABLED);

    /* Configure WS_TIMER_RISING_BLK timer */
    Flexio_I2s_Ip_SetTimerCompare(baseAddr, WS_TIMER_RISING_BLK(ResourceIndex), (uint16)((uint16)(bits << 2U) - 4U));
    Flexio_I2s_Ip_SetTimerConfig(baseAddr,
                              WS_TIMER_RISING_BLK(ResourceIndex),
                              FLEXIO_TIMER_START_BIT_DISABLED,
                              FLEXIO_TIMER_STOP_BIT_DISABLED,
                              FLEXIO_TIMER_ENABLE_PIN_POSEDGE_TRG_HIGH,
                              FLEXIO_TIMER_DISABLE_TRG,
                              FLEXIO_TIMER_RESET_NEVER,
                              FLEXIO_TIMER_DECREMENT_PIN_SHIFT_PIN,
                              FLEXIO_TIMER_INITOUT_ONE);
    Flexio_I2s_Ip_SetTimerControl(baseAddr,
                               WS_TIMER_RISING_BLK(ResourceIndex),
                               (uint8)((uint8)(SCK_TIMER(ResourceIndex) << 2U) + 3U), /* SCK timer trigger output */
                               FLEXIO_TRIGGER_POLARITY_HIGH,
                               FLEXIO_TRIGGER_SOURCE_INTERNAL,
                               ConfigPtr->sckPin,               /* SCK input pin */
                               FLEXIO_PIN_POLARITY_HIGH,
                               FLEXIO_PIN_CONFIG_DISABLED,
                               FLEXIO_TIMER_MODE_DISABLED);

    /* Configure WS timer */
    Flexio_I2s_Ip_SetTimerCompare(baseAddr, WS_TIMER(ResourceIndex), (uint16)((uint16)(bits << 1U) - 1U));
    Flexio_I2s_Ip_SetTimerConfig(baseAddr,
                              WS_TIMER(ResourceIndex),
                              FLEXIO_TIMER_START_BIT_DISABLED,
                              FLEXIO_TIMER_STOP_BIT_DISABLED,
                              FLEXIO_TIMER_ENABLE_PIN_POSEDGE_TRG_HIGH, /* enable at first falling edge after first rising edge of bclk */
                              FLEXIO_TIMER_DISABLE_TIM_CMP_TRG_LOW,
                              FLEXIO_TIMER_RESET_NEVER,
                              FLEXIO_TIMER_DECREMENT_PIN_SHIFT_PIN,
                              FLEXIO_TIMER_INITOUT_ONE);
    Flexio_I2s_Ip_SetTimerControl(baseAddr,
                               WS_TIMER(ResourceIndex),
                               (uint8)((uint8)(WS_TIMER_RISING_BLK(ResourceIndex) << 2U) + 3U), /* WS_TIMER_RISING_BLK timer trigger output */
                               FLEXIO_TRIGGER_POLARITY_HIGH,
                               FLEXIO_TRIGGER_SOURCE_INTERNAL,
                               ConfigPtr->sckPin,               /* SCK input pin */
                               FLEXIO_PIN_POLARITY_LOW,
                               FLEXIO_PIN_CONFIG_DISABLED,          /* enable output */
                               FLEXIO_TIMER_MODE_DISABLED);
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterEndTransfer
 * Description   : End the current transfer
 *
 *END**************************************************************************/
static void Flexio_I2s_Ip_MasterEndTransfer(Flexio_I2s_Ip_MasterStateType *Master)
{
    FLEXIO_Type *baseAddr;
    uint8 ResourceIndex;    /* Index of first used internal resource Instance (shifter and timer) */

    baseAddr = Flexio_I2s_Ip_pBaseAddr[Master->FlexioCommon.Instance];
    ResourceIndex = Master->FlexioCommon.ResourceIndex;

    /* Disable transfer engine */
    switch (Master->driverType)
    {
        case FLEXIO_I2S_IP_DRIVER_TYPE_INTERRUPT:
            /* Disable interrupts for Rx and Tx shifters */
            Flexio_Mcl_Ip_SetShifterInterrupt(baseAddr,
                                 (uint8)((1U << TX_SHIFTER(ResourceIndex)) | (1U << RX_SHIFTER(ResourceIndex))),
                                 FALSE);
            Flexio_Mcl_Ip_SetShifterErrorInterrupt(baseAddr,
                                 (uint8)((1U << TX_SHIFTER(ResourceIndex)) | (1U << RX_SHIFTER(ResourceIndex))),
                                 FALSE);
            break;
        case FLEXIO_I2S_IP_DRIVER_TYPE_POLLING:
            /* Nothing to do here */
            break;
#if (STD_ON == FLEXIO_I2S_IP_DMA_FEATURE_AVAILABLE)
        case FLEXIO_I2S_IP_DRIVER_TYPE_DMA:
            /* Stop DMA channels */
            /* TODO: Add DMA Support */
            break;
#endif
        default:
            /* Impossible type - do nothing */
            break;
    }

    Master->driverIdle = TRUE;
    Master->txData = NULL_PTR;
    Master->rxData = NULL_PTR;
    Master->txRemainingBytes = 0U;
    Master->rxRemainingBytes = 0U;
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterEnableTransfer
 * Description   : Enables timers and shifters to start a transfer
 *
 *END**************************************************************************/
static void Flexio_I2s_Ip_MasterEnableTransfer(Flexio_I2s_Ip_MasterStateType *Master)
{
    FLEXIO_Type *baseAddr;
    uint8 ResourceIndex;    /* Index of first used internal resource Instance (shifter and timer) */

    ResourceIndex = Master->FlexioCommon.ResourceIndex;
    baseAddr = Flexio_I2s_Ip_pBaseAddr[Master->FlexioCommon.Instance];

    /* enable timers and shifters */
    Flexio_I2s_Ip_SetShifterMode(baseAddr, TX_SHIFTER(ResourceIndex), FLEXIO_SHIFTER_MODE_TRANSMIT);
    Flexio_I2s_Ip_SetShifterMode(baseAddr, RX_SHIFTER(ResourceIndex), FLEXIO_SHIFTER_MODE_RECEIVE);
    if (Master->Master)
    {
        Flexio_I2s_Ip_SetTimerMode(baseAddr, SCK_TIMER(ResourceIndex), FLEXIO_TIMER_MODE_8BIT_BAUD);
    }
    else
    {
        Flexio_I2s_Ip_SetTimerMode(baseAddr, SCK_TIMER(ResourceIndex), FLEXIO_TIMER_MODE_16BIT);
        Flexio_I2s_Ip_SetTimerMode(baseAddr, WS_TIMER_RISING_BLK(ResourceIndex), FLEXIO_TIMER_MODE_16BIT);
    }
    Flexio_I2s_Ip_SetTimerMode(baseAddr, WS_TIMER(ResourceIndex), FLEXIO_TIMER_MODE_16BIT);
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterStopTransfer
 * Description   : Stops the current transfer
 *
 *END**************************************************************************/
static void Flexio_I2s_Ip_MasterStopTransfer(Flexio_I2s_Ip_MasterStateType *Master)
{
    FLEXIO_Type *baseAddr;
    uint8 ResourceIndex;    /* Index of first used internal resource Instance (shifter and timer) */

    ResourceIndex = Master->FlexioCommon.ResourceIndex;
    baseAddr = Flexio_I2s_Ip_pBaseAddr[Master->FlexioCommon.Instance];

    /* disable timers and shifters */
    Flexio_I2s_Ip_SetShifterMode(baseAddr, TX_SHIFTER(ResourceIndex), FLEXIO_SHIFTER_MODE_DISABLED);
    Flexio_I2s_Ip_SetShifterMode(baseAddr, RX_SHIFTER(ResourceIndex), FLEXIO_SHIFTER_MODE_DISABLED);
    Flexio_I2s_Ip_SetTimerMode(baseAddr, SCK_TIMER(ResourceIndex), FLEXIO_TIMER_MODE_DISABLED);
    if (!Master->Master)
    {
        Flexio_I2s_Ip_SetTimerMode(baseAddr, WS_TIMER_RISING_BLK(ResourceIndex), FLEXIO_TIMER_MODE_DISABLED);
    }
    Flexio_I2s_Ip_SetTimerMode(baseAddr, WS_TIMER(ResourceIndex), FLEXIO_TIMER_MODE_DISABLED);
    /* Disable pin output */
    Flexio_I2s_Ip_SetShifterPinConfig(baseAddr, TX_SHIFTER(ResourceIndex), FLEXIO_PIN_CONFIG_DISABLED);

    /* clear any leftover error flags */
    Flexio_Mcl_Ip_ClearShifterErrorStatus(baseAddr, TX_SHIFTER(ResourceIndex));
    Flexio_Mcl_Ip_ClearShifterErrorStatus(baseAddr, RX_SHIFTER(ResourceIndex));
    /* discard any leftover rx. data */
    Flexio_Mcl_Ip_ClearShifterStatus(baseAddr, RX_SHIFTER(ResourceIndex));

    /* end the transfer */
    Flexio_I2s_Ip_MasterEndTransfer(Master);
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterWaitTransferEnd
 * Description   : waits for the end of a blocking transfer
 *
 *END**************************************************************************/
static Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_MasterWaitTransferEnd(Flexio_I2s_Ip_MasterStateType *Master, uint32 Timeout)
{
    uint32 CurrentTicks = 0u;
    uint32 ElapsedTicks = 0u;
    uint32 TimeoutTicks = OsIf_MicrosToTicks(Timeout, FLEXIO_I2S_IP_TIMEOUT_TYPE);
    Flexio_I2s_Ip_StatusType osifError = FLEXIO_I2S_IP_STATUS_SUCCESS;

    switch (Master->driverType)
    {
        case FLEXIO_I2S_IP_DRIVER_TYPE_INTERRUPT:
            /* Wait for transfer to be completed by the IRQ */
            /* Add OSIF wait */
            break;
        case FLEXIO_I2S_IP_DRIVER_TYPE_POLLING:
            CurrentTicks = OsIf_GetCounter(FLEXIO_I2S_IP_TIMEOUT_TYPE);
            /* Call Flexio_I2s_Ip_MasterGetStatus() to do the transfer */
            do
            {
                ElapsedTicks += OsIf_GetElapsed(&CurrentTicks, FLEXIO_I2S_IP_TIMEOUT_TYPE);
            } while ((Flexio_I2s_Ip_MasterGetStatus(Master->FlexioCommon.Instance, (uint8)Master->FlexioCommon.ResourceIndex/2U, NULL_PTR) == FLEXIO_I2S_IP_STATUS_BUSY) && (ElapsedTicks < TimeoutTicks));

            if(ElapsedTicks >= TimeoutTicks)
            {
                osifError = FLEXIO_I2S_IP_STATUS_TIMEOUT;
            }
            break;
#if (STD_ON == FLEXIO_I2S_IP_DMA_FEATURE_AVAILABLE)
        case FLEXIO_I2S_IP_DRIVER_TYPE_DMA:
           /* Add OSIF wait */
            break;
#endif
        default:
            /* Impossible type - do nothing */
            break;
    }

    /* blocking transfer is over */
    Master->blocking = FALSE;
    if (osifError == FLEXIO_I2S_IP_STATUS_TIMEOUT)
    {
        /* abort current transfer */
        Master->status = FLEXIO_I2S_IP_STATUS_TIMEOUT;
        Flexio_I2s_Ip_MasterStopTransfer(Master);
    }

    return Master->status;
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_ReadData
 * Description   : reads data received by the module
 *
 *END**************************************************************************/
static void Flexio_I2s_Ip_ReadData(Flexio_I2s_Ip_MasterStateType *Master)
{
    const FLEXIO_Type *baseAddr;
    uint32 data;
    uint8 ResourceIndex;    /* Index of first used internal resource Instance (shifter and timer) */

    baseAddr = Flexio_I2s_Ip_pBaseAddr[Master->FlexioCommon.Instance];
    ResourceIndex = Master->FlexioCommon.ResourceIndex;

    /* Read data from shifter buffer */
    data = Flexio_I2s_Ip_ReadShifterBuffer(baseAddr, RX_SHIFTER(ResourceIndex), FLEXIO_SHIFTER_RW_MODE_BIT_SWAP);

    if (Master->rxRemainingBytes > 0U)
    {
        if (Master->rxData != NULL_PTR)
        {
            switch (Master->byteWidth)
            {
            case 1U:
                *(uint8 *)Master->rxData = (uint8)data;
                break;
            case 2U:
                *(uint16 *)Master->rxData = (uint16)data;
                break;
            default:
                *(uint32 *)Master->rxData = (uint32)data;
                break;
            }
            /* Update rx buffer pointer */
            Master->rxData = &Master->rxData[Master->byteWidth];
        }
        /* Update remaining bytes count even if buffer is null */
        Master->rxRemainingBytes -= (uint32)(Master->byteWidth);
    }
    else
    {
        /* No data to receive, just ignore the read data */
    }
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_WriteData
 * Description   : writes data to be transmitted by the module
 *
 *END**************************************************************************/
static void Flexio_I2s_Ip_WriteData(Flexio_I2s_Ip_MasterStateType *Master)
{
    FLEXIO_Type *baseAddr;
    uint32 data;
    uint8 ResourceIndex;    /* Index of first used internal resource Instance (shifter and timer) */

    baseAddr = Flexio_I2s_Ip_pBaseAddr[Master->FlexioCommon.Instance];
    ResourceIndex = Master->FlexioCommon.ResourceIndex;

    if (Master->txRemainingBytes == 0U)
    {
        /* Done transmitting */
        return;
    }

    /* Read data from user buffer and update tx buffer pointer and remaining bytes count */
    switch (Master->byteWidth)
    {
    case 1U:
        data = (uint32)(*(const uint8 *)Master->txData);
        break;
    case 2U:
        data = (uint32)(*(const uint16 *)Master->txData);
        break;
    default:
        data = (uint32)(*(const uint32 *)Master->txData);
        break;
    }
    Master->txData = &Master->txData[Master->byteWidth];
    Master->txRemainingBytes -= (uint32)(Master->byteWidth);

    /* Write data to shifter buffer */
    /* Shift data before bit-swapping it to get the relevant bits in the lower part of the shifter */
    data <<= 32U - (uint32)(Master->bitsWidth);
    Flexio_I2s_Ip_WriteShifterBuffer(baseAddr, TX_SHIFTER(ResourceIndex), data, FLEXIO_SHIFTER_RW_MODE_BIT_SWAP);
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterCheckStatus
 * Description   : Check status of the I2S transfer. This function can be
 *                 called either in an interrupt routine or directly in polling
 *                 mode to advance the I2S transfer.
 *
 *END**************************************************************************/
static void Flexio_I2s_Ip_MasterCheckStatus(uint8 Instance, uint8 Channel)
{
    Flexio_I2s_Ip_MasterStateType * Master = Flexio_I2s_Ip_pxState[Instance][Channel];
    FLEXIO_Type *baseAddr;
    uint8 ResourceIndex;    /* Index of first used internal resource Instance (shifter and timer) */

    baseAddr = Flexio_I2s_Ip_pBaseAddr[Master->FlexioCommon.Instance];
    ResourceIndex = Master->FlexioCommon.ResourceIndex;

    /* Check for errors */
    if (Master->txData != NULL_PTR)
    {
        if(Flexio_Mcl_Ip_GetShifterErrorStatus(baseAddr, TX_SHIFTER(ResourceIndex)))
        {
            Master->status = FLEXIO_I2S_IP_STATUS_TX_UNDERRUN;
            Flexio_Mcl_Ip_ClearShifterErrorStatus(baseAddr, TX_SHIFTER(ResourceIndex));
            /* Continue processing events */
        }
    }
    if (Master->rxData != NULL_PTR)
    {
        if (Flexio_Mcl_Ip_GetShifterErrorStatus(baseAddr, RX_SHIFTER(ResourceIndex)))
        {
            Master->status = FLEXIO_I2S_IP_STATUS_RX_OVERRUN;
            Flexio_Mcl_Ip_ClearShifterErrorStatus(baseAddr, RX_SHIFTER(ResourceIndex));
            /* Continue processing events */
        }
    }
    /* Check if data was received */
    if (Flexio_Mcl_Ip_GetShifterStatus(baseAddr, RX_SHIFTER(ResourceIndex)))
    {
        Flexio_I2s_Ip_ReadData(Master);
        if ((Master->rxData != NULL_PTR) && (Master->rxRemainingBytes == 0U))
        {
            /* Out of rx space, call callback to allow user to provide a new buffer */
            if (Master->callback != NULL_PTR)
            {
                Master->callback(FLEXIO_I2S_IP_EVENT_RX_FULL, Master->callbackParam);
            }
        }
    }
    /* Check if transmitter needs more data */
    if (Master->txData != NULL_PTR)
    {
        if (Flexio_Mcl_Ip_GetShifterStatus(baseAddr, TX_SHIFTER(ResourceIndex)))
        {
            Flexio_I2s_Ip_WriteData(Master);
            if (Master->txRemainingBytes == 0U)
            {
                Master->txData = NULL_PTR;
                /* Out of data, call callback to allow user to provide a new buffer */
                if (Master->callback != NULL_PTR)
                {
                    Master->callback(FLEXIO_I2S_IP_EVENT_TX_EMPTY, Master->callbackParam);
                }
                if ((Master->txRemainingBytes == 0U) && (Master->driverType == FLEXIO_I2S_IP_DRIVER_TYPE_INTERRUPT))
                {
                    /* Still no more data to transmit, transmission will stop */
                    /* disable tx interrupts */
                    Flexio_Mcl_Ip_SetShifterInterrupt(baseAddr, (uint8)(1U << TX_SHIFTER(ResourceIndex)), FALSE);
                    Flexio_Mcl_Ip_SetShifterErrorInterrupt(baseAddr, (uint8)(1U << TX_SHIFTER(ResourceIndex)), FALSE);
                    /* Enable rx interrupt to signal end of transfer */
                    Flexio_Mcl_Ip_SetShifterInterrupt(baseAddr, (uint8)(1U << RX_SHIFTER(ResourceIndex)), TRUE);
                }
            }
        }
    }

    /* Check if transfer is over */
    if (Master->rxRemainingBytes == 0U)
    {
        /* Record success if there was no error */
        if (Master->status == FLEXIO_I2S_IP_STATUS_BUSY)
        {
            Master->status = FLEXIO_I2S_IP_STATUS_SUCCESS;
        }
        /* End transfer */
        Flexio_I2s_Ip_MasterStopTransfer(Master);
        /* Call callback to announce the event to the user */
        if (Master->callback != NULL_PTR)
        {
            Master->callback(FLEXIO_I2S_IP_EVENT_END_TRANSFER, Master->callbackParam);
        }
    }
}

#if (STD_ON == FLEXIO_I2S_IP_DMA_FEATURE_AVAILABLE)

/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterEndDmaTxTransfer
 * Description   : function called at the end of a DMA Tx transfer
 *
 *END**************************************************************************/
/* TODO: Add DMA Support - prototype - static void Flexio_I2s_Ip_MasterEndDmaTxTransfer(void *stateStruct, edma_chn_Flexio_I2s_Ip_StatusType status) */


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterEndDmaRxTransfer
 * Description   : function called at the end of a DMA Tx transfer
 *
 *END**************************************************************************/
/* TODO: Add DMA Support - prototype - static void Flexio_I2s_Ip_MasterEndDmaRxTransfer(void *stateStruct, edma_chn_Flexio_I2s_Ip_StatusType status) */


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterComputeTxRegAddr
 * Description   : Computes the address of the register used for DMA tx transfer
 *
 *END**************************************************************************/
static uint32 Flexio_I2s_Ip_MasterComputeTxRegAddr(const Flexio_I2s_Ip_MasterStateType *Master)
{
    uint32 addr;
    const FLEXIO_Type *baseAddr;
    uint8 shifter;

    baseAddr = Flexio_I2s_Ip_pBaseAddr[Master->FlexioCommon.Instance];
    shifter = TX_SHIFTER(Master->FlexioCommon.ResourceIndex);
    addr = (uint32)(&(baseAddr->SHIFTBUFBIS[shifter])) + (sizeof(uint32) - Master->byteWidth);
    return addr;
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterComputeRxRegAddr
 * Description   : Computes the address of the register used for DMA rx transfer
 *
 *END**************************************************************************/
static uint32 Flexio_I2s_Ip_MasterComputeRxRegAddr(const Flexio_I2s_Ip_MasterStateType *Master)
{
    uint32 addr;
    const FLEXIO_Type *baseAddr;
    uint8 shifter;

    baseAddr = Flexio_I2s_Ip_pBaseAddr[Master->FlexioCommon.Instance];
    shifter = RX_SHIFTER(Master->FlexioCommon.ResourceIndex);
    addr = (uint32)(&(baseAddr->SHIFTBUFBIS[shifter]));
    return addr;
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterStartDmaTransfer
 * Description   : Starts a DMA transfer
 *
 *END**************************************************************************/

/*TODO: Add DMA support - add prototype static void Flexio_I2s_Ip_MasterStartDmaTransfer(Flexio_I2s_Ip_MasterStateType *Master) */

#endif /* #if (STD_ON == FLEXIO_I2S_IP_DMA_FEATURE_AVAILABLE) */

/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_ResourcesInit
 * Description   : Initializes the resources for the current driver
 *
 *END**************************************************************************/
static void Flexio_I2s_Ip_ResourcesInit(uint8 Instance,
                                        const Flexio_I2s_Ip_CommonStateType *Driver)
{
    uint8 Resource;
    uint8 ResourceCount;
    uint8 ResourceIndex;
    FLEXIO_Type *BaseAddr;

    BaseAddr = Flexio_I2s_Ip_pBaseAddr[Instance];
    ResourceCount = Driver->ResourceCount;
    ResourceIndex = Driver->ResourceIndex;
    for (Resource = ResourceIndex; Resource < (ResourceIndex + ResourceCount); Resource++)
    {
        /* Ensure all shifters/timers are disabled */
        Flexio_I2s_Ip_SetShifterMode(BaseAddr, Resource, FLEXIO_SHIFTER_MODE_DISABLED);
        Flexio_I2s_Ip_SetTimerMode(BaseAddr, Resource, FLEXIO_TIMER_MODE_DISABLED);
        /* Ensure all interrupts and DMA requests are disabled */
        Flexio_Mcl_Ip_SetShifterInterrupt(BaseAddr, (uint8)(1U << Resource), FALSE);
        Flexio_Mcl_Ip_SetShifterErrorInterrupt(BaseAddr, (uint8)(1U << Resource), FALSE);
        Flexio_Mcl_Ip_SetTimerInterrupt(BaseAddr, (uint8)(1U << Resource), FALSE);
        Flexio_Mcl_Ip_SetShifterDMARequest(BaseAddr, (uint8)(1U << Resource), FALSE);
        /* Clear any leftover flags */
        Flexio_Mcl_Ip_ClearShifterStatus(BaseAddr, Resource);
        Flexio_Mcl_Ip_ClearShifterErrorStatus(BaseAddr, Resource);
        Flexio_Mcl_Ip_ClearTimerStatus(BaseAddr, Resource);
    }
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_InitDriver
 * Description   : Initializes an Instance of FlexIO driver
 *
 *END**************************************************************************/
static Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_InitDriver(uint8 Instance,
                                                         const Flexio_I2s_Ip_CommonStateType *Driver)
{
    Flexio_I2s_Ip_StatusType RetCode = FLEXIO_I2S_IP_STATUS_SUCCESS;

    uint8 FlexioChannelIndex;
    FlexioChannelIndex = (uint8)((Driver->ResourceIndex)/2U);

    Flexio_I2s_Ip_au8ChannelStatus[FlexioChannelIndex] = 1U;

    /* initialize the allocated resources */
    Flexio_I2s_Ip_ResourcesInit(Instance, Driver);
    (void)RetCode;
    return FLEXIO_I2S_IP_STATUS_SUCCESS;
}

/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_DeinitDriver
 * Description   : De-initializes an Instance of FlexIO driver
 *
 *END**************************************************************************/
static Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_DeinitDriver(const Flexio_I2s_Ip_CommonStateType *Driver)
{
    uint8 Instance;
    uint8 FlexioChannelIndex;

    Instance = Driver->Instance;
    FlexioChannelIndex = (uint8)((Driver->ResourceIndex)/2U);

    Flexio_I2s_Ip_au8ChannelStatus[FlexioChannelIndex] = 0U;
    (void)Instance;

    return FLEXIO_I2S_IP_STATUS_SUCCESS;
}

/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/

/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterInit
 * Description   : Initialize the FLEXIO_I2S Master mode driver
 * @implements : Flexio_I2s_Ip_MasterInit_Activity
 *
 *END**************************************************************************/
Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_MasterInit(uint8 Instance,
                                                uint8 Channel,
                                                const Flexio_I2s_Ip_MasterConfigType * ConfigPtr)
{
    Flexio_I2s_Ip_StatusType RetCode;
    Flexio_I2s_Ip_MasterStateType * Master;
    Flexio_I2s_Ip_StatusType osifError = FLEXIO_I2S_IP_STATUS_SUCCESS;
#if (STD_ON == FLEXIO_I2S_IP_DMA_FEATURE_AVAILABLE)
    uint8 dmaReqTx;
    uint8 dmaReqRx;
#endif

#if (STD_ON == FLEXIO_I2S_IP_DEV_ERROR_DETECT)
    DevAssert(ConfigPtr != NULL_PTR);
    DevAssert(Flexio_I2s_Ip_pxState[Instance][Channel] == NULL_PTR);
    DevAssert(Instance < FLEXIO_INSTANCE_COUNT);
    DevAssert(Channel < FLEXIO_I2S_IP_MAX_CHANNEL_COUNT);
#endif

    Flexio_I2s_Ip_pxState[Instance][Channel] = ConfigPtr->MasterState;
    Master =  Flexio_I2s_Ip_pxState[Instance][Channel];

    /* Instruct the resource allocator that we need two shifters/timers */
    Master->FlexioCommon.ResourceCount = 2U;
    Master->FlexioCommon.ResourceIndex = ConfigPtr->ResourceIndex;

    /* Common FlexIO driver initialization */
    RetCode = (Flexio_I2s_Ip_StatusType)Flexio_I2s_Ip_InitDriver(Instance, &(Master->FlexioCommon));
    if (RetCode != FLEXIO_I2S_IP_STATUS_SUCCESS)
    {   /* Initialization failed, not enough resources */
        return RetCode;
    }

    /* Initialize driver-specific context structure */
    Master->driverType = ConfigPtr->driverType;
    Master->bitsWidth = ConfigPtr->bitsWidth;
    Master->byteWidth = Flexio_I2s_Ip_ComputeByteWidth(ConfigPtr->bitsWidth);
    Master->driverIdle = TRUE;
    Master->callback = ConfigPtr->callback;
    Master->callbackParam = ConfigPtr->callbackParam;
    Master->blocking = FALSE;
    Master->txData = NULL_PTR;
    Master->txRemainingBytes = 0U;
    Master->rxData = NULL_PTR;
    Master->rxRemainingBytes = 0U;
    Master->Master = TRUE;
    Master->status = FLEXIO_I2S_IP_STATUS_SUCCESS;

    /* Configure device for I2S mode */
    Flexio_I2s_Ip_MasterConfigure(Master, ConfigPtr);

    /* Set up transfer engine */
    switch (Master->driverType)
    {
        case FLEXIO_I2S_IP_DRIVER_TYPE_INTERRUPT:

            break;
        case FLEXIO_I2S_IP_DRIVER_TYPE_POLLING:
            /* Nothing to do here, Flexio_I2s_Ip_MasterGetStatus() will handle the transfer */
            break;
#if (STD_ON == FLEXIO_I2S_IP_DMA_FEATURE_AVAILABLE)
        case FLEXIO_I2S_IP_DRIVER_TYPE_DMA:
            /* Store DMA channel numbers */
            /* TODO: Add DMA Support */
            break;
#endif
        default:
            /* Impossible type - do nothing */
            break;
    }

    (void)osifError;
    return FLEXIO_I2S_IP_STATUS_SUCCESS;
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterDeinit
 * Description   : De-initialize the FLEXIO_I2S Master mode driver
 * @implements : Flexio_I2s_Ip_MasterDeinit_Activity
 *
 *END**************************************************************************/
Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_MasterDeinit(uint8 Instance, uint8 Channel)
{
    Flexio_I2s_Ip_StatusType RetStatus = FLEXIO_I2S_IP_STATUS_BUSY;
    const Flexio_I2s_Ip_MasterStateType * Master = Flexio_I2s_Ip_pxState[Instance][Channel];

#if (STD_ON == FLEXIO_I2S_IP_DEV_ERROR_DETECT)
    DevAssert(Master != NULL_PTR);
    DevAssert(Instance < FLEXIO_INSTANCE_COUNT);
    DevAssert(Channel < FLEXIO_I2S_IP_MAX_CHANNEL_COUNT);
#endif

    /* Check if Driver is busy */
    if (Master->driverIdle)
    {
        RetStatus = (Flexio_I2s_Ip_StatusType)Flexio_I2s_Ip_DeinitDriver(&(Master->FlexioCommon));
        Flexio_I2s_Ip_pxState[Instance][Channel] = NULL_PTR;
    }

    return RetStatus;
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterSendData
 * Description   : Perform a non-blocking send transaction on the I2S bus
 * @implements : Flexio_I2s_Ip_MasterSendData_Activity
 *
 *END**************************************************************************/
Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_MasterSendData(uint8 Instance, uint8 Channel,
                                              const uint8 * TxBuff,
                                              uint32 TxSize)
{
    Flexio_I2s_Ip_MasterStateType * Master = Flexio_I2s_Ip_pxState[Instance][Channel];

    FLEXIO_Type *baseAddr;
    uint8 ResourceIndex;    /* Index of first used internal resource Instance (shifter and timer) */

#if (STD_ON == FLEXIO_I2S_IP_DEV_ERROR_DETECT)
    DevAssert(Master != NULL_PTR);
    DevAssert(Instance < FLEXIO_INSTANCE_COUNT);
    DevAssert(Channel < FLEXIO_I2S_IP_MAX_CHANNEL_COUNT);
    DevAssert(TxBuff != NULL_PTR);
    DevAssert(TxSize > 0U);
    DevAssert((TxSize % (uint32)(Master->byteWidth)) == 0U);
#endif

    baseAddr = Flexio_I2s_Ip_pBaseAddr[Master->FlexioCommon.Instance];
    ResourceIndex = Master->FlexioCommon.ResourceIndex;

    /* Check if driver is busy */
    if (!Master->driverIdle)
    {
        return FLEXIO_I2S_IP_STATUS_BUSY;
    }

    Master->txData = TxBuff;
    Master->txRemainingBytes = TxSize;
    /* also count received data, it tells us when tx is actually completed */
    Master->rxRemainingBytes = TxSize;
    Master->rxData = NULL_PTR;
    Master->status = FLEXIO_I2S_IP_STATUS_BUSY;
    Master->driverIdle = FALSE;

    /* Enable pin output */
    Flexio_I2s_Ip_SetShifterPinConfig(baseAddr, TX_SHIFTER(ResourceIndex), FLEXIO_PIN_CONFIG_OUTPUT);
    /* Enable timers and shifters */
    Flexio_I2s_Ip_MasterEnableTransfer(Master);
    /* Enable transfer engine */
    switch (Master->driverType)
    {
        case FLEXIO_I2S_IP_DRIVER_TYPE_INTERRUPT:
            /* Enable interrupts for Tx shifter */
            Flexio_Mcl_Ip_SetShifterInterrupt(baseAddr,
                                 (uint8)((1U << TX_SHIFTER(ResourceIndex)) | (1U << RX_SHIFTER(ResourceIndex))),
                                 TRUE);
            Flexio_Mcl_Ip_SetShifterErrorInterrupt(baseAddr,
                                 (uint8)((1U << TX_SHIFTER(ResourceIndex)) | (1U << RX_SHIFTER(ResourceIndex))),
                                 TRUE);
            break;
        case FLEXIO_I2S_IP_DRIVER_TYPE_POLLING:
            /* Call Flexio_I2s_Ip_MasterCheckStatus once to send the first byte */
            Flexio_I2s_Ip_MasterCheckStatus(Instance, Channel);
            break;
#if (STD_ON == FLEXIO_I2S_IP_DMA_FEATURE_AVAILABLE)
        case FLEXIO_I2S_IP_DRIVER_TYPE_DMA:
        /* TODO: Add DMA support */
            break;
#endif
        default:
            /* Impossible type - do nothing */
            break;
    }

    return FLEXIO_I2S_IP_STATUS_SUCCESS;
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterSendDataBlocking
 * Description   : Perform a blocking send transaction on the I2S bus
 * @implements : Flexio_I2s_Ip_MasterSendDataBlocking_Activity
 *
 *END**************************************************************************/
Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_MasterSendDataBlocking(uint8 Instance, uint8 Channel,
                                                          const uint8 * TxBuff,
                                                          uint32 TxSize,
                                                          uint32 Timeout)
{
    Flexio_I2s_Ip_MasterStateType * Master = Flexio_I2s_Ip_pxState[Instance][Channel];

    /* Check if driver is busy */
    if (!Master->driverIdle)
    {
        return FLEXIO_I2S_IP_STATUS_BUSY;
    }

    /* mark transfer as blocking */
    if (Master->driverType != FLEXIO_I2S_IP_DRIVER_TYPE_POLLING)
    {
        Master->blocking = TRUE;
    }
    /* Call Flexio_I2s_Ip_MasterSendData to start transfer */
    (void)Flexio_I2s_Ip_MasterSendData(Instance, Channel, TxBuff, TxSize);

    /* Wait for transfer to end */
    return Flexio_I2s_Ip_MasterWaitTransferEnd(Master, Timeout);
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterReceiveData
 * Description   : Perform a non-blocking receive transaction on the I2S bus
 * @implements : Flexio_I2s_Ip_MasterReceiveData_Activity
 *
 *END**************************************************************************/
Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_MasterReceiveData(uint8 Instance, uint8 Channel,
                                                     uint8 * RxBuff,
                                                     uint32 RxSize)
{
    Flexio_I2s_Ip_MasterStateType * Master = Flexio_I2s_Ip_pxState[Instance][Channel];

    FLEXIO_Type *baseAddr;
    uint8 ResourceIndex;    /* Index of first used internal resource Instance (shifter and timer) */

#if (STD_ON == FLEXIO_I2S_IP_DEV_ERROR_DETECT)
    DevAssert(Master != NULL_PTR);
    DevAssert(Instance < FLEXIO_INSTANCE_COUNT);
    DevAssert(Channel < FLEXIO_I2S_IP_MAX_CHANNEL_COUNT);
    DevAssert(RxBuff != NULL_PTR);
    DevAssert(RxSize > 0U);
    DevAssert((RxSize % (uint32)(Master->byteWidth)) == 0U);
#endif

    baseAddr = Flexio_I2s_Ip_pBaseAddr[Master->FlexioCommon.Instance];
    ResourceIndex = Master->FlexioCommon.ResourceIndex;

    /* Check if driver is busy */
    if (!Master->driverIdle)
    {
        return FLEXIO_I2S_IP_STATUS_BUSY;
    }

    Master->rxData = RxBuff;
    Master->rxRemainingBytes = RxSize;
    Master->txData = NULL_PTR;
    Master->txRemainingBytes = 0U;
    Master->status = FLEXIO_I2S_IP_STATUS_BUSY;
    Master->driverIdle = FALSE;

    /* Enable timers and shifters */
    Flexio_I2s_Ip_MasterEnableTransfer(Master);

    /* Enable transfer engine */
    switch (Master->driverType)
    {
        case FLEXIO_I2S_IP_DRIVER_TYPE_INTERRUPT:
            /* Enable interrupts for Rx shifter */
            Flexio_Mcl_Ip_SetShifterInterrupt(baseAddr,
                                 (uint8)(1U << RX_SHIFTER(ResourceIndex)),
                                 TRUE);
            Flexio_Mcl_Ip_SetShifterErrorInterrupt(baseAddr,
                                 (uint8)(1U << RX_SHIFTER(ResourceIndex)),
                                 TRUE);
            break;
        case FLEXIO_I2S_IP_DRIVER_TYPE_POLLING:
            /* Call Flexio_I2s_Ip_MasterCheckStatus once to send the first byte */
            Flexio_I2s_Ip_MasterCheckStatus(Instance, Channel);
            break;
#if (STD_ON == FLEXIO_I2S_IP_DMA_FEATURE_AVAILABLE)
        case FLEXIO_I2S_IP_DRIVER_TYPE_DMA:
            /* TODO: Add DMA support */
            break;
#endif
        default:
            /* Impossible type - do nothing */
            break;
    }

    /* For Master we need to send a dummy char to start the clock.
       For Slave just put a 0 in the buffer to keep the tx line clear while receiving. */
    Flexio_I2s_Ip_WriteShifterBuffer(baseAddr, TX_SHIFTER(ResourceIndex), 0x0, FLEXIO_SHIFTER_RW_MODE_BIT_SWAP);

    return FLEXIO_I2S_IP_STATUS_SUCCESS;
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterReceiveDataBlocking
 * Description   : Perform a blocking receive transaction on the I2S bus
 * @implements : Flexio_I2s_Ip_MasterReceiveDataBlocking_Activity
 *
 *END**************************************************************************/
Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_MasterReceiveDataBlocking(uint8 Instance, uint8 Channel,
                                                        uint8 * RxBuff,
                                                        uint32 RxSize,
                                                        uint32 Timeout)
{
    Flexio_I2s_Ip_MasterStateType * Master = Flexio_I2s_Ip_pxState[Instance][Channel];

    /* Check if driver is busy */
    if (!Master->driverIdle)
    {
        return FLEXIO_I2S_IP_STATUS_BUSY;
    }

    /* mark transfer as blocking */
    if (Master->driverType != FLEXIO_I2S_IP_DRIVER_TYPE_POLLING)
    {
        Master->blocking = TRUE;
    }
    /* Call Flexio_I2s_Ip_MasterReceiveData to start transfer */
    (void)Flexio_I2s_Ip_MasterReceiveData(Instance, Channel, RxBuff, RxSize);

    /* Wait for transfer to end */
    return Flexio_I2s_Ip_MasterWaitTransferEnd(Master, Timeout);
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterTransferAbort
 * Description   : Aborts a non-blocking I2S Master transaction
 * @implements : Flexio_I2s_Ip_MasterTransferAbort_Activity
 *
 *END**************************************************************************/
Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_MasterTransferAbort(uint8 Instance, uint8 Channel)
{
    Flexio_I2s_Ip_MasterStateType * Master = Flexio_I2s_Ip_pxState[Instance][Channel];

#if (STD_ON == FLEXIO_I2S_IP_DEV_ERROR_DETECT)
    DevAssert(Master != NULL_PTR);
    DevAssert(Instance < FLEXIO_INSTANCE_COUNT);
    DevAssert(Channel < FLEXIO_I2S_IP_MAX_CHANNEL_COUNT);
#endif

    /* Check if driver is busy */
    if (Master->driverIdle)
    {
        return FLEXIO_I2S_IP_STATUS_SUCCESS;
    }

    Master->status = FLEXIO_I2S_IP_STATUS_ABORTED;
    Flexio_I2s_Ip_MasterStopTransfer(Master);

    return FLEXIO_I2S_IP_STATUS_SUCCESS;
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterGetStatus
 * Description   : Get the status of the current non-blocking I2S Master transaction
 * @implements : Flexio_I2s_Ip_MasterGetStatus_Activity
 *
 *END**************************************************************************/
Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_MasterGetStatus(uint8 Instance, uint8 Channel, uint32 *BytesRemaining)
{
    const Flexio_I2s_Ip_MasterStateType * Master = Flexio_I2s_Ip_pxState[Instance][Channel];

#if (STD_ON == FLEXIO_I2S_IP_DEV_ERROR_DETECT)
    DevAssert(Master != NULL_PTR);
    DevAssert(Instance < FLEXIO_INSTANCE_COUNT);
    DevAssert(Channel < FLEXIO_I2S_IP_MAX_CHANNEL_COUNT);
#endif

    if (!Master->driverIdle)
    {
        switch(Master->driverType)
        {
        case FLEXIO_I2S_IP_DRIVER_TYPE_POLLING:
            /* In polling mode advance the I2S transfer here */
            Flexio_I2s_Ip_MasterCheckStatus(Instance, Channel);
            break;
#if (STD_ON == FLEXIO_I2S_IP_DMA_FEATURE_AVAILABLE)
        case FLEXIO_I2S_IP_DRIVER_TYPE_DMA:
            /* In DMA mode just update the remaining count.
            DO NOT write Master->rxRemainingBytes directly !!! */
            /* TODO: Add DMA support */
            break;
#endif
        default:
            /* Nothing */
            break;
        }

    }

    /* Use rxRemainingBytes even for transmit; byte is not transmitted
    until rx shifter reports a receive event */
    if (BytesRemaining != NULL_PTR)
    {
        *BytesRemaining = Master->rxRemainingBytes;
    }

    if (!Master->driverIdle)
    {
        return FLEXIO_I2S_IP_STATUS_BUSY;
    }
    else
    {
        return Master->status;
    }
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_SlaveInit
 * Description   : Initialize the FLEXIO_I2S Slave mode driver
 * @implements : Flexio_I2s_Ip_SlaveInit_Activity
 *
 *END**************************************************************************/
Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_SlaveInit(uint8 Instance,
                                                uint8 Channel,
                                                const Flexio_I2s_Ip_SlaveConfigType * ConfigPtr)
{
    Flexio_I2s_Ip_StatusType RetCode;
    Flexio_I2s_Ip_MasterStateType * Slave;
    Flexio_I2s_Ip_StatusType osifError = FLEXIO_I2S_IP_STATUS_SUCCESS;
#if (STD_ON == FLEXIO_I2S_IP_DMA_FEATURE_AVAILABLE)
    uint8 dmaReqTx;
    uint8 dmaReqRx;
#endif

#if (STD_ON == FLEXIO_I2S_IP_DEV_ERROR_DETECT)
    DevAssert(ConfigPtr != NULL_PTR);
    DevAssert(Flexio_I2s_Ip_pxState[Instance][Channel] == NULL_PTR);
    DevAssert(Instance < FLEXIO_INSTANCE_COUNT);
    DevAssert(Channel < FLEXIO_I2S_IP_MAX_CHANNEL_COUNT);
#endif

    Flexio_I2s_Ip_pxState[Instance][Channel] = ConfigPtr->SlaveState;
    Slave =  Flexio_I2s_Ip_pxState[Instance][Channel];

    /* Instruct the resource allocator that we need three shifters/timers */
    Slave->FlexioCommon.ResourceCount = 3U;
    Slave->FlexioCommon.ResourceIndex = ConfigPtr->ResourceIndex;

    /* Common FlexIO driver initialization */
    RetCode = (Flexio_I2s_Ip_StatusType)Flexio_I2s_Ip_InitDriver(Instance, &(Slave->FlexioCommon));
    if (RetCode != FLEXIO_I2S_IP_STATUS_SUCCESS)
    {   /* Initialization failed, not enough resources */
        return RetCode;
    }

    /* Initialize driver-specific context structure */
    Slave->driverType = ConfigPtr->driverType;
    Slave->bitsWidth = ConfigPtr->bitsWidth;
    Slave->byteWidth = Flexio_I2s_Ip_ComputeByteWidth(ConfigPtr->bitsWidth);
    Slave->driverIdle = TRUE;
    Slave->callback = ConfigPtr->callback;
    Slave->callbackParam = ConfigPtr->callbackParam;
    Slave->blocking = FALSE;
    Slave->txData = NULL_PTR;
    Slave->txRemainingBytes = 0U;
    Slave->rxData = NULL_PTR;
    Slave->rxRemainingBytes = 0U;
    Slave->Master = FALSE;
    Slave->status = FLEXIO_I2S_IP_STATUS_SUCCESS;

    /* Configure device for I2S mode */
    Flexio_I2s_Ip_SlaveConfigure(Slave, ConfigPtr);

    /* Set up transfer engine */
    switch (Slave->driverType)
    {
        case FLEXIO_I2S_IP_DRIVER_TYPE_INTERRUPT:

            break;
        case FLEXIO_I2S_IP_DRIVER_TYPE_POLLING:
            /* Nothing to do here, Flexio_I2s_Ip_MasterGetStatus() will handle the transfer */
            break;
#if (STD_ON == FLEXIO_I2S_IP_DMA_FEATURE_AVAILABLE)
        case FLEXIO_I2S_IP_DRIVER_TYPE_DMA:
            /* Store DMA channel numbers */
            /* TODO: Add DMA support */
            break;
#endif
        default:
            /* Impossible type - do nothing */
            break;
    }

    (void)osifError;
    return FLEXIO_I2S_IP_STATUS_SUCCESS;
}


/*!
 * @brief De-initialize the FLEXIO_I2S Slave mode driver
 *
 * This function de-initializes the FLEXIO_I2S driver in Slave mode. The driver can't be used
 * again until reinitialized. The context structure is no longer needed by the driver and
 * can be freed after calling this function.
 *
 * @param Slave    Pointer to the FLEXIO_I2S Slave driver context structure.
 * @return    Error or success status returned by API
 * @implements : Flexio_I2s_Ip_SlaveDeinit_Activity
 */
Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_SlaveDeinit(uint8 Instance, uint8 Channel)
{
    return Flexio_I2s_Ip_MasterDeinit(Instance, Channel);
}


/*!
 * @brief Perform a non-blocking send transaction on the I2S bus
 *
 * This function starts the transmission of a block of data and returns immediately.
 * The rest of the transmission is handled by the interrupt service routine (if the driver
 * is initialized in interrupt mode) or by the Flexio_I2s_Ip_SlaveGetStatus function (if
 * the driver is initialized in polling mode).
 * Use Flexio_I2s_Ip_SlaveGetStatus() to check the progress of the transmission.
 *
 * @param Slave    Pointer to the FLEXIO_I2S Slave driver context structure.
 * @param TxBuff    pointer to the data to be transferred
 * @param TxSize    length in bytes of the data to be transferred
 * @return    Error or success status returned by API
 * @implements : Flexio_I2s_Ip_SlaveSendData_Activity
 */
Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_SlaveSendData(uint8 Instance, uint8 Channel,
                                                    const uint8 * TxBuff,
                                                    uint32 TxSize)
{
    return Flexio_I2s_Ip_MasterSendData(Instance, Channel, TxBuff, TxSize);
}


/*!
 * @brief Perform a blocking send transaction on the I2S bus
 *
 * This function sends a block of data, and
 * only returns when the transmission is complete.
 *
 * @param Slave    Pointer to the FLEXIO_I2S Slave driver context structure.
 * @param TxBuff    pointer to the data to be transferred
 * @param TxSize    length in bytes of the data to be transferred
 * @param Timeout  Timeout for the transfer in milliseconds
 * @return    Error or success status returned by API
 * @implements : Flexio_I2s_Ip_SlaveSendDataBlocking_Activity
 */
Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_SlaveSendDataBlocking(uint8 Instance, uint8 Channel,
                                                            const uint8 * TxBuff,
                                                            uint32 TxSize,
                                                            uint32 Timeout)
{
    return Flexio_I2s_Ip_MasterSendDataBlocking(Instance, Channel, TxBuff, TxSize, Timeout);
}


/*!
 * @brief Perform a non-blocking receive transaction on the I2S bus
 *
 * This function starts the reception of a block of data and returns immediately.
 * The rest of the reception is handled by the interrupt service routine (if the driver
 * is initialized in interrupt mode) or by the Flexio_I2s_Ip_SlaveGetStatus function (if
 * the driver is initialized in polling mode).
 * Use Flexio_I2s_Ip_SlaveGetStatus() to check the progress of the reception.
 *
 * @param Slave    Pointer to the FLEXIO_I2S Slave driver context structure.
 * @param RxBuff    pointer to the buffer where to store received data
 * @param RxSize    length in bytes of the data to be transferred
 * @return    Error or success status returned by API
 * @implements : Flexio_I2s_Ip_SlaveReceiveData_Activity
 */
Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_SlaveReceiveData(uint8 Instance, uint8 Channel,
                                                       uint8 * RxBuff,
                                                       uint32 RxSize)
{
    return Flexio_I2s_Ip_MasterReceiveData(Instance, Channel, RxBuff, RxSize);
}


/*!
 * @brief Perform a blocking receive transaction on the I2S bus
 *
 * This function receives a block of data and only returns when the reception is complete.
 *
 * @param Slave    Pointer to the FLEXIO_I2S Slave driver context structure.
 * @param RxBuff    pointer to the buffer where to store received data
 * @param RxSize    length in bytes of the data to be transferred
 * @param Timeout  Timeout for the transfer in milliseconds
 * @return    Error or success status returned by API
 * @implements : Flexio_I2s_Ip_SlaveReceiveDataBlocking_Activity
 */
Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_SlaveReceiveDataBlocking(uint8 Instance, uint8 Channel,
                                                               uint8 * RxBuff,
                                                               uint32 RxSize,
                                                               uint32 Timeout)
{
    return Flexio_I2s_Ip_MasterReceiveDataBlocking(Instance, Channel, RxBuff, RxSize, Timeout);
}


/*!
 * @brief Aborts a non-blocking I2S Slave transaction
 *
 * This function aborts a non-blocking I2S transfer.
 *
 * @param Slave    Pointer to the FLEXIO_I2S Slave driver context structure.
 * @return    Error or success status returned by API
 * Implements : Flexio_I2s_Ip_SlaveTransferAbort_Activity
 */
Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_SlaveTransferAbort(uint8 Instance, uint8 Channel)
{
    return Flexio_I2s_Ip_MasterTransferAbort(Instance, Channel);
}


/*!
 * @brief Get the status of the current non-blocking I2S Slave transaction
 *
 * This function returns the current status of a non-blocking I2S Slave transaction.
 * A return code of FLEXIO_I2S_IP_STATUS_BUSY means the transfer is still in progress.
 * Otherwise the function returns a status reflecting the outcome of the last transfer.
 * When the driver is initialized in polling mode this function also advances the transfer
 * by checking and handling the transmit and receive events, so it must be called
 * frequently to avoid overflows or underflows.
 *
 * @param Slave    Pointer to the FLEXIO_I2S Slave driver context structure.
 * @param BytesRemaining  the remaining number of bytes to be transferred
 * @return    Error or success status returned by API
 * @implements : Flexio_I2s_Ip_SlaveGetStatus_Activity
 */
Flexio_I2s_Ip_StatusType Flexio_I2s_Ip_SlaveGetStatus(uint8 Instance, uint8 Channel, uint32 *BytesRemaining)
{
    return Flexio_I2s_Ip_MasterGetStatus(Instance, Channel, BytesRemaining);
}


/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_MasterCheckEvent
 * Description   : Check if event had occurred for selected FlexIO channel
 *
 *END**************************************************************************/
static boolean Flexio_I2s_Ip_MasterCheckEvent(uint8 StatusMask,
                                              uint8 Channel)
{
    return ((((((uint32)StatusMask) >> Channel) & 1U) == 1U) ? TRUE : FALSE);
}

/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_TransmitEventHandler
 * Description   : handler for transmit event
 *
 *END**************************************************************************/
static void Flexio_I2s_Ip_TransmitEventHandler(Flexio_I2s_Ip_MasterStateType *Master,
                                               uint8 ShifterMaskFlag,
                                               uint8 ShifterErrMaskFlag,
                                               uint8 TimerMaskFlag)
{
    FLEXIO_Type *BaseAddr;
    uint8 ResourceIndex;    /* Index of first used internal resource Instance (shifter and timer) */

    BaseAddr = Flexio_I2s_Ip_pBaseAddr[Master->FlexioCommon.Instance];
    ResourceIndex = Master->FlexioCommon.ResourceIndex;

    /* Handle events for TX shifter or SCK timer */

    if(Flexio_I2s_Ip_MasterCheckEvent(ShifterErrMaskFlag, TX_SHIFTER(ResourceIndex)))
    {
        /*In case the Interrupt is spurious then the ISR shall only clear the interrupt status flag and return immediately*/
        if (FALSE == Flexio_I2s_Ip_GetShifterErrorInterrupt(BaseAddr, TX_SHIFTER(ResourceIndex)))
        {
            /*Clear Error Status flag*/
            Flexio_Mcl_Ip_ClearShifterErrorStatus(BaseAddr, TX_SHIFTER(ResourceIndex));
        }
        else
        {
            Master->status = FLEXIO_I2S_IP_STATUS_TX_UNDERRUN;
            /* don't stop the transfer, continue processing events */
        }
    }

    /* Check if transmitter needs more data */
    if (Flexio_I2s_Ip_MasterCheckEvent(ShifterMaskFlag, TX_SHIFTER(ResourceIndex)))
    {
        /*In case the Interrupt is spurious then the ISR shall only clear the interrupt status flag and return immediately*/
        if (FALSE == Flexio_I2s_Ip_GetShifterInterrupt(BaseAddr, TX_SHIFTER(ResourceIndex)))
        {
            /*Clear Shifter Status flag*/
            Flexio_Mcl_Ip_ClearShifterStatus(BaseAddr, TX_SHIFTER(ResourceIndex));
        }
        else
        {
            Flexio_I2s_Ip_WriteData(Master);
            if (0U == Master->txRemainingBytes)
            {
                /* Done transmitting, disable Tx interrupt */
                Flexio_Mcl_Ip_SetShifterInterrupt(BaseAddr, (uint8)(1U << TX_SHIFTER(ResourceIndex)), FALSE);
                Flexio_Mcl_Ip_SetShifterErrorInterrupt(BaseAddr, (uint8)(1U << TX_SHIFTER(ResourceIndex)), FALSE);
            }
        }
    }

    /* Check if the transfer is over */
    if (Flexio_I2s_Ip_MasterCheckEvent(TimerMaskFlag, SCK_TIMER(ResourceIndex)))
    {
        /*In case the Interrupt is spurious then the ISR shall only clear the interrupt status flag and return immediately*/
        if (FALSE == Flexio_Mcl_Ip_GetTimerInterruptEnable(BaseAddr,SCK_TIMER(ResourceIndex)))
        {
            /* Clear timer status */
            Flexio_Mcl_Ip_ClearTimerStatus(BaseAddr, SCK_TIMER(ResourceIndex));
        }
        else
        {
            if (Master->callback != NULL_PTR)
            {
                Master->callback(FLEXIO_I2S_IP_EVENT_END_TRANSFER, Master->callbackParam);
            }
        }
    }
}
/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_ReceiveEventHandler
 * Description   : handler for receive event
 *
 *END**************************************************************************/
static void Flexio_I2s_Ip_ReceiveEventHandler(Flexio_I2s_Ip_MasterStateType *Master,
                                              uint8 ShifterMaskFlag,
                                              uint8 ShifterErrMaskFlag)
{
    FLEXIO_Type *BaseAddr;
    uint8 ResourceIndex;    /* Index of first used internal resource Instance (shifter and timer) */

    BaseAddr = Flexio_I2s_Ip_pBaseAddr[Master->FlexioCommon.Instance];
    ResourceIndex = Master->FlexioCommon.ResourceIndex;

    if (Flexio_I2s_Ip_MasterCheckEvent(ShifterErrMaskFlag, RX_SHIFTER(ResourceIndex)))
    {
        /*In case the Interrupt is spurious then the ISR shall only clear the interrupt status flag and return immediately*/
        if (FALSE == Flexio_I2s_Ip_GetShifterErrorInterrupt(BaseAddr, RX_SHIFTER(ResourceIndex)))
        {
            /*Clear Error Status flag*/
            Flexio_Mcl_Ip_ClearShifterErrorStatus(BaseAddr, RX_SHIFTER(ResourceIndex));
        }
        else
        {
            Master->status = FLEXIO_I2S_IP_STATUS_RX_OVERRUN;
            /* don't stop the transfer, continue processing events */
        }
    }

#if (STD_ON == FLEXIO_I2S_IP_DMA_FEATURE_AVAILABLE)
    if(Master->driverType != FLEXIO_I2S_IP_DRIVER_TYPE_DMA)
#endif
    {
        /* Check if data was received */
        if (TRUE == Flexio_I2s_Ip_MasterCheckEvent(ShifterMaskFlag, RX_SHIFTER(ResourceIndex)))
        {
            /*In case the Interrupt is spurious then the ISR shall only clear the interrupt status flag and return immediately*/
            if (FALSE == Flexio_I2s_Ip_GetShifterInterrupt(BaseAddr, RX_SHIFTER(ResourceIndex)))
            {
                /*Clear Shifter Status flag*/
                Flexio_Mcl_Ip_ClearShifterStatus(BaseAddr, RX_SHIFTER(ResourceIndex));
            }
            else
            {
                Flexio_I2s_Ip_ReadData(Master);
            }
        }
    }

    /* Check if transfer is over */
    if (Master->rxRemainingBytes == 0U)
    {
        /* Record success if there was no error */
        if (Master->status == FLEXIO_I2S_IP_STATUS_BUSY)
        {
            Master->status = FLEXIO_I2S_IP_STATUS_SUCCESS;
        }
        /* End transfer */
        Flexio_I2s_Ip_MasterStopTransfer(Master);
        /* Call callback to announce the event to the user */
        if (Master->callback != NULL)
        {
            Master->callback(FLEXIO_I2S_IP_EVENT_END_TRANSFER, Master->callbackParam);
        }
    }
}

/*FUNCTION**********************************************************************
 *
 * Function Name : Flexio_I2s_Ip_IrqHandler
 * Description   : Handler for FlexIO I2s channels
 * @implements Flexio_I2s_Ip.c_Artifact
 *END**************************************************************************/
void Flexio_I2s_Ip_IrqHandler(const uint8 FlexIOChannel,
                              uint8 ShifterMaskFlag,
                              uint8 ShifterErrMaskFlag,
                              uint8 TimerMaskFlag)
{
    uint8 ResourceIndex;    /* Index of first used internal resource Instance (shifter and timer) */
    Flexio_I2s_Ip_MasterStateType *State = NULL_PTR;
    uint8 I2sChannel = (uint8)(FlexIOChannel/2U);

    uint8 Instance = 0U;
    State = Flexio_I2s_Ip_pxState[Instance][I2sChannel];

    /* If the driver is not initialized, the ISR shall only clear interrupt status flag and return immediately. */
    if(NULL_PTR == State)
    {
        FLEXIO_Type *BaseAddr = Flexio_I2s_Ip_pBaseAddr[Instance];

        /* Clear timer status */
        Flexio_Mcl_Ip_ClearTimerStatus(BaseAddr, FlexIOChannel);
        /* Clear Shifter status */
        Flexio_Mcl_Ip_ClearShifterStatus(BaseAddr, FlexIOChannel);
        /*Clear Error Status flag*/
        Flexio_Mcl_Ip_ClearShifterErrorStatus(BaseAddr, FlexIOChannel);
    }
    else
    {
        ResourceIndex = State->FlexioCommon.ResourceIndex;
        if (0U != Flexio_I2s_Ip_au8ChannelStatus[I2sChannel])
        {
            if(FlexIOChannel == ResourceIndex)
            {
                Flexio_I2s_Ip_TransmitEventHandler(State, ShifterMaskFlag, ShifterErrMaskFlag, TimerMaskFlag);
            }
            else
            {
                Flexio_I2s_Ip_ReceiveEventHandler(State, ShifterMaskFlag, ShifterErrMaskFlag);
            }
        }
    }
}

#define I2S_STOP_SEC_CODE
#include "I2s_MemMap.h"

#endif /* (STD_ON == FLEXIO_I2S_IP_ENABLE) */

#ifdef __cplusplus
}
#endif

/** @} */
